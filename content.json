{"meta":{"title":"QWHS","subtitle":"纸上得来终觉浅","description":"CV工程师，面向搜索引擎编程","author":"宁中老程","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2020-06-07T07:19:53.000Z","updated":"2020-06-07T07:22:18.159Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-06-07T04:44:54.000Z","updated":"2020-06-07T05:08:53.141Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring MVC 请求处理过程","slug":"Spring-MVC-请求处理过程","date":"2021-09-08T08:03:11.000Z","updated":"2021-09-08T08:43:02.455Z","comments":true,"path":"2021/09/08/Spring-MVC-请求处理过程/","link":"","permalink":"http://yoursite.com/2021/09/08/Spring-MVC-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/","excerpt":"","text":"九大组件SpringMVC几乎所有的功能都由九大组件来完成，所以明白九大组件的作用，对于学习SpringMVC来说非常重要。 1234567891011121314151617181920212223242526/** 文件上传解析器 */private MultipartResolver multipartResolver;/** 区域解析器，用于国际化 */private LocaleResolver localeResolver;/** 主题解析器 */private ThemeResolver themeResolver;/** Handler映射信息 */private List&lt;HandlerMapping&gt; handlerMappings;/** Handler适配器*/private List&lt;HandlerAdapter&gt; handlerAdapters;/** Handler执行异常解析器 */private List&lt;HandlerExceptionResolver&gt; handlerExceptionResolvers;/** 请求到视图的转换器 */private RequestToViewNameTranslator viewNameTranslator;/** SpringMVC允许重定向时携带参数，存在session中，用完就销毁，所以叫FlashMap */private FlashMapManager flashMapManager;/** 视图解析器 */private List&lt;ViewResolver&gt; viewResolvers; HandlerMapping：Handler映射信息，根据请求携带的url信息查找处理器（Handler）。每个请求都需要对应的Handler处理。 HandlerAdapter：Handler适配器，SpringMVC没有直接调用处理器（Handler），而是通过HandlerAdapter来调用，主要是为了统一Handler的调用方式 ViewResolver：视图解析器，用来将字符串类型的视图名称解析为View类型的视图。ViewResolver需要找到渲染所用的模板和所用的技术（也就是视图的类型）进行渲染，具体的渲染过程则交由不同的视图自己完成。 MultipartResolver：文件上传解析器，主要用来处理文件上传请求 HandlerExceptionResolver：Handler执行异常解析器，用来对异常进行统一处理 RequestToViewNameTranslator：请求到视图的转换器 LocaleResolver：区域解析器，用于支持国际化 FlashMapManager：SpringMVC允许重定向时携带参数，存在session中，用完就销毁，所以叫FlashMap ThemeResolver：主题解析器，用于支持不同的主题 九大组件中最重的的前三个，HandlerMapping、HandlerAdapter和ViewResolver，因为这是阅读源码时，避不开的三个组件。 调试准备 搭建一个基本的Spring web项目 Controller部分 12345678910111213141516171819202122232425@Controllerpublic class IndexController &#123; @RequestMapping(\"/index/home\") public String home(String id, Student student, @RequestParam(\"code\") String code) &#123; System.out.println(student.getName()); return \"index\"; &#125; @ResponseBody @RequestMapping(\"/index/list\") public String list() &#123; return \"success\"; &#125;&#125;Entity部分public class Student &#123; private String name; private Integer gender; // getter、setter&#125; 核心方法我们都知道，SpringMVC有一个用来分发请求的前端控制器DispatcherServlet，其中用来处理请求的方法就是doService，该方法定义如下 doService 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Exposes the DispatcherServlet-specific request attributes and delegates to &#123;@link #doDispatch&#125; * for the actual dispatching. */@Overrideprotected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; logRequest(request); // Keep a snapshot of the request attributes in case of an include, // to be able to restore the original attributes after the include. Map&lt;String, Object&gt; attributesSnapshot = null; if (WebUtils.isIncludeRequest(request)) &#123; attributesSnapshot = new HashMap&lt;&gt;(); Enumeration&lt;?&gt; attrNames = request.getAttributeNames(); while (attrNames.hasMoreElements()) &#123; String attrName = (String) attrNames.nextElement(); if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123; attributesSnapshot.put(attrName, request.getAttribute(attrName)); &#125; &#125; &#125; // Make framework objects available to handlers and view objects. request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext()); request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver); request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver); request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource()); if (this.flashMapManager != null) &#123; FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response); if (inputFlashMap != null) &#123; request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap)); &#125; request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap()); request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager); &#125; try &#123; // 真正执行的方法 doDispatch(request, response); &#125; finally &#123; if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123; // Restore the original attribute snapshot, in case of an include. if (attributesSnapshot != null) &#123; restoreAttributesAfterInclude(request, attributesSnapshot); &#125; &#125; &#125;&#125; doDispatchdoDispatch是doService中真正用来处理请求的方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** * 实际处理请求的方法 */protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; // 校验是否是文件上传请求 processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // Determine handler for the current request. // 为当前请求找到一个合适的处理器（Handler） // 返回值是一个HandlerExecutionChain，也就是处理器执行链 mappedHandler = getHandler(processedRequest); if (mappedHandler == null) &#123; noHandlerFound(processedRequest, response); return; &#125; // Determine handler adapter for the current request. // 根据HandlerExecutionChain携带的Handler找到合适的HandlerAdapter HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler. // 处理GET请求的缓存 String method = request.getMethod(); boolean isGet = \"GET\".equals(method); if (isGet || \"HEAD\".equals(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; // 执行拦截器的preHandle方法 if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; // Actually invoke the handler. // 利用HandlerAdapter来执行Handler里对应的处理方法 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; // 如果没有设置视图，则应用默认的视图名 applyDefaultViewName(processedRequest, mv); // 执行拦截器的postHandle方法 mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; catch (Exception ex) &#123; dispatchException = ex; &#125; catch (Throwable err) &#123; // As of 4.3, we're processing Errors thrown from handler methods as well, // making them available for @ExceptionHandler methods and other scenarios. dispatchException = new NestedServletException(\"Handler dispatch failed\", err); &#125; // 根据ModelAndView对象解析视图 processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; catch (Exception ex) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, ex); &#125; catch (Throwable err) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(\"Handler processing failed\", err)); &#125; finally &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; // Instead of postHandle and afterCompletion if (mappedHandler != null) &#123; mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); &#125; &#125; else &#123; // Clean up any resources used by a multipart request. if (multipartRequestParsed) &#123; cleanupMultipart(processedRequest); &#125; &#125; &#125;&#125; 该方法就是SpringMVC处理请求的整体流程，其中涉及到几个重要的方法。 getHandler该方法定义如下 12345678910111213141516/** * Return the HandlerExecutionChain for this request. * 为这个request返回一个HandlerExecutionChain */@Nullableprotected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; if (this.handlerMappings != null) &#123; for (HandlerMapping mapping : this.handlerMappings) &#123; HandlerExecutionChain handler = mapping.getHandler(request); if (handler != null) &#123; return handler; &#125; &#125; &#125; return null;&#125; 调试信息如下 根据调试信息可以看出，getHandler方法主要是从List&lt;HandlerMapping&gt; handlerMappings集合中遍历查找一个合适的处理器（Handler），返回的结果是一个HandlerExecutionChain。然后再根据HandlerExecutionChain里携带的Handler去获取HandlerAdapter。 getHandlerAdaptergetHandlerAdapter方法定义如下 12345678910111213141516/** * Return the HandlerAdapter for this handler object. * @param handler the handler object to find an adapter for * @throws ServletException if no HandlerAdapter can be found for the handler. This is a fatal error. */ protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException &#123; if (this.handlerAdapters != null) &#123; for (HandlerAdapter adapter : this.handlerAdapters) &#123; if (adapter.supports(handler)) &#123; return adapter; &#125; &#125; &#125; throw new ServletException(\"No adapter for handler [\" + handler + \"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler\"); &#125; 同样getHandlerAdapter方法主要是从List&lt;HandlerAdapter&gt; handlerAdapters集合中遍历查找一个合适的处理器适配器（HandlerAdapter），返回的结果是一个HandlerAdapter。 可以看到此处HandlerAdapter真正的实现类是RequestMappingHandlerAdapter。 processDispatchResultprocessDispatchResult方法主要根据方法执行完成后封装的ModelAndView，转发到对应页面，定义如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Handle the result of handler selection and handler invocation, which is * either a ModelAndView or an Exception to be resolved to a ModelAndView. */private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv, @Nullable Exception exception) throws Exception &#123; boolean errorView = false; if (exception != null) &#123; if (exception instanceof ModelAndViewDefiningException) &#123; logger.debug(\"ModelAndViewDefiningException encountered\", exception); mv = ((ModelAndViewDefiningException) exception).getModelAndView(); &#125; else &#123; Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null); mv = processHandlerException(request, response, handler, exception); errorView = (mv != null); &#125; &#125; // Did the handler return a view to render? if (mv != null &amp;&amp; !mv.wasCleared()) &#123; // 主要调用该方法渲染视图 render(mv, request, response); if (errorView) &#123; WebUtils.clearErrorRequestAttributes(request); &#125; &#125; else &#123; if (logger.isTraceEnabled()) &#123; logger.trace(\"No view rendering, null ModelAndView returned.\"); &#125; &#125; if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123; // Concurrent handling started during a forward return; &#125; if (mappedHandler != null) &#123; // Exception (if any) is already handled.. mappedHandler.triggerAfterCompletion(request, response, null); &#125;&#125; renderrender方法定义如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Render the given ModelAndView. * &lt;p&gt;This is the last stage in handling a request. It may involve resolving the view by name. * @param mv the ModelAndView to render * @param request current HTTP servlet request * @param response current HTTP servlet response * @throws ServletException if view is missing or cannot be resolved * @throws Exception if there's a problem rendering the view */protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; // Determine locale for request and apply it to the response. Locale locale = (this.localeResolver != null ? this.localeResolver.resolveLocale(request) : request.getLocale()); response.setLocale(locale); View view; String viewName = mv.getViewName(); if (viewName != null) &#123; // We need to resolve the view name. // 根据给定的视图名称，解析获取View对象 view = resolveViewName(viewName, mv.getModelInternal(), locale, request); if (view == null) &#123; throw new ServletException(\"Could not resolve view with name '\" + mv.getViewName() + \"' in servlet with name '\" + getServletName() + \"'\"); &#125; &#125; else &#123; // No need to lookup: the ModelAndView object contains the actual View object. view = mv.getView(); if (view == null) &#123; throw new ServletException(\"ModelAndView [\" + mv + \"] neither contains a view name nor a \" + \"View object in servlet with name '\" + getServletName() + \"'\"); &#125; &#125; // Delegate to the View object for rendering. if (logger.isTraceEnabled()) &#123; logger.trace(\"Rendering view [\" + view + \"] \"); &#125; try &#123; if (mv.getStatus() != null) &#123; response.setStatus(mv.getStatus().value()); &#125; view.render(mv.getModelInternal(), request, response); &#125; catch (Exception ex) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Error rendering view [\" + view + \"]\", ex); &#125; throw ex; &#125;&#125; resolveViewNameresolveViewName方法定义如下 1234567891011121314@Nullableprotected View resolveViewName(String viewName, @Nullable Map&lt;String, Object&gt; model, Locale locale, HttpServletRequest request) throws Exception &#123; if (this.viewResolvers != null) &#123; for (ViewResolver viewResolver : this.viewResolvers) &#123; View view = viewResolver.resolveViewName(viewName, locale); if (view != null) &#123; return view; &#125; &#125; &#125; return null;&#125; 根据调试信息可以看到真正解析视图的ViewResolver的是InternalResourceViewResolver类，也就是我们经常配置的一项类型 12345&lt;!-- 定义视图文件解析 --&gt;&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/views/\" /&gt; &lt;property name=\"suffix\" value=\".html\" /&gt;&lt;/bean&gt; 至此我们就得到了SpringMVC处理请求的完整逻辑 但是，有两个重要的问题没有解决，那就是：参数绑定和返回值处理。 &gt; 因为在编写Controller里面的方法的时候，各种类型的参数都有，SpringMVC是怎么处理不同类型的参数的呢？&gt; SpringMVC处理请求完成后，一定会返回ModelAndView吗，如果加了@ResponseBody注解呢？ 参数绑定在整个流程中，还有一个最重要的方法，那就是真正执行handler的方法，参数的绑定和返回值的处理都在这个方法里，也就是 12// Actually invoke the handler.mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); handlehandle方法的作用是根据请求参数，执行真正的处理方法，并且返回合适的ModelAndView对象，也有可能返回null。该方法定义如下在AbstractHandlerMethodAdapter类中 12345678910/** * This implementation expects the handler to be an &#123;@link HandlerMethod&#125;. */@Override@Nullablepublic final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return handleInternal(request, response, (HandlerMethod) handler);&#125; 可以看到这个方法实现只有一行代码 handleInternal继续深入handleInternal方法 123456789101112131415161718192021222324252627282930313233343536373839@Overrideprotected ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; ModelAndView mav; // 校验指定的请求以获取受支持的方法类型（GET、POST等）和所需的session checkRequest(request); // Execute invokeHandlerMethod in synchronized block if required. if (this.synchronizeOnSession) &#123; HttpSession session = request.getSession(false); if (session != null) &#123; Object mutex = WebUtils.getSessionMutex(session); synchronized (mutex) &#123; mav = invokeHandlerMethod(request, response, handlerMethod); &#125; &#125; else &#123; // No HttpSession available -&gt; no mutex necessary mav = invokeHandlerMethod(request, response, handlerMethod); &#125; &#125; else &#123; // No synchronization on session demanded at all... // 真正执行handler的方法 mav = invokeHandlerMethod(request, response, handlerMethod); &#125; if (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123; if (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123; applyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers); &#125; else &#123; prepareResponse(response); &#125; &#125; return mav;&#125; invokeHandlerMethod继续深入invokeHandlerMethod方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * Invoke the &#123;@link RequestMapping&#125; handler method preparing a &#123;@link ModelAndView&#125; * if view resolution is required. * 执行@RequestMapping标注的handler方法，如果需要解析视图就准备一个ModelAndView */@Nullableprotected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; ServletWebRequest webRequest = new ServletWebRequest(request, response); try &#123; WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod); ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory); // HandlerMethod接口封装执行方法的信息，提供对方法参数，方法返回值，方法注释等的便捷访问。 ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod); if (this.argumentResolvers != null) &#123; invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers); &#125; if (this.returnValueHandlers != null) &#123; invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers); &#125; invocableMethod.setDataBinderFactory(binderFactory); invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer); // ModelAndViewContainer可以看做ModelAndView的上下文容器，关联着Model和View的信息 ModelAndViewContainer mavContainer = new ModelAndViewContainer(); mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request)); modelFactory.initModel(webRequest, mavContainer, invocableMethod); mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect); AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response); asyncWebRequest.setTimeout(this.asyncRequestTimeout); WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); asyncManager.setTaskExecutor(this.taskExecutor); asyncManager.setAsyncWebRequest(asyncWebRequest); asyncManager.registerCallableInterceptors(this.callableInterceptors); asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors); if (asyncManager.hasConcurrentResult()) &#123; Object result = asyncManager.getConcurrentResult(); mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0]; asyncManager.clearConcurrentResult(); LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123; String formatted = LogFormatUtils.formatValue(result, !traceOn); return \"Resume with async result [\" + formatted + \"]\"; &#125;); invocableMethod = invocableMethod.wrapConcurrentResult(result); &#125; // 真正执行Handler的方法 invocableMethod.invokeAndHandle(webRequest, mavContainer); if (asyncManager.isConcurrentHandlingStarted()) &#123; return null; &#125; // 获取ModelAndeView对象 return getModelAndView(mavContainer, modelFactory, webRequest); &#125; finally &#123; webRequest.requestCompleted(); &#125;&#125; invokeAndHandle invokeAndHandle方法的作用是执行并处理真正响应请求的方法，该方法定义如下 123456789101112131415161718192021222324252627282930313233343536373839/** * Invoke the method and handle the return value through one of the * configured &#123;@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers&#125;. * @param webRequest the current request * @param mavContainer the ModelAndViewContainer for this request * @param providedArgs \"given\" arguments matched by type (not resolved) */public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; // 执行handler的方法 Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs); setResponseStatus(webRequest); if (returnValue == null) &#123; if (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) &#123; disableContentCachingIfNecessary(webRequest); mavContainer.setRequestHandled(true); return; &#125; &#125; else if (StringUtils.hasText(getResponseStatusReason())) &#123; mavContainer.setRequestHandled(true); return; &#125; mavContainer.setRequestHandled(false); Assert.state(this.returnValueHandlers != null, \"No return value handlers\"); try &#123; this.returnValueHandlers.handleReturnValue( returnValue, getReturnValueType(returnValue), mavContainer, webRequest); &#125; catch (Exception ex) &#123; if (logger.isTraceEnabled()) &#123; logger.trace(formatErrorForReturnValue(returnValue), ex); &#125; throw ex; &#125;&#125; invokeForRequest12345678910111213141516171819202122232425262728293031/** * Invoke the method after resolving its argument values in the context of the given request. * &lt;p&gt;Argument values are commonly resolved through * &#123;@link HandlerMethodArgumentResolver HandlerMethodArgumentResolvers&#125;. * The &#123;@code providedArgs&#125; parameter however may supply argument values to be used directly, * i.e. without argument resolution. Examples of provided argument values include a * &#123;@link WebDataBinder&#125;, a &#123;@link SessionStatus&#125;, or a thrown exception instance. * Provided argument values are checked before argument resolvers. * &lt;p&gt;Delegates to &#123;@link #getMethodArgumentValues&#125; and calls &#123;@link #doInvoke&#125; with the * resolved arguments. * @param request the current request * @param mavContainer the ModelAndViewContainer for this request * @param providedArgs \"given\" arguments matched by type, not resolved * @return the raw value returned by the invoked method * @throws Exception raised if no suitable argument resolver can be found, * or if the method raised an exception * @see #getMethodArgumentValues * @see #doInvoke */@Nullablepublic Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; // 获取参数 Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs); if (logger.isTraceEnabled()) &#123; logger.trace(\"Arguments: \" + Arrays.toString(args)); &#125; // 执行 return doInvoke(args);&#125; 真正的执行无非就是通过反射invoke，所以更重要的是参数是如何绑定的，详情就在getMethodArgumentValues方法 getMethodArgumentValuesgetMethodArgumentValues方法用于从request请求中获取真正的参数，返回的是Object数组，该方法定义如下 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Get the method argument values for the current request, checking the provided * argument values and falling back to the configured argument resolvers. * &lt;p&gt;The resulting array will be passed into &#123;@link #doInvoke&#125;. * @since 5.1.2 */protected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; // 获取方法上所有的参数 MethodParameter[] parameters = getMethodParameters(); if (ObjectUtils.isEmpty(parameters)) &#123; return EMPTY_ARGS; &#125; Object[] args = new Object[parameters.length]; for (int i = 0; i &lt; parameters.length; i++) &#123; MethodParameter parameter = parameters[i]; parameter.initParameterNameDiscovery(this.parameterNameDiscoverer); args[i] = findProvidedArgument(parameter, providedArgs); if (args[i] != null) &#123; continue; &#125; if (!this.resolvers.supportsParameter(parameter)) &#123; throw new IllegalStateException(formatArgumentError(parameter, \"No suitable resolver\")); &#125; try &#123; args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory); &#125; catch (Exception ex) &#123; // Leave stack trace for later, exception may actually be resolved and handled... if (logger.isDebugEnabled()) &#123; String exMsg = ex.getMessage(); if (exMsg != null &amp;&amp; !exMsg.contains(parameter.getExecutable().toGenericString())) &#123; logger.debug(formatArgumentError(parameter, exMsg)); &#125; &#125; throw ex; &#125; &#125; return args;&#125; 根据调试信息可以看到，用来处理请求参数的类是HandlerMethodArgumentResolver接口的实现类HandlerMethodArgumentResolverComposite，此时正在处理的参数是一个Student对象，并且已经把值注绑定了，也就是说真正执行绑定的是方法resolveArgument resolveArgumentresolveArgument是真正执行绑定的的方法 1234567891011121314151617181920/** * Iterate over registered * &#123;@link HandlerMethodArgumentResolver HandlerMethodArgumentResolvers&#125; * and invoke the one that supports it. * @throws IllegalArgumentException if no suitable argument resolver is found */@Override@Nullablepublic Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123; // 获取合适的参数解析器 HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter); if (resolver == null) &#123; throw new IllegalArgumentException(\"Unsupported parameter type [\" + parameter.getParameterType().getName() + \"]. supportsParameter should be called first.\"); &#125; // 执行参数绑定 return resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);&#125; getArgumentResolvergetArgumentResolver该方法用于执行参数的绑定，定义如下 123456789101112131415161718/** * Find a registered &#123;@link HandlerMethodArgumentResolver&#125; that supports * the given method parameter. */@Nullableprivate HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) &#123; HandlerMethodArgumentResolver result = this.argumentResolverCache.get(parameter); if (result == null) &#123; for (HandlerMethodArgumentResolver resolver : this.argumentResolvers) &#123; if (resolver.supportsParameter(parameter)) &#123; result = resolver; this.argumentResolverCache.put(parameter, result); break; &#125; &#125; &#125; return result;&#125; 该方法的逻辑就是先从argumentResolver缓存中找到能够执行参数绑定的HandlerMethodArgumentResolver，如果找不到就从HandlerMethodArgumentResolver找，SpringMVC支持的HandlerMethodArgumentResolver一共有26种，用来解析各种类型的参数 RequestParamMethodArgumentResolver：处理普通参数（基本类型、包装类型、String），不管加不加@RequestParam注解 ServletModelAttributeMethodProcessor：处理POJO类型的参数，比如自定义的Student对象 RequestResponseBodyMethodProcessor：处理@RequestBody注解类型的参数 resolveArgument由于不同类型的参数有不同的HandlerMethodArgumentResolver来处理，此处选取POJO类型参数的注入实现，对应的参数解析类是ModelAttributeMethodProcessor，其中resolveArgument方法用来解析（绑定）参数方法定义如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * Resolve the argument from the model or if not found instantiate it with * its default if it is available. The model attribute is then populated * with request values via data binding and optionally validated * if &#123;@code @java.validation.Valid&#125; is present on the argument. * @throws BindException if data binding and validation result in an error * and the next method parameter is not of type &#123;@link Errors&#125; * @throws Exception if WebDataBinder initialization fails */@Override@Nullablepublic final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123; Assert.state(mavContainer != null, \"ModelAttributeMethodProcessor requires ModelAndViewContainer\"); Assert.state(binderFactory != null, \"ModelAttributeMethodProcessor requires WebDataBinderFactory\"); // 获取参数名 String name = ModelFactory.getNameForParameter(parameter); // 获取参数上的ModelAttribute注解 ModelAttribute ann = parameter.getParameterAnnotation(ModelAttribute.class); if (ann != null) &#123; mavContainer.setBinding(name, ann.binding()); &#125; Object attribute = null; BindingResult bindingResult = null; if (mavContainer.containsAttribute(name)) &#123; attribute = mavContainer.getModel().get(name); &#125; else &#123; // Create attribute instance try &#123; // 创建参数类型的实例（未注入值），底层就是通过反射调用构造方法 attribute = createAttribute(name, parameter, binderFactory, webRequest); &#125; catch (BindException ex) &#123; if (isBindExceptionRequired(parameter)) &#123; // No BindingResult parameter -&gt; fail with BindException throw ex; &#125; // Otherwise, expose null/empty value and associated BindingResult if (parameter.getParameterType() == Optional.class) &#123; attribute = Optional.empty(); &#125; bindingResult = ex.getBindingResult(); &#125; &#125; if (bindingResult == null) &#123; // Bean property binding and validation; // skipped in case of binding failure on construction. WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name); if (binder.getTarget() != null) &#123; if (!mavContainer.isBindingDisabled(name)) &#123; // 真正执行绑定（值注入）的方法 bindRequestParameters(binder, webRequest); &#125; validateIfApplicable(binder, parameter); if (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123; throw new BindException(binder.getBindingResult()); &#125; &#125; // Value type adaptation, also covering java.util.Optional if (!parameter.getParameterType().isInstance(attribute)) &#123; attribute = binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter); &#125; bindingResult = binder.getBindingResult(); &#125; // Add resolved attribute and BindingResult at the end of the model Map&lt;String, Object&gt; bindingResultModel = bindingResult.getModel(); mavContainer.removeAttributes(bindingResultModel); mavContainer.addAllAttributes(bindingResultModel); return attribute;&#125; 根据调试信息也可以看到bindRequestParameters(binder, webRequest)执行完成之后，POJO类型的参数已经完成了绑定。 bindRequestParameters12345678910111213/** * This implementation downcasts &#123;@link WebDataBinder&#125; to * &#123;@link ServletRequestDataBinder&#125; before binding. * @see ServletRequestDataBinderFactory */@Overrideprotected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) &#123; ServletRequest servletRequest = request.getNativeRequest(ServletRequest.class); Assert.state(servletRequest != null, \"No ServletRequest\"); ServletRequestDataBinder servletBinder = (ServletRequestDataBinder) binder; // 执行绑定的方法 servletBinder.bind(servletRequest);&#125; bind继续深入bind方法 12345678910111213public void bind(ServletRequest request) &#123; // 获取所有参数的键值对 MutablePropertyValues mpvs = new ServletRequestParameterPropertyValues(request); // 处理文件上传请求 MultipartRequest multipartRequest = WebUtils.getNativeRequest(request, MultipartRequest.class); if (multipartRequest != null) &#123; bindMultipart(multipartRequest.getMultiFileMap(), mpvs); &#125; // 把url中携带的参数也加入到MutablePropertyValues addBindValues(mpvs, request); // 执行绑定（注入值） doBind(mpvs);&#125; 由于调用层次过深，所以无法一步步列出下面的步骤，doBind方法的原理还是通过调用POJO对象里的setter方法设置值，可以查看最终的调试信息 根据调试信息可以看到，最终执行的还是POJO对象的setter方法，具体执行的类是BeanWrapperImpl。 了解了参数的绑定，再来看返回值的处理。 返回值处理invokeAndHandle回到源码invokeAndHandle方法处（ServletInvocableHandlerMethod类中），该方法定义如下 123456789101112131415161718192021222324252627282930313233343536373839/** * Invoke the method and handle the return value through one of the * configured &#123;@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers&#125;. * @param webRequest the current request * @param mavContainer the ModelAndViewContainer for this request * @param providedArgs \"given\" arguments matched by type (not resolved) */public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs); setResponseStatus(webRequest); if (returnValue == null) &#123; if (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) &#123; disableContentCachingIfNecessary(webRequest); mavContainer.setRequestHandled(true); return; &#125; &#125; else if (StringUtils.hasText(getResponseStatusReason())) &#123; mavContainer.setRequestHandled(true); return; &#125; mavContainer.setRequestHandled(false); Assert.state(this.returnValueHandlers != null, \"No return value handlers\"); try &#123; // 真正处理不同类型返回值的方法 this.returnValueHandlers.handleReturnValue( returnValue, getReturnValueType(returnValue), mavContainer, webRequest); &#125; catch (Exception ex) &#123; if (logger.isTraceEnabled()) &#123; logger.trace(formatErrorForReturnValue(returnValue), ex); &#125; throw ex; &#125;&#125; 真正处理不同类型的返回值的方法是handleReturnValue方法 handleReturnValue12345678910111213141516/** * Iterate over registered &#123;@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers&#125; and invoke the one that supports it. * @throws IllegalStateException if no suitable &#123;@link HandlerMethodReturnValueHandler&#125; is found. */@Overridepublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception &#123; // 根据返回值个返回值类型选取合适的HandlerMethodReturnValueHandler HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType); if (handler == null) &#123; throw new IllegalArgumentException(\"Unknown return value type: \" + returnType.getParameterType().getName()); &#125; // 真正的处理返回值 handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);&#125; selectHandler12345678910111213@Nullableprivate HandlerMethodReturnValueHandler selectHandler(@Nullable Object value, MethodParameter returnType) &#123; boolean isAsyncValue = isAsyncReturnValue(value, returnType); for (HandlerMethodReturnValueHandler handler : this.returnValueHandlers) &#123; if (isAsyncValue &amp;&amp; !(handler instanceof AsyncHandlerMethodReturnValueHandler)) &#123; continue; &#125; if (handler.supportsReturnType(returnType)) &#123; return handler; &#125; &#125; return null;&#125; 根据调试信息可以看到，SpringMVC为返回值提供了15个HandlerMethodReturnValueHandler的实现了来处理不同类型的返回值。 事实上，用来处理@ResponseBody类型的是RequestResponseBodyMethodProcessor。 如果对前文参数绑定还有印象的话，会发现@RequestBody类型参数绑定也是用的这个类。 继续跟进RequestResponseBodyMethodProcessor类的handleReturnValue方法 handleReturnValueRequestResponseBodyMethodProcessor类的handleReturnValue方法定义如下 这里设置了一个非常重要的属性requestHandled，这个属性关系到是否需要返回ModelAndView对象 1234567891011121314151617@Overridepublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException &#123; // 设置该请求是否已在处理程序中完全处理，例如@ResponseBody方法不需要视图解析器，此处就可以设置为true。 // 当控制器方法声明类型为ServletResponse或OutputStream的参数时，也可以设置此标志为true。 // 这个属性设置成true之后，上层getModelAndView获取ModelAndView时会返回Null，因为不需要视图。 // 默认值为false mavContainer.setRequestHandled(true); ServletServerHttpRequest inputMessage = createInputMessage(webRequest); ServletServerHttpResponse outputMessage = createOutputMessage(webRequest); // Try even with null return value. ResponseBodyAdvice could get involved. // 底层就是利用java.io.OutputStreamWriter类把返回值写到网络IO writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);&#125; 继续深入writeWithMessageConverters方法，一步步调试到最后，底层就是利用java.io.OutputStreamWriter类把返回值写到网络IO 由于handleReturnValue把requestHandled设置成了true，上层在调用getModelAndView方法时会返回null，表示该请求不需要视图。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"spring","slug":"java/spring","permalink":"http://yoursite.com/categories/java/spring/"},{"name":"springMVC","slug":"java/spring/springMVC","permalink":"http://yoursite.com/categories/java/spring/springMVC/"}],"tags":[{"name":"mvc\"","slug":"mvc","permalink":"http://yoursite.com/tags/mvc/"}]},{"title":"16 条 yyds 的代码规范","slug":"16-条-yyds-的代码规范","date":"2021-08-10T08:22:09.000Z","updated":"2021-08-10T08:45:53.123Z","comments":true,"path":"2021/08/10/16-条-yyds-的代码规范/","link":"","permalink":"http://yoursite.com/2021/08/10/16-%E6%9D%A1-yyds-%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/","excerpt":"","text":"MyBatis 不要为了多个查询条件而写 1 = 1 当遇到多个查询条件，使用where 1=1 可以很方便的解决我们的问题，但是这样很可能会造成非常大的性能损失，因为添加了 “where 1=1 ”的过滤条件之后，数据库系统就无法使用索引等查询优化策略，数据库系统将会被迫对每行数据进行扫描（即全表扫描） 以比较此行是否满足过滤条件，当表中的数据量较大时查询速度会非常慢；此外，还会存在SQL 注入的风险。 反例： 123456789&lt;select id=\"queryBookInfo\" parameterType=\"com.tjt.platform.entity.BookInfo\" resultType=\"java.lang.Integer\"&gt; select count(*) from t_rule_BookInfo t where 1=1&lt;if test=\"title !=null and title !='' \"&gt; AND title = #&#123;title&#125;&lt;/if&gt;&lt;if test=\"author !=null and author !='' \"&gt; AND author = #&#123;author&#125;&lt;/if&gt;&lt;/select&gt; 正例： 1234567891011&lt;select id=\"queryBookInfo\" parameterType=\"com.tjt.platform.entity.BookInfo\" resultType=\"java.lang.Integer\"&gt; select count(*) from t_rule_BookInfo t&lt;where&gt;&lt;if test=\"title !=null and title !='' \"&gt; title = #&#123;title&#125;&lt;/if&gt;&lt;if test=\"author !=null and author !='' \"&gt; AND author = #&#123;author&#125;&lt;/if&gt;&lt;/where&gt;&lt;/select&gt; UPDATE 操作也一样，可以用标记代替 1=1。 迭代entrySet() 获取Map 的key 和value 当循环中只需要获取Map 的主键key时，迭代keySet() 是正确的；但是，当需要主键key 和取值value 时，迭代entrySet() 才是更高效的做法，其比先迭代keySet() 后再去通过get 取值性能更佳。 反例： 12345//Map 获取value 反例:HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();for (String key : map.keySet())&#123; String value = map.get(key);&#125; 正例： 123456//Map 获取key &amp; value 正例:HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();for (Map.Entry&lt;String,String&gt; entry : map.entrySet())&#123; String key = entry.getKey(); String value = entry.getValue();&#125; 使用Collection.isEmpty() 检测空 使用Collection.size() 来检测是否为空在逻辑上没有问题，但是使用Collection.isEmpty() 使得代码更易读，并且可以获得更好的性能；除此之外，任何Collection.isEmpty() 实现的时间复杂度都是O(1) ，不需要多次循环遍历，但是某些通过Collection.size() 方法实现的时间复杂度可能是O(n)，或者使用第三方工具类如：Hutool 提供的集合检查工具。 反例： 1234LinkedList&lt;Object&gt; collection = new LinkedList&lt;&gt;();if (collection.size() == 0)&#123; System.out.println(\"collection is empty.\");&#125; 正例： 12345678910LinkedList&lt;Object&gt; collection = new LinkedList&lt;&gt;();if (collection.isEmpty())&#123; System.out.println(\"collection is empty.\");&#125;//检测是否为null 可以使用CollectionUtils.isEmpty()if (CollectionUtils.isEmpty(collection))&#123; System.out.println(\"collection is null.\");&#125; 初始化集合时尽量指定其大小 尽量在初始化时指定集合的大小，能有效减少集合的扩容次数，因为集合每次扩容的时间复杂度很可能时O(n)，耗费时间和性能。 反例： 123456//初始化list，往list 中添加元素反例：int[] arr = new int[]&#123;1,2,3,4&#125;;List&lt;Integer&gt; list = new ArrayList&lt;&gt;();for (int i : arr)&#123; list.add(i);&#125; 正例： 1234567//初始化list，往list 中添加元素正例：int[] arr = new int[]&#123;1,2,3,4&#125;;//指定集合list 的容量大小List&lt;Integer&gt; list = new ArrayList&lt;&gt;(arr.length);for (int i : arr)&#123; list.add(i);&#125; 使用StringBuilder 拼接字符串 一般的字符串拼接在编译期Java 会对其进行优化，但是在循环中字符串的拼接Java 编译期无法执行优化，所以需要使用StringBuilder 进行替换。 反例： 123456//在循环中拼接字符串反例String str = \"\";for (int i = 0; i &lt; 10; i++)&#123; //在循环中字符串拼接Java 不会对其进行优化 str += i;&#125; 正例： 123456789//在循环中拼接字符串正例String str1 = \"Love\";String str2 = \"Courage\";String strConcat = str1 + str2; //Java 编译器会对该普通模式的字符串拼接进行优化StringBuilder sb = new StringBuilder();for (int i = 0; i &lt; 10; i++)&#123; //在循环中，Java 编译器无法进行优化，所以要手动使用StringBuilder sb.append(i);&#125; 若需频繁调用Collection.contains 方法则使用Set 在Java 集合类库中，List的contains 方法普遍时间复杂度为O(n)，若代码中需要频繁调用contains 方法查找数据则先将集合list 转换成HashSet 实现，将O(n) 的时间复杂度将为O(1)。 反例： 1234567//频繁调用Collection.contains() 反例List&lt;Object&gt; list = new ArrayList&lt;&gt;();for (int i = 0; i &lt;= Integer.MAX_VALUE; i++)&#123; //时间复杂度为O(n) if (list.contains(i)) System.out.println(\"list contains \"+ i);&#125; 正例: 123456789//频繁调用Collection.contains() 正例List&lt;Object&gt; list = new ArrayList&lt;&gt;();Set&lt;Object&gt; set = new HashSet&lt;&gt;();for (int i = 0; i &lt;= Integer.MAX_VALUE; i++)&#123; //时间复杂度为O(1) if (set.contains(i))&#123; System.out.println(\"list contains \"+ i); &#125;&#125; 使用静态代码块实现赋值静态成员变量 对于集合类型的静态成员变量，应该使用静态代码块赋值，而不是使用集合实现来赋值。 反例： 123456789101112131415//赋值静态成员变量反例private static Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;()&#123; &#123; map.put(\"Leo\",1); map.put(\"Family-loving\",2); map.put(\"Cold on the out side passionate on the inside\",3); &#125;&#125;;private static List&lt;String&gt; list = new ArrayList&lt;&gt;()&#123; &#123; list.add(\"Sagittarius\"); list.add(\"Charming\"); list.add(\"Perfectionist\"); &#125;&#125;; 正例： 1234567891011121314//赋值静态成员变量正例private static Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();static &#123; map.put(\"Leo\",1); map.put(\"Family-loving\",2); map.put(\"Cold on the out side passionate on the inside\",3);&#125;private static List&lt;String&gt; list = new ArrayList&lt;&gt;();static &#123; list.add(\"Sagittarius\"); list.add(\"Charming\"); list.add(\"Perfectionist\");&#125; 删除未使用的局部变量、方法参数、私有方法、字段和多余的括号。工具类中屏蔽构造函数 工具类是一堆静态字段和函数的集合，其不应该被实例化；但是，Java 为每个没有明确定义构造函数的类添加了一个隐式公有构造函数，为了避免不必要的实例化，应该显式定义私有构造函数来屏蔽这个隐式公有构造函数。 反例： 123456789public class PasswordUtils &#123;//工具类构造函数反例private static final Logger LOG = LoggerFactory.getLogger(PasswordUtils.class);public static final String DEFAULT_CRYPT_ALGO = \"PBEWithMD5AndDES\";public static String encryptPassword(String aPassword) throws IOException &#123; return new PasswordUtils(aPassword).encrypt();&#125; 正例： 123456789101112public class PasswordUtils &#123;//工具类构造函数正例private static final Logger LOG = LoggerFactory.getLogger(PasswordUtils.class);//定义私有构造函数来屏蔽这个隐式公有构造函数private PasswordUtils()&#123;&#125;public static final String DEFAULT_CRYPT_ALGO = \"PBEWithMD5AndDES\";public static String encryptPassword(String aPassword) throws IOException &#123; return new PasswordUtils(aPassword).encrypt();&#125; 删除多余的异常捕获并抛出 用catch 语句捕获异常后，若什么也不进行处理，就只是让异常重新抛出，这跟不捕获异常的效果一样，可以删除这块代码或添加别的处理。 反例： 123456789101112131415//多余异常反例private static String fileReader(String fileName)throws IOException&#123; try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) &#123; String line; StringBuilder builder = new StringBuilder(); while ((line = reader.readLine()) != null) &#123; builder.append(line); &#125; return builder.toString(); &#125; catch (Exception e) &#123; //仅仅是重复抛异常 未作任何处理 throw e; &#125;&#125; 正例： 12345678910111213141516//多余异常正例private static String fileReader(String fileName)throws IOException&#123; try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) &#123; String line; StringBuilder builder = new StringBuilder(); while ((line = reader.readLine()) != null) &#123; builder.append(line); &#125; return builder.toString(); //删除多余的抛异常，或增加其他处理： /*catch (Exception e) &#123; return \"fileReader exception\"; &#125;*/ &#125;&#125; 字符串转化使用String.valueOf(value) 代替 “ “ + value 把其它对象或类型转化为字符串时，使用String.valueOf(value) 比 “”+value 的效率更高。 反例： 1234//把其它对象或类型转化为字符串反例：int num = 520;// \"\" + valueString strLove = \"\" + num; 正例： 1234//把其它对象或类型转化为字符串正例：int num = 520;// String.valueOf() 效率更高String strLove = String.valueOf(num); 避免使用BigDecimal(double) BigDecimal(double) 存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。 反例： 12// BigDecimal 反例BigDecimal bigDecimal = new BigDecimal(0.11D); 正例： 12// BigDecimal 正例BigDecimal bigDecimal1 = bigDecimal.valueOf(0.11D); 返回空数组和集合而非 null 若程序运行返回null，需要调用方强制检测null，否则就会抛出空指针异常；返回空数组或空集合，有效地避免了调用方因为未检测null 而抛出空指针异常的情况，还可以删除调用方检测null 的语句使代码更简洁。 反例： 123456789101112//返回null 反例public static Result[] getResults() &#123; return null;&#125;public static List&lt;Result&gt; getResultList() &#123; return null;&#125;public static Map&lt;String, Result&gt; getResultMap() &#123; return null;&#125; 正例： 123456789101112//返回空数组和空集正例public static Result[] getResults() &#123; return new Result[0];&#125;public static List&lt;Result&gt; getResultList() &#123; return Collections.emptyList();&#125;public static Map&lt;String, Result&gt; getResultMap() &#123; return Collections.emptyMap();&#125; 优先使用常量或确定值调用equals 方法 对象的equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals 方法。 反例： 123456//调用 equals 方法反例private static boolean fileReader(String fileName)throws IOException&#123; // 可能抛空指针异常 return fileName.equals(\"Charming\");&#125; 正例： 123456789//调用 equals 方法正例private static boolean fileReader(String fileName)throws IOException&#123; // 使用常量或确定有值的对象来调用 equals 方法 return \"Charming\".equals(fileName); //或使用：java.util.Objects.equals() 方法 return Objects.equals(\"Charming\",fileName);&#125; 枚举的属性字段必须是私有且不可变 枚举通常被当做常量使用，如果枚举中存在公共属性字段或设置字段方法，那么这些枚举常量的属性很容易被修改；理想情况下，枚举中的属性字段是私有的，并在私有构造函数中赋值，没有对应的Setter 方法，最好加上final 修饰符。 反例： 123456789101112131415161718192021public enum SwitchStatus &#123; // 枚举的属性字段反例 DISABLED(0, \"禁用\"), ENABLED(1, \"启用\"); public int value; private String description; private SwitchStatus(int value, String description) &#123; this.value = value; this.description = description; &#125; public String getDescription() &#123; return description; &#125; public void setDescription(String description) &#123; this.description = description; &#125;&#125; 正例： 1234567891011121314151617181920212223public enum SwitchStatus &#123; // 枚举的属性字段正例 DISABLED(0, \"禁用\"), ENABLED(1, \"启用\"); // final 修饰 private final int value; private final String description; private SwitchStatus(int value, String description) &#123; this.value = value; this.description = description; &#125; // 没有Setter 方法 public int getValue() &#123; return value; &#125; public String getDescription() &#123; return description; &#125;&#125; tring.split(String regex)部分关键字需要转译 使用字符串String 的plit 方法时，传入的分隔字符串是正则表达式，则部分关键字（比如 .| 等）需要转义。 反例： 123456// String.split(String regex) 反例String[] split = \"a.ab.abc\".split(\".\");System.out.println(Arrays.toString(split)); // 结果为[]String[] split1 = \"a|ab|abc\".split(\"|\");System.out.println(Arrays.toString(split1)); // 结果为[\"a\", \"|\", \"a\", \"b\", \"|\", \"a\", \"b\", \"c\"] 正例： 12345678// String.split(String regex) 正例// . 需要转译String[] split2 = \"a.ab.abc\".split(\"\\\\.\");System.out.println(Arrays.toString(split2)); // 结果为[\"a\", \"ab\", \"abc\"]// | 需要转译String[] split3 = \"a|ab|abc\".split(\"\\\\|\");System.out.println(Arrays.toString(split3)); // 结果为[\"a\", \"ab\", \"abc\"]","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"},{"name":"代码规范","slug":"代码规范","permalink":"http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"}]},{"title":"win10安装Redis","slug":"win10安装Redis","date":"2021-08-05T01:57:57.000Z","updated":"2021-08-05T02:25:32.680Z","comments":true,"path":"2021/08/05/win10安装Redis/","link":"","permalink":"http://yoursite.com/2021/08/05/win10%E5%AE%89%E8%A3%85Redis/","excerpt":"","text":"win10安装redis下载下载地址： https://github.com/MicrosoftArchive/redis/releases 根据系统下载的版本：以（64位为例） 下载后一般解压到根目录下：如（E:\\Redis-x64-3.2.100） 安装打开cmd命令窗口，使用命令进行安装和注册redis到window服务 安装命令：redis-server.exe –service-install redis.windows.conf –loglevel verbose 启动服务命令：redis-server.exe –service-start 关闭服务命令：redis-server.exe –service-stop 最后返回的successfully表示安装成功。 也可以通过任务管理器中查看后台中是否有redis-service来判断是否启动成功。 我们重新打开一个cmd ,作为一个客户端调用redis服务，如下图所示，调用命令是：redis-cli.exe -h 127.0.0.1 -p 6379，如下图显示地址和端口，说明调用成功 然后我们使用set 和get 命令进行测试一下，set uname “abc”,然后使用get uname可以获取到对应set的值，说明调用成功 客户端使用redis我们重新打开一个cmd ,作为一个客户端调用redis服务，如下图所示，调用命令是：redis-cli.exe -h 127.0.0.1 -p 6379，如下图显示地址和端口，说明调用成功 然后我们使用set 和get 命令进行测试一下，set uname “abc”,然后使用get uname可以获取到对应set的值，说明调用成功 设置密码 还可以通过将字符串设置为空来清空密码：CONFIG SET requirepass “”","categories":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"},{"name":"NoSql数据库","slug":"Redis/NoSql数据库","permalink":"http://yoursite.com/categories/Redis/NoSql%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"},{"name":"安装","slug":"安装","permalink":"http://yoursite.com/tags/%E5%AE%89%E8%A3%85/"}]},{"title":"sql 查出一张表中重复的所有记录数据","slug":"sql-查出一张表中重复的所有记录数据","date":"2021-07-22T07:45:35.000Z","updated":"2021-07-22T07:51:21.858Z","comments":true,"path":"2021/07/22/sql-查出一张表中重复的所有记录数据/","link":"","permalink":"http://yoursite.com/2021/07/22/sql-%E6%9F%A5%E5%87%BA%E4%B8%80%E5%BC%A0%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%89%80%E6%9C%89%E8%AE%B0%E5%BD%95%E6%95%B0%E6%8D%AE/","excerpt":"","text":"查询重复的数据1.查询出所有数据进行分组之后，和重复数据的重复次数的查询数据，先列下： 1select count(username) as '重复次数',username from t_user group by username having count(*)&gt;1 order by username desc 2.查找表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断 1select * from people where peopleId in (select peopleId from people group by peopleId having count(peopleId) &gt; 1) 3.查找表中多余的重复记录（多个字段） 1select * from people a where (a.peopleId,a.seq) in (select peopleId,seq from people group by peopleId,seq having count(*) &gt; 1)","categories":[{"name":"sql语句","slug":"sql语句","permalink":"http://yoursite.com/categories/sql%E8%AF%AD%E5%8F%A5/"},{"name":"数据库","slug":"sql语句/数据库","permalink":"http://yoursite.com/categories/sql%E8%AF%AD%E5%8F%A5/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"},{"name":"查询重复记录","slug":"查询重复记录","permalink":"http://yoursite.com/tags/%E6%9F%A5%E8%AF%A2%E9%87%8D%E5%A4%8D%E8%AE%B0%E5%BD%95/"}]},{"title":"深入理解 Java 的 3 种工厂模式","slug":"深入理解-Java-的-3-种工厂模式","date":"2021-07-22T02:52:40.000Z","updated":"2021-07-22T07:56:36.978Z","comments":true,"path":"2021/07/22/深入理解-Java-的-3-种工厂模式/","link":"","permalink":"http://yoursite.com/2021/07/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E7%9A%84-3-%E7%A7%8D%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"简单工厂模式简单工厂的定义：提供一个创建对象实例的功能，而无须关心其具体实现。被创建实例的类型可以是接口、抽象类，也可以是具体的类 实现汽车接口 123public interface Car &#123; String getName();&#125; 奔驰类 123456public class Benz implements Car &#123; @Override public String getName() &#123; return \"Benz\"; &#125;&#125; 宝马类 123456public class BMW implements Car &#123; @Override public String getName() &#123; return \"BMW\"; &#125;&#125; 简单工厂，既能生产宝马又能生产奔驰 123456789101112public class SimpleFactory &#123; public Car getCar(String name)&#123; if (name.equals(\"BMW\"))&#123; return new BMW(); &#125;else if (name.equals(\"benz\"))&#123; return new Benz(); &#125;else &#123; System.out.println(\"不好意思，这个品牌的汽车生产不了\"); return null; &#125; &#125;&#125; 测试类 1234567public class SimpleFactoryTest &#123; public static void main(String[] args)&#123; SimpleFactory simpleFactory = new SimpleFactory(); Car car = simpleFactory.getCar(\"BMW\"); System.out.println(car.getName()); &#125;&#125; 测试结果 1BMW 根据简单工厂的定义，用户只要产品而不在乎产品如何生产，看起来好像很完美的样子这个世界存在什么都生产的工厂吗？ 显然是不存在的，每一个汽车品牌都有自己的生产工厂，都有自己生产技术。映射到spring框架中，我们有很多很多种的bean需要生产，如果只依靠一个简单工厂来实现，那么我们得在工厂类中嵌套多少个if..else if啊？ 而且我们在代码中生产一辆汽车只是new一下就出来了，但实际操作中却不知道需要进行多少操作，加载、注册等操作都将体现在工厂类中，那么这个类就会变得紊乱，管理起来也很不方便，所以说每个品牌应该有自己的生产类。 因为专一，所以专业，这个时候工厂方法就出现了。 工厂方法工厂接口 1234//定义一个工厂接口，功能就是生产汽车public interface Factory &#123; Car getCar();&#125; 奔驰工厂 123456public class BenzFactory implements Factory &#123; @Override public Car getCar() &#123; return new Benz(); &#125;&#125; 宝马工厂 1234public class BMWFactory implements Factory&#123; @Override public Car getCar() &#123;return new BMW();&#125;&#125; 测试类 12345678public class FactoryTest &#123; public static void main(String[] args) &#123; Factory bmwFactory = new BMWFactory(); System.out.println(bmwFactory.getCar().getName()); Factory benzFactory = new BenzFactory(); System.out.println(benzFactory.getCar().getName()); &#125;&#125; 测试结果 1BMWBenz 根据上述代码可以看出，不同品牌的汽车是由不同的工厂生产的，貌似又是很完美的。但大家看一下测试类，当一个人想要去买一辆宝马汽车的时候（假设没有销售商），那么他就要去找宝马工厂给他生产一辆，过几天又想要买一辆奔驰汽车的时候，又得跑到奔驰工厂请人生产，这无疑就增加了用户的操作复杂性。所以有没有一种方便用户操作的方法呢？这个时候抽象工厂模式就出现了。 抽象工厂抽象工厂 12345678910public abstract class AbstractFactory &#123; protected abstract Car getCar(); //这段代码就是动态配置的功能//固定模式的委派 public Car getCar(String name)&#123; if(\"BMW\".equalsIgnoreCase(name))&#123;return new BmwFactory().getCar();&#125; else if(\"Benz\".equalsIgnoreCase(name))&#123;return new BenzFactory().getCar();&#125; else if(\"Audi\".equalsIgnoreCase(name))&#123;return new AudiFactory().getCar();&#125; else&#123;System.out.println(\"这个产品产不出来\");return null;&#125; &#125;&#125; 默认工厂 1234public class DefaultFactory extends AbstractFactory &#123; private AudiFactory defaultFactory = new AudiFactory(); public Car getCar() &#123;return defaultFactory.getCar();&#125;&#125; 宝马工厂 123456public class BMWFactory extends AbstractFactory &#123; @Override public Car getCar() &#123; return new BMW(); &#125;&#125; 奔驰工厂 123456public class BenzFactory extends AbstractFactory &#123; @Override public Car getCar() &#123; return new Benz(); &#125;&#125; 测试类 123456public class AbstractFactoryTest &#123; public static void main(String[] args) &#123; DefaultFactory factory = new DefaultFactory(); System.out.println(factory.getCar(\"Benz\").getName()); &#125;&#125; 测试结果 1Benz 根据上述代码可以看出，用户需要一辆汽车，只需要去找默认的工厂提出自己的需求（传入参数），便能得到自己想要产品，而不用根据产品去寻找不同的生产工厂，方便用户操作。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"},{"name":"工厂模式","slug":"工厂模式","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"}]},{"title":"Spring Boot 注解原理与自动装配原理","slug":"Spring-Boot-注解原理与自动装配原理","date":"2021-07-22T02:02:09.000Z","updated":"2021-07-22T02:20:24.753Z","comments":true,"path":"2021/07/22/Spring-Boot-注解原理与自动装配原理/","link":"","permalink":"http://yoursite.com/2021/07/22/Spring-Boot-%E6%B3%A8%E8%A7%A3%E5%8E%9F%E7%90%86%E4%B8%8E%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/","excerpt":"","text":"首先，先看SpringBoot的主配置类： 12345678@SpringBootApplicationpublic class StartEurekaApplication&#123; public static void main(String[] args) &#123; SpringApplication.run(StartEurekaApplication.class, args); &#125;&#125; 点进@SpringBootApplication来看，发现@SpringBootApplication是一个组合注解。 123456789101112@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123;&#125; 首先我们先来看 @SpringBootConfiguration： 123456@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Configurationpublic @interface SpringBootConfiguration &#123;&#125; 可以看到这个注解除了元注解以外，就只有一个@Configuration，那也就是说这个注解相当于@Configuration，所以这两个注解作用是一样的，它让我们能够去注册一些额外的Bean，并且导入一些额外的配置。 那@Configuration还有一个作用就是把该类变成一个配置类，不需要额外的XML进行配置。所以@SpringBootConfiguration就相当于@Configuration。进入@Configuration，发现@Configuration核心是@Component，说明Spring的配置类也是Spring的一个组件。 12345678910@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Configuration &#123; @AliasFor( annotation = Component.class ) String value() default \"\";&#125; 继续来看下一个@EnableAutoConfiguration,这个注解是开启自动配置的功能。 12345678910111213@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;)public @interface EnableAutoConfiguration &#123; String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\"; Class&lt;?&gt;[] exclude() default &#123;&#125;; String[] excludeName() default &#123;&#125;;&#125; 可以看到它是由 @AutoConfigurationPackage，@Import(EnableAutoConfigurationImportSelector.class)这两个而组成的，我们先说@AutoConfigurationPackage，他是说：让包中的类以及子包中的类能够被自动扫描到spring容器中。 1234567@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Import(&#123;Registrar.class&#125;)public @interface AutoConfigurationPackage &#123;&#125; 使用@Import来给Spring容器中导入一个组件 ，这里导入的是Registrar.class。来看下这个Registrar： 123456789101112static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports &#123; Registrar() &#123; &#125; public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123; AutoConfigurationPackages.register(registry, (new AutoConfigurationPackages.PackageImport(metadata)).getPackageName()); &#125; public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) &#123; return Collections.singleton(new AutoConfigurationPackages.PackageImport(metadata)); &#125; &#125; 就是通过以上这个方法获取扫描的包路径，可以debug查看具体的值： 那metadata是什么呢，可以看到是标注在@SpringBootApplication注解上的DemosbApplication，也就是我们的主配置类Application： 其实就是将主配置类（即@SpringBootApplication标注的类）的所在包及子包里面所有组件扫描加载到Spring容器。因此我们要把DemoApplication放在项目的最高级中（最外层目录）。 看看注解@Import(AutoConfigurationImportSelector.class)，@Import注解就是给Spring容器中导入一些组件，这里传入了一个组件的选择器:AutoConfigurationImportSelector。 可以从图中看出AutoConfigurationImportSelector 继承了 DeferredImportSelector 继承了 ImportSelector，ImportSelector有一个方法为：selectImports。将所有需要导入的组件以全类名的方式返回，这些组件就会被添加到容器中。 12345678910public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; if (!this.isEnabled(annotationMetadata)) &#123; return NO_IMPORTS; &#125; else &#123; AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(this.beanClassLoader); AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); &#125;&#125; 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件。 有了自动配置类，免去了我们手动编写配置注入功能组件等的工作。那是如何获取到这些配置类的呢，看看下面这个方法： 12345678910111213141516protected AutoConfigurationImportSelector.AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) &#123; if (!this.isEnabled(annotationMetadata)) &#123; return EMPTY_ENTRY; &#125; else &#123; AnnotationAttributes attributes = this.getAttributes(annotationMetadata); List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes); configurations = this.removeDuplicates(configurations); Set&lt;String&gt; exclusions = this.getExclusions(annotationMetadata, attributes); this.checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = this.filter(configurations, autoConfigurationMetadata); this.fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions); &#125;&#125; 我们可以看到getCandidateConfigurations()这个方法，他的作用就是引入系统已经加载好的一些类，到底是那些类呢： 12345678910protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123; List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader()); Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.\"); return configurations;&#125;public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123; String factoryClassName = factoryClass.getName(); return (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());&#125; 会从META-INF/spring.factories中获取资源，然后通过Properties加载资源： 123456789101112131415161718192021222324252627282930313233343536private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123; MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader); if (result != null) &#123; return result; &#125; else &#123; try &#123; Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(\"META-INF/spring.factories\") : ClassLoader.getSystemResources(\"META-INF/spring.factories\"); LinkedMultiValueMap result = new LinkedMultiValueMap(); while(urls.hasMoreElements()) &#123; URL url = (URL)urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); Iterator var6 = properties.entrySet().iterator(); while(var6.hasNext()) &#123; Map.Entry&lt;?, ?&gt; entry = (Map.Entry)var6.next(); String factoryClassName = ((String)entry.getKey()).trim(); String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue()); int var10 = var9.length; for(int var11 = 0; var11 &lt; var10; ++var11) &#123; String factoryName = var9[var11]; result.add(factoryClassName, factoryName.trim()); &#125; &#125; &#125; cache.put(classLoader, result); return result; &#125; catch (IOException var13) &#123; throw new IllegalArgumentException(\"Unable to load factories from location [META-INF/spring.factories]\", var13); &#125; &#125;&#125; 可以知道SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作。以前我们需要自己配置的东西，自动配置类都帮我们完成了。如下图可以发现Spring常见的一些类已经自动导入。 接下来看@ComponentScan注解，@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })，这个注解就是扫描包，然后放入spring容器。 1234@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM,classes = &#123;TypeExcludeFilter.class&#125;), @Filter(type = FilterType.CUSTOM,classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123;&#125; 总结下@SpringbootApplication：就是说，他已经把很多东西准备好，具体是否使用取决于我们的程序或者说配置。 接下来继续看run方法： 123public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125; 来看下在执行run方法到底有没有用到哪些自动配置的东西，我们点进run： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public ConfigurableApplicationContext run(String... args) &#123; //计时器 StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList(); this.configureHeadlessProperty(); //监听器 SpringApplicationRunListeners listeners = this.getRunListeners(args); listeners.starting(); Collection exceptionReporters; try &#123; ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); ConfigurableEnvironment environment = this.prepareEnvironment(listeners, applicationArguments); this.configureIgnoreBeanInfo(environment); Banner printedBanner = this.printBanner(environment); //准备上下文 context = this.createApplicationContext(); exceptionReporters = this.getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[]&#123;ConfigurableApplicationContext.class&#125;, context); //预刷新context this.prepareContext(context, environment, listeners, applicationArguments, printedBanner); //刷新context this.refreshContext(context); //刷新之后的context this.afterRefresh(context, applicationArguments); stopWatch.stop(); if (this.logStartupInfo) &#123; (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), stopWatch); &#125; listeners.started(context); this.callRunners(context, applicationArguments); &#125; catch (Throwable var10) &#123; this.handleRunFailure(context, var10, exceptionReporters, listeners); throw new IllegalStateException(var10); &#125; try &#123; listeners.running(context); return context; &#125; catch (Throwable var9) &#123; this.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)null); throw new IllegalStateException(var9); &#125;&#125; 那我们关注的就是 refreshContext(context); 刷新context，我们点进来看。 1234567891011private void refreshContext(ConfigurableApplicationContext context) &#123; refresh(context); if (this.registerShutdownHook) &#123; try &#123; context.registerShutdownHook(); &#125; catch (AccessControlException ex) &#123; // Not allowed in some environments. &#125; &#125;&#125; 我们继续点进refresh(context); 1234protected void refresh(ApplicationContext applicationContext) &#123; Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext); ((AbstractApplicationContext) applicationContext).refresh();&#125; 他会调用 ((AbstractApplicationContext) applicationContext).refresh();方法，我们点进来看： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125;catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125;finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; 由此可知，就是一个spring的bean的加载过程。继续来看一个方法叫做 onRefresh()： 123protected void onRefresh() throws BeansException &#123; // For subclasses: do nothing by default.&#125; 他在这里并没有直接实现，但是我们找他的具体实现： 比如Tomcat跟web有关，我们可以看到有个ServletWebServerApplicationContext： 12345678910@Overrideprotected void onRefresh() &#123; super.onRefresh(); try &#123; createWebServer(); &#125; catch (Throwable ex) &#123; throw new ApplicationContextException(\"Unable to start web server\", ex); &#125;&#125; 可以看到有一个createWebServer();方法他是创建web容器的，而Tomcat不就是web容器，那是如何创建的呢，我们继续看： 123456789101112131415161718private void createWebServer() &#123; WebServer webServer = this.webServer; ServletContext servletContext = getServletContext(); if (webServer == null &amp;&amp; servletContext == null) &#123; ServletWebServerFactory factory = getWebServerFactory(); this.webServer = factory.getWebServer(getSelfInitializer()); &#125; else if (servletContext != null) &#123; try &#123; getSelfInitializer().onStartup(servletContext); &#125; catch (ServletException ex) &#123; throw new ApplicationContextException(\"Cannot initialize servlet context\", ex); &#125; &#125; initPropertySources();&#125; factory.getWebServer(getSelfInitializer());他是通过工厂的方式创建的。 123public interface ServletWebServerFactory &#123; WebServer getWebServer(ServletContextInitializer... initializers);&#125; 可以看到 它是一个接口，为什么会是接口。因为我们不止是Tomcat一种web容器。 我们看到还有Jetty，那我们来看TomcatServletWebServerFactory： 123456789101112131415161718@Overridepublic WebServer getWebServer(ServletContextInitializer... initializers) &#123; Tomcat tomcat = new Tomcat(); File baseDir = (this.baseDirectory != null) ? this.baseDirectory : createTempDir(\"tomcat\"); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); customizeConnector(connector); tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); configureEngine(tomcat.getEngine()); for (Connector additionalConnector : this.additionalTomcatConnectors) &#123; tomcat.getService().addConnector(additionalConnector); &#125; prepareContext(tomcat.getHost(), initializers); return getTomcatWebServer(tomcat);&#125; 那这块代码，就是我们要寻找的内置Tomcat，在这个过程当中，我们可以看到创建Tomcat的一个流程。 如果不明白的话， 我们在用另一种方式来理解下，大家要应该都知道stater举点例子。 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;&lt;/dependency&gt; 首先自定义一个stater。 12345678910111213141516&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt;&lt;groupId&gt;com.zgw&lt;/groupId&gt;&lt;artifactId&gt;gw-spring-boot-starter&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 我们先来看maven配置写入版本号，如果自定义一个stater的话必须依赖spring-boot-autoconfigure这个包,我们先看下项目目录。 1234567891011public class GwServiceImpl implements GwService&#123; @Autowired GwProperties properties; @Override public void Hello() &#123; String name=properties.getName(); System.out.println(name+\"说:你们好啊\"); &#125;&#125; 我们做的就是通过配置文件来定制name这个是具体实现。 1234567891011121314@Component@ConfigurationProperties(prefix = \"spring.gwname\")public class GwProperties &#123; String name=\"zgw\"; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 这个类可以通过@ConfigurationProperties读取配置文件。 1234567891011121314151617@Configuration@ConditionalOnClass(GwService.class) //扫描类@EnableConfigurationProperties(GwProperties.class) //让配置类生效public class GwAutoConfiguration &#123; /** * 功能描述 托管给spring * @author zgw * @return */ @Bean @ConditionalOnMissingBean public GwService gwService() &#123; return new GwServiceImpl(); &#125;&#125; 这个为配置类，为什么这么写因为，spring-boot的stater都是这么写的，我们可以参照他仿写stater，以达到自动配置的目的，然后我们在通过spring.factories也来进行配置。 1org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.gw.GwAutoConfiguration 然后这样一个简单的stater就完成了，然后可以进行maven的打包，在其他项目引入就可以使用。","categories":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/categories/spring/"},{"name":"springboot","slug":"spring/springboot","permalink":"http://yoursite.com/categories/spring/springboot/"},{"name":"java","slug":"spring/springboot/java","permalink":"http://yoursite.com/categories/spring/springboot/java/"}],"tags":[{"name":"注解","slug":"注解","permalink":"http://yoursite.com/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"自动装配","slug":"自动装配","permalink":"http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"}]},{"title":"图解Java中那18 把锁","slug":"图解Java中那18-把锁","date":"2021-07-21T08:00:02.000Z","updated":"2021-07-22T01:35:48.750Z","comments":true,"path":"2021/07/21/图解Java中那18-把锁/","link":"","permalink":"http://yoursite.com/2021/07/21/%E5%9B%BE%E8%A7%A3Java%E4%B8%AD%E9%82%A318-%E6%8A%8A%E9%94%81/","excerpt":"","text":"乐观锁和悲观锁 独占锁和共享锁 互斥锁和读写锁 公平锁和非公平锁 可重入锁 自旋锁 分段锁 锁升级（无锁|偏向锁|轻量级锁|重量级锁） 锁优化技术（锁粗化、锁消除） 乐观锁与悲观锁 悲观锁 悲观锁对应于生活中悲观的人，悲观的人总是想着事情往坏的方向发展。 举个生活中的例子，假设厕所只有一个坑位了，悲观锁上厕所会第一时间把门反锁上，这样其他人上厕所只能在门外等候，这种状态就是「阻塞」了。 回到代码世界中，一个共享数据加了悲观锁，那线程每次想操作这个数据前都会假设其他线程也可能会操作这个数据，所以每次操作前都会上锁，这样其他线程想操作这个数据拿不到锁只能阻塞了。 在 Java 语言中 synchronized 和 ReentrantLock等就是典型的悲观锁，还有一些使用了 synchronized 关键字的容器类如 HashTable 等也是悲观锁的应用。 乐观锁 乐观锁 对应于生活中乐观的人，乐观的人总是想着事情往好的方向发展。 举个生活中的例子，假设厕所只有一个坑位了，乐观锁认为：这荒郊野外的，又没有什么人，不会有人抢我坑位的，每次关门上锁多浪费时间，还是不加锁好了。你看乐观锁就是天生乐观！ 回到代码世界中，乐观锁操作数据时不会上锁，在更新的时候会判断一下在此期间是否有其他线程去更新这个数据。 乐观锁可以使用版本号机制和CAS算法实现。在 Java 语言中 java.util.concurrent.atomic包下的原子类就是使用CAS 乐观锁实现的。 两种锁的使用场景 悲观锁和乐观锁没有孰优孰劣，有其各自适应的场景。 乐观锁适用于写比较少（冲突比较小）的场景，因为不用上锁、释放锁，省去了锁的开销，从而提升了吞吐量。 如果是写多读少的场景，即冲突比较严重，线程间竞争激烈，使用乐观锁就是导致线程不断进行重试，这样可能还降低了性能，这种场景下使用悲观锁就比较合适。 独占锁与共享锁 独占锁 独占锁是指锁一次只能被一个线程所持有。如果一个线程对数据加上排他锁后，那么其他线程不能再对该数据加任何类型的锁。获得独占锁的线程即能读数据又能修改数据。 JDK中的synchronized和java.util.concurrent(JUC)包中Lock的实现类就是独占锁。 共享锁 共享锁是指锁可被多个线程所持有。如果一个线程对数据加上共享锁后，那么其他线程只能对数据再加共享锁，不能加独占锁。获得共享锁的线程只能读数据，不能修改数据。 在 JDK 中 ReentrantReadWriteLock 就是一种共享锁。 互斥锁和读写锁 互斥锁 互斥锁是独占锁的一种常规实现，是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。 互斥锁一次只能一个线程拥有互斥锁，其他线程只有等待。 读写锁 读写锁是共享锁的一种具体实现。读写锁管理一组锁，一个是只读的锁，一个是写锁。 读锁可以在没有写锁的时候被多个线程同时持有，而写锁是独占的。写锁的优先级要高于读锁，一个获得了读锁的线程必须能看到前一个释放的写锁所更新的内容。 读写锁相比于互斥锁并发程度更高，每次只有一个写线程，但是同时可以有多个线程并发读。 在 JDK 中定义了一个读写锁的接口：ReadWriteLock 1234567891011public interface ReadWriteLock &#123; /** * 获取读锁 */ Lock readLock(); /** * 获取写锁 */ Lock writeLock();&#125; ReentrantReadWriteLock 实现了ReadWriteLock接口，具体实现这里不展开，后续会深入源码解析。 公平锁和非公平锁 公平锁 公平锁是指多个线程按照申请锁的顺序来获取锁，这里类似排队买票，先来的人先买，后来的人在队尾排着，这是公平的。 在 java 中可以通过构造函数初始化公平锁 1234/*** 创建一个可重入锁，true 表示公平锁，false 表示非公平锁。默认非公平锁*/Lock lock = new ReentrantLock(true); 非公平锁 非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成优先级翻转，或者饥饿的状态（某个线程一直得不到锁）。 在 java 中 synchronized 关键字是非公平锁，ReentrantLock默认也是非公平锁。 1234/*** 创建一个可重入锁，true 表示公平锁，false 表示非公平锁。默认非公平锁*/Lock lock = new ReentrantLock(false); 可重入锁 可重入锁又称之为递归锁，是指同一个线程在外层方法获取了锁，在进入内层方法会自动获取锁。 对于Java ReentrantLock而言, 他的名字就可以看出是一个可重入锁。对于Synchronized而言，也是一个可重入锁。 敲黑板：可重入锁的一个好处是可一定程度避免死锁。 以 synchronized 为例，看一下下面的代码： 12345678public synchronized void mehtodA() throws Exception&#123; // Do some magic tings mehtodB();&#125;public synchronized void mehtodB() throws Exception&#123; // Do some magic tings&#125; 上面的代码中 methodA 调用 methodB，如果一个线程调用methodA 已经获取了锁再去调用 methodB 就不需要再次获取锁了，这就是可重入锁的特性。如果不是可重入锁的话，mehtodB 可能不会被当前线程执行，可能造成死锁。 自旋锁 自旋锁是指线程在没有获得锁时不是被直接挂起，而是执行一个忙循环，这个忙循环就是所谓的自旋。 自旋锁的目的是为了减少线程被挂起的几率，因为线程的挂起和唤醒也都是耗资源的操作。 如果锁被另一个线程占用的时间比较长，即使自旋了之后当前线程还是会被挂起，忙循环就会变成浪费系统资源的操作，反而降低了整体性能。因此自旋锁是不适应锁占用时间长的并发情况的。 在 Java 中，AtomicInteger 类有自旋的操作，我们看一下代码： 1234567public final int getAndAddInt(Object o, long offset, int delta) &#123; int v; do &#123; v = getIntVolatile(o, offset); &#125; while (!compareAndSwapInt(o, offset, v, v + delta)); return v;&#125; CAS 操作如果失败就会一直循环获取当前 value 值然后重试。 另外自适应自旋锁也需要了解一下。 在JDK1.6又引入了自适应自旋，这个就比较智能了，自旋时间不再固定，由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定。如果虚拟机认为这次自旋也很有可能再次成功那就会次序较多的时间，如果自旋很少成功，那以后可能就直接省略掉自旋过程，避免浪费处理器资源。 分段锁 分段锁 是一种锁的设计，并不是具体的一种锁。 分段锁设计目的是将锁的粒度进一步细化，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。 在 Java 语言中 CurrentHashMap 底层就用了分段锁，使用Segment，就可以进行并发使用了。 锁升级（无锁|偏向锁|轻量级锁|重量级锁） JDK1.6 为了提升性能减少获得锁和释放锁所带来的消耗，引入了4种锁的状态：无锁、偏向锁、轻量级锁和重量级锁，它会随着多线程的竞争情况逐渐升级，但不能降级。 无锁 无锁状态其实就是上面讲的乐观锁，这里不再赘述。 偏向锁 Java偏向锁(Biased Locking)是指它会偏向于第一个访问锁的线程，如果在运行过程中，只有一个线程访问加锁的资源，不存在多线程竞争的情况，那么线程是不需要重复获取锁的，这种情况下，就会给线程加一个偏向锁。 偏向锁的实现是通过控制对象Mark Word的标志位来实现的，如果当前是可偏向状态，需要进一步判断对象头存储的线程 ID 是否与当前线程 ID 一致，如果一致直接进入。 轻量级锁 当线程竞争变得比较激烈时，偏向锁就会升级为轻量级锁，轻量级锁认为虽然竞争是存在的，但是理想情况下竞争的程度很低，通过自旋方式等待上一个线程释放锁。 重量级锁 如果线程并发进一步加剧，线程的自旋超过了一定次数，或者一个线程持有锁，一个线程在自旋，又来了第三个线程访问时（反正就是竞争继续加大了），轻量级锁就会膨胀为重量级锁，重量级锁会使除了此时拥有锁的线程以外的线程都阻塞。 升级到重量级锁其实就是互斥锁了，一个线程拿到锁，其余线程都会处于阻塞等待状态。 在 Java 中，synchronized 关键字内部实现原理就是锁升级的过程：无锁 –&gt; 偏向锁 –&gt; 轻量级锁 –&gt; 重量级锁。 锁优化技术（锁粗化、锁消除） 锁粗化 锁粗化就是将多个同步块的数量减少，并将单个同步块的作用范围扩大，本质上就是将多次上锁、解锁的请求合并为一次同步请求。 举个例子，一个循环体中有一个代码同步块，每次循环都会执行加锁解锁操作。 1234567private static final Object LOCK = new Object();for(int i = 0;i &lt; 100; i++) &#123; synchronized(LOCK)&#123; // do some magic things &#125;&#125; 经过锁粗化后就变成下面这个样子了： 12345 synchronized(LOCK)&#123; for(int i = 0;i &lt; 100; i++) &#123; // do some magic things &#125;&#125; 锁消除 锁消除是指虚拟机编译器在运行时检测到了共享数据没有竞争的锁，从而将这些锁进行消除。 举个例子让大家更好理解。 123456public String test(String s1, String s2)&#123; StringBuffer stringBuffer = new StringBuffer(); stringBuffer.append(s1); stringBuffer.append(s2); return stringBuffer.toString();&#125; 上面代码中有一个 test 方法，主要作用是将字符串 s1 和字符串 s2 串联起来。 test 方法中三个变量s1, s2, stringBuffer， 它们都是局部变量，局部变量是在栈上的，栈是线程私有的，所以就算有多个线程访问 test 方法也是线程安全的。 我们都知道 StringBuffer 是线程安全的类，append 方法是同步方法，但是 test 方法本来就是线程安全的，为了提升效率，虚拟机帮我们消除了这些同步锁，这个过程就被称为锁消除。 12345678StringBuffer.class// append 是同步方法public synchronized StringBuffer append(String str) &#123; toStringCache = null; super.append(str); return this;&#125; 一张图总结 前面讲了 Java 语言中各种各种的锁，最后再通过六个问题统一总结一下： -- End --","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java锁","slug":"java锁","permalink":"http://yoursite.com/tags/java%E9%94%81/"}]},{"title":"Java8 实现List转map 、分组、过滤","slug":"Java8-实现List转map-、分组、过滤","date":"2020-11-10T02:40:12.000Z","updated":"2020-11-10T03:05:40.824Z","comments":true,"path":"2020/11/10/Java8-实现List转map-、分组、过滤/","link":"","permalink":"http://yoursite.com/2020/11/10/Java8-%E5%AE%9E%E7%8E%B0List%E8%BD%ACmap-%E3%80%81%E5%88%86%E7%BB%84%E3%80%81%E8%BF%87%E6%BB%A4/","excerpt":"","text":"利用java8新特性，可以用简洁高效的代码来实现一些数据处理。 定义1个Apple对象： 123456789101112131415public class Apple &#123; private Integer id; private String name; private BigDecimal money; private Integer num; public Apple(Integer id, String name, BigDecimal money, Integer num) &#123; this.id = id; this.name = name; this.money = money; this.num = num; &#125; &#125; 添加一些测试数据： 1234567891011List&lt;Apple&gt; appleList = new ArrayList&lt;&gt;();//存放apple对象集合 Apple apple1 = new Apple(1,\"苹果1\",new BigDecimal(\"3.25\"),10);Apple apple12 = new Apple(1,\"苹果2\",new BigDecimal(\"1.35\"),20);Apple apple2 = new Apple(2,\"香蕉\",new BigDecimal(\"2.89\"),30);Apple apple3 = new Apple(3,\"荔枝\",new BigDecimal(\"9.99\"),40); appleList.add(apple1);appleList.add(apple12);appleList.add(apple2);appleList.add(apple3); 1.分组List里面的对象元素，以某个属性来分组，例如，以id分组，将id相同的放在一起： 12345//List 以ID分组 Map&lt;Integer,List&lt;Apple&gt;&gt;Map&lt;Integer, List&lt;Apple&gt;&gt; groupBy = appleList.stream().collect(Collectors.groupingBy(Apple::getId)); System.err.println(\"groupBy:\"+groupBy);&#123;1=[Apple&#123;id=1, name='苹果1', money=3.25, num=10&#125;, Apple&#123;id=1, name='苹果2', money=1.35, num=20&#125;], 2=[Apple&#123;id=2, name='香蕉', money=2.89, num=30&#125;], 3=[Apple&#123;id=3, name='荔枝', money=9.99, num=40&#125;]&#125; 2、List转Mapid为key，apple对象为value，可以这么做： 12345678/** * List -&gt; Map * 需要注意的是： * toMap 如果集合对象有重复的key，会报错Duplicate key .... * apple1,apple12的id都为1。 * 可以用 (k1,k2)-&gt;k1 来设置，如果有重复的key,则保留key1,舍弃key2 */Map&lt;Integer, Apple&gt; appleMap = appleList.stream().collect(Collectors.toMap(Apple::getId, a -&gt; a,(k1,k2)-&gt;k1)); 3、过滤Filter从集合中过滤出来符合条件的元素： 12345//过滤出符合条件的数据List&lt;Apple&gt; filterList = appleList.stream().filter(a -&gt; a.getName().equals(\"香蕉\")).collect(Collectors.toList()); System.err.println(\"filterList:\"+filterList);[Apple&#123;id=2, name='香蕉', money=2.89, num=30&#125;] 4、求和将集合中的数据按照某个属性求和: 123//计算 总金额BigDecimal totalMoney = appleList.stream().map(Apple::getMoney).reduce(BigDecimal.ZERO, BigDecimal::add);System.err.println(\"totalMoney:\"+totalMoney); //totalMoney:17.48 5、查找流中最大 最小值Collectors.maxBy 和 Collectors.minBy 来计算流中的最大或最小值: 12345Optional&lt;Dish&gt; maxDish = Dish.menu.stream().collect(Collectors.maxBy(Comparator.comparing(Dish::getCalories)));maxDish.ifPresent(System.out::println); Optional&lt;Dish&gt; minDish = Dish.menu.stream().collect(Collectors.minBy(Comparator.comparing(Dish::getCalories)));minDish.ifPresent(System.out::println); 6、去重123456789import static java.util.Comparator.comparingLong;import static java.util.stream.Collectors.collectingAndThen;import static java.util.stream.Collectors.toCollection; // 根据id去重 List&lt;Person&gt; unique = appleList.stream().collect( collectingAndThen( toCollection(() -&gt; new TreeSet&lt;&gt;(comparingLong(Apple::getId))), ArrayList::new) );","categories":[{"name":"Java8","slug":"Java8","permalink":"http://yoursite.com/categories/Java8/"}],"tags":[{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"}]},{"title":"Linux实用命令及杂项","slug":"Linux实用命令及杂项","date":"2020-06-09T13:49:57.000Z","updated":"2020-06-09T13:53:42.371Z","comments":true,"path":"2020/06/09/Linux实用命令及杂项/","link":"","permalink":"http://yoursite.com/2020/06/09/Linux%E5%AE%9E%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E6%9D%82%E9%A1%B9/","excerpt":"","text":"1.关机&amp;重启命令 shutdown shutdown -h now 表示立即关机 shutdown -h 1 表示一分钟后关机 shutdown -r now 表示立即重启 halt 停机 等价于关机 reboot 重启系统 sync 把内存的数据保存到磁盘上 一般在关机或重启时先执行的命令 2.用户注销 logout 注销当前用户登录 (在图形界面无效) 3.用户管理 useradd xiaoming 添加一个用户 xiaoming（用户创建成功后会自动的创建与用户名同名的家目录与用户组） useradd -d 指定目录 用户名 创建新的用户并指定家目录 passwd xiaoming 给用户xiaoming指定密码 userdel xiaoming 删除用户xiaoming但是保留家目录 userdel -r xiaoming 删除xiaoming并删除家目录 id xiaoming 查询xiaoming的用户详细信息 su - root 切换到root用户 exit 退出 返回到原来的用户 whoami 当前用户是谁 groupadd wudang 添加一个用户组wudang groupdel wudang 删除用户组wudang useradd -g wudang xiaoming 将用户xiaoming指定到用户组wudang中 usermod -g shaolin xiaoming 将用户xiaoming修改用户组到shaolin中 4.运行级别linux一共分为7种运行级别，配置在 /etc/inittab id:5:initdefault: 这一行的数字中: 运行级别0：系统关机状态，系统默认运行级别不能设为0，否则不能正常启动 运行级别1：单用户(找回丢失密码)，root权限，用于系统维护，禁止远程登陆 运行级别2：多用户状态(没有网络服务) 运行级别3：多用户状态(有网络服务)，登陆后进入控制台命令行模式 运行级别4：系统未使用，保留 运行级别5：X11控制台，登陆后进入图形GUI模式 （图形界面） 运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动 init 3 将运行级别调整到3 5.帮助指令 man ls 查看命令ls的帮助及使用方法 help ls 查看ls命令的帮助及使用方法 6.文件目录 pwd 显示当前目录的绝对路径 ls -a 显示当前目录所有的文件和目录包括隐藏的文件 ls -l 以列表的方式显示信息 cd ~ 或 cd : 回到当前用户的家目录 cd .. 回到上一级目录 mkdir /home/dog 在home目录下创建一个dog目录 mkdir -p /home/animal/tigger 在home目录下创建多级 /animal/tigger 目录 rmdir /home/dog 删除目录/home/dog 如果目录下有内容时无法删除 rm -rf /home/dog 删除目录/home/dog 有没有内容都直接删除 touch hello.txt 创建一个hello.txt的空文件 cp hello.txt bbb/ 复制当前路径下的hello.txt到bbb文件夹中 cp -r test/ zwj/ 递归将test目录拷贝到zwj目录下 再次拷贝可能会提示覆盖 通过cp前加\\强制覆盖 mv aaa.txt bbb.txt 将当前目录的aaa.txt重命名为bbb.txt mv aaa.txt /root 将aaa.txt移动到root目录下 cat -n /etc/profile 查看etc下profile文件的内容并显示行号 cat -n /etc/profile | more 查看ect目录下profile文件的内容分页显示并显示行号 less /etc/peofile 效率比more命令高按需加载文件内容而不是一次性全部加载 ls -l &gt; aaa.txt 将ls的输出内容覆盖写入到aaa.txt中,aaa.txt不存在则创建 ls -l &gt;&gt; aaa.txt 将ls的输出内容追加写入到aaa.txt中,aaa.txt不存在则创建 echo “想要写的内容” &gt; a.txt 把双引号里的内容覆盖添加到a.txt中 echo $PATH 输出PATH环境变量 echo “hello” 输出hello文本 head -n 5 a.txt 显示a.txt文件前五行的内容 tail -n 5 a.txt 显示a.txt文件后五行的内容 tail -f a.txt 实时监控a.txt的变化 经常用到查看日志","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"命令","slug":"命令","permalink":"http://yoursite.com/tags/%E5%91%BD%E4%BB%A4/"}]},{"title":"jdk1.8下的Date与LocalDateTime的互相转换及格式化时间","slug":"jdk1-8下的Date与LocalDateTime的互相转换及格式化时间","date":"2020-06-09T13:29:12.000Z","updated":"2020-06-09T13:36:06.173Z","comments":true,"path":"2020/06/09/jdk1-8下的Date与LocalDateTime的互相转换及格式化时间/","link":"","permalink":"http://yoursite.com/2020/06/09/jdk1-8%E4%B8%8B%E7%9A%84Date%E4%B8%8ELocalDateTime%E7%9A%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2%E5%8F%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%B6%E9%97%B4/","excerpt":"","text":"不跟你多bb，上代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * @Author :liangHuang. * @Date :2019/5/8 16:28 * @Description :时间工具类 */public class DateUtil &#123; private static final ConcurrentMap&lt;String, DateTimeFormatter&gt; FORMATTER_CACHE = new ConcurrentHashMap&lt;&gt;(); private static final int PATTERN_CACHE_SIZE = 500; public static final String LOCAL_DATE_TIME = \"yyyy-MM-dd HH:mm:ss\"; public static final String LOCAL_DATE = \"yyyy-MM-dd\"; public static final String LOCAL_TIME = \"HH:mm:ss\"; /** * Date转换为格式化时间 * @param date * @param pattern * @return */ public static String format(Date date, String pattern)&#123; return format(LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault()), pattern); &#125; /** * localDateTime转换为格式化时间 * @param localDateTime localDateTime * @param pattern 格式 * @return */ public static String format(LocalDateTime localDateTime, String pattern)&#123; DateTimeFormatter formatter = createCacheFormatter(pattern); return localDateTime.format(formatter); &#125; /** * 格式化字符串转为Date * @param time 格式化时间 * @param pattern 格式 * @return */ public static Date parseDate(String time, String pattern)&#123; return Date.from(parseLocalDateTime(time, pattern).atZone(ZoneId.systemDefault()).toInstant()); &#125; /** * 格式化字符串转为LocalDateTime * @param time 格式化时间 * @param pattern 格式 * @return */ public static LocalDateTime parseLocalDateTime(String time, String pattern)&#123; DateTimeFormatter formatter = createCacheFormatter(pattern); return LocalDateTime.parse(time, formatter); &#125; /** * 在缓存中创建DateTimeFormatter * @param pattern 格式 * @return */ private static DateTimeFormatter createCacheFormatter(String pattern)&#123; if (pattern == null || pattern.length() == 0) &#123; throw new IllegalArgumentException(\"Invalid pattern specification\"); &#125; DateTimeFormatter formatter = FORMATTER_CACHE.get(pattern); if(formatter == null)&#123; if(FORMATTER_CACHE.size() &lt; PATTERN_CACHE_SIZE)&#123; formatter = DateTimeFormatter.ofPattern(pattern); DateTimeFormatter oldFormatter = FORMATTER_CACHE.putIfAbsent(pattern, formatter); if(oldFormatter != null)&#123; formatter = oldFormatter; &#125; &#125; &#125; return formatter; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"util","slug":"util","permalink":"http://yoursite.com/tags/util/"}]},{"title":".JPEG .GIF .PNG 三种图片格式的区别","slug":"JPEG-GIF-PNG-三种图片格式的区别","date":"2020-06-09T11:33:18.000Z","updated":"2020-06-09T11:37:19.363Z","comments":true,"path":"2020/06/09/JPEG-GIF-PNG-三种图片格式的区别/","link":"","permalink":"http://yoursite.com/2020/06/09/JPEG-GIF-PNG-%E4%B8%89%E7%A7%8D%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"1.JPEG格式 JPEG（JPG）图片支持的颜色较多，图片可以压缩，但是不支持透明，一般使用JPEG来保存照片等颜色丰富的图片 2.GIF GIF支持的颜色较少，只支持简单的透明，支持动态图，图片颜色单一或者是动态图时可以使用GIF格式 3.PNG PNG格式支持的颜色较多，并且支持复杂的透明，可以用来显示颜色复杂的透明的图片，开发中比较常见 开发建议 ++效果不一致，使用效果好的++ ++效果一致，使用小的++","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"图片","slug":"图片","permalink":"http://yoursite.com/tags/%E5%9B%BE%E7%89%87/"}]},{"title":"cookie、session、token、jwt介绍","slug":"cookie、session、token、jwt介绍","date":"2020-06-09T02:56:03.000Z","updated":"2020-06-09T03:04:57.983Z","comments":true,"path":"2020/06/09/cookie、session、token、jwt介绍/","link":"","permalink":"http://yoursite.com/2020/06/09/cookie%E3%80%81session%E3%80%81token%E3%80%81jwt%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"cookie cookie的诞生由于HTTP协议是无状态的，而服务器端的业务必须是要有状态的。Cookie诞生的最初目的是为了存储web中的状态信息，以方便服务器端使用。比如判断用户是否是第一次访问网站。目前最新的规范是RFC 6265，它是一个由浏览器服务器共同协作实现的规范。Cookie的处理分为：服务器像客户端发送cookie浏览器将cookie保存之后每次http请求浏览器都会将cookie发送给服务器端 session 为什么要有session的出现？答：是由于网络中http协议造成的，因为http本身是无状态协议，这样，无法确定你的本次请求和上次请求是不是你发送的。如果要进行类似论坛登陆相关的操作，就实现不了了。 session生成方式？答：浏览器第一次访问服务器，服务器会创建一个session，然后同时为该session生成一个唯一的会话的key,也就是sessionid，然后，将sessionid及对应的session分别作为key和value保存到缓存中，也可以持久化到数据库中，然后服务器再把sessionid，以cookie的形式发送给客户端。这样浏览器下次再访问时，会直接带着cookie中的sessionid。然后服务器根据sessionid找到对应的session进行匹配；还有一种是浏览器禁用了cookie或不支持cookie，这种可以通过URL重写的方式发到服务器； token 访问资源的令牌验证流程：1.把用户的用户名和密码发到后端2.后端进行校验，校验成功会生成token, 把token发送给客户端3.客户端自己保存token, 再次请求就要在Http协议的请求头中带着token去访问服务端，和在服务端保存的token信息进行比对校验。 JWT java web token 的缩写，可使用restful接口定义，也可以用在web中段落引用组成：header在header中声明一些信息payload、 签证验证流程：1.段落引用在头部信息中声明加密算法和常量， 然后把header使用json转化为字符串2.段落引用在载荷中声明用户信息，同时还有一些其他的内容；再次使用json 把载荷部分进行转化，转化为字符串3.使用在header中声明的加密算法和每个项目随机生成的secret来进行加密， 把第一步分字符串和第二部分的字符串进行加密， 生成新的字符串。词字符串是独一无二的。4.解密的时候，只要客户端带着JWT来发起请求，服务端就直接使用secret进行解密。 特点：1.三部分组成，每一部分都进行字符串的转化2.解密的时候没有使用数据库，仅仅使用的是secret进行解密。3.JWT的secret不能泄密","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"login","slug":"login","permalink":"http://yoursite.com/tags/login/"}]},{"title":"Hexo免输入密码部署到github","slug":"Hexo免输入密码部署到github","date":"2020-06-07T10:52:19.000Z","updated":"2021-07-22T01:38:07.693Z","comments":true,"path":"2020/06/07/Hexo免输入密码部署到github/","link":"","permalink":"http://yoursite.com/2020/06/07/Hexo%E5%85%8D%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81%E9%83%A8%E7%BD%B2%E5%88%B0github/","excerpt":"","text":"hexo 使用hexo d命令部署到github时，会要求你输入用户名密码，每次提交都要输入，为了方便添加如下配置： 在系统变量中添加一个环境变量： 12变量名：HOME变量值：%USERPROFILE% 接着在你的用户目录（C:\\Users\\username）下新建一个叫 _netrc的文件编辑这个文件： 123machine github.comlogin usernamepassword password 设置好这些后，当你再次部署时，就不用输入用户名和密码了。","categories":[{"name":"博客","slug":"博客","permalink":"http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"}]},{"title":"使用jdk实现动态代理","slug":"使用jdk实现动态代理","date":"2020-06-07T05:21:02.000Z","updated":"2020-06-07T07:27:25.047Z","comments":true,"path":"2020/06/07/使用jdk实现动态代理/","link":"","permalink":"http://yoursite.com/2020/06/07/%E4%BD%BF%E7%94%A8jdk%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","excerpt":"","text":"java的代理就是客户类不再直接与委托类直接打打交道，而是通过一个中间层进行访问，这个中间层就是代理，优势: 1.隐藏委托类 2.代码解耦 代理主要分为静态代理、jdk动态代理、和CGLIB 动态代理，各有优缺点，没有最好的，存在即合理。 1 计算器接口需求例如我们有一个实现计算器的接口: 1234567891011121314151617181920212223242526272829public interface Calculator &#123; /** * 两个数相加 * @param a * @param b * @return */ int sub(int a, int b); /** * 两个数相减 * @param a * @param b * @return */ int less(int a, int b); /** * 两个数相乘 * @param a * @param b * @return */ int Multiply(int a, int b); /** * 两个数相除 * @param a * @param b * @return */ int except(int a, int b); 以及接口实现类，并且在每次预算前与运算后返回入参及结果打印: 123456789101112131415161718192021222324252627282930313233public class CalculatorImpl implements Calculator &#123; @Override public int sub(int a, int b) &#123; System.out.println(\"sub计算开始，参数为[\" + a + \",\"+ b +\"]。\"); int result = a + b; System.out.println(\"sub计算结束，结果为[\" + result +\"]。\"); return result; &#125; @Override public int less(int a, int b) &#123; System.out.println(\"less计算开始，参数为[\" + a + \",\"+ b +\"]。\"); int result = a - b; System.out.println(\"less计算结束，结果为[\" + result +\"]。\"); return result; &#125; @Override public int multiply(int a, int b) &#123; System.out.println(\"multiply计算开始，参数为[\" + a + \",\"+ b +\"]。\"); int result = a * b; System.out.println(\"multiply计算结束，结果为[\" + result +\"]。\"); return result; &#125; @Override public int except(int a, int b) &#123; System.out.println(\"except计算开始，参数为[\" + a + \",\"+ b +\"]。\"); int result = a / b; System.out.println(\"except计算结束，结果为[\" + result +\"]。\"); return result; &#125;&#125; 测试 1234567891011public class Test &#123; public static void main(String[] args) &#123; Calculator calculator = new CalculatorImpl(); int sub = calculator.sub(1, 2); System.out.println(\"---&gt;\" + sub); int less = calculator.less(6, 2); System.out.println(\"---&gt;\" + less); &#125;&#125; 打印结果为： sub计算开始，参数为[1,2]。sub计算结束，结果为[3]。—&gt;3less计算开始，参数为[6,2]。less计算结束，结果为[4]。—&gt;4 虽然实现了需求但是以上代码（虽然简单）暴露了很多问题： 1.代码混乱：越来越多的非业务需求（日志与验证等）加入后，原本简单的业务代码急剧膨胀，每个方法在处理核心逻辑的同时还需要关注多个点 2.代码分散：以日志需求为例，只是为了满足这个单一需求（加减乘除），就不得不在多个模块（方法）上多次重复相同的日志代码，如果日志代码修改，需要修改所有模块 2 使用jdk动态代理实现无入侵日志打印删除计算器实中的日志记录代码并创建动态代理类 CalculatorloggingProxy 1234567891011121314151617181920212223242526272829303132333435363738public class CalculatorloggingProxy &#123; //想要代理的对象 private Calculator target; public CalculatorloggingProxy(Calculator target) &#123; this.target = target; &#125; public Calculator getLoggingProxy()&#123; Calculator proxy = null; //代理对象由哪一个类加载器度负责加载 ClassLoader loader = target.getClass().getClassLoader(); //代理对象的类型，有哪些方法 Class[] interfaces = new Class[] &#123;Calculator.class&#125;; //当调用代理对象的方法时，执行该代码 InvocationHandler invocationHandler = new InvocationHandler() &#123; /** * @param proxy 正在返回的代理对象，一般情况下在 invoke方法中都不使用该对象 * @param method 正在被调用的方法 * @param args 方法的参数 * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String methodName = method.getName(); System.out.println(\"计算器[\"+ methodName + \"]方法开始执行,参数为\" + Arrays.asList(args)); //执行方法 Object result = method.invoke(target, args); System.out.println(\"方法[\"+ methodName + \"]计算完毕,结果为\" + result); return result; &#125; &#125;; proxy = (Calculator)Proxy.newProxyInstance(loader, interfaces, invocationHandler); return proxy; &#125;&#125; 测试test更改为 123456789101112131415161718public class Test &#123; public static void main(String[] args) &#123; Calculator calculator = new CalculatorImpl(); CalculatorloggingProxy calculatorloggingProxy = new CalculatorloggingProxy(calculator); //获取计算器代理对象 Calculator loggingProxy = calculatorloggingProxy.getLoggingProxy(); //调用加法 loggingProxy.sub(1, 2); //调用减法 loggingProxy.less(6, 2); //乘法 loggingProxy.multiply(4, 4); //除法 loggingProxy.except(18,2); &#125;&#125; 执行测试，结果为： 计算器[sub]方法开始执行,参数为[1, 2]方法[sub]计算完毕,结果为3计算器[less]方法开始执行,参数为[6, 2]方法[less]计算完毕,结果为4计算器[multiply]方法开始执行,参数为[4, 4]方法[multiply]计算完毕,结果为16计算器[except]方法开始执行,参数为[18, 2]方法[except]计算完毕,结果为9 至此我们完成了动态代理，实现需求。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"},{"name":"动态代理","slug":"动态代理","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"}]}],"categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"spring","slug":"java/spring","permalink":"http://yoursite.com/categories/java/spring/"},{"name":"springMVC","slug":"java/spring/springMVC","permalink":"http://yoursite.com/categories/java/spring/springMVC/"},{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"},{"name":"NoSql数据库","slug":"Redis/NoSql数据库","permalink":"http://yoursite.com/categories/Redis/NoSql%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"sql语句","slug":"sql语句","permalink":"http://yoursite.com/categories/sql%E8%AF%AD%E5%8F%A5/"},{"name":"数据库","slug":"sql语句/数据库","permalink":"http://yoursite.com/categories/sql%E8%AF%AD%E5%8F%A5/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"spring","slug":"spring","permalink":"http://yoursite.com/categories/spring/"},{"name":"springboot","slug":"spring/springboot","permalink":"http://yoursite.com/categories/spring/springboot/"},{"name":"java","slug":"spring/springboot/java","permalink":"http://yoursite.com/categories/spring/springboot/java/"},{"name":"Java8","slug":"Java8","permalink":"http://yoursite.com/categories/Java8/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"},{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"mvc\"","slug":"mvc","permalink":"http://yoursite.com/tags/mvc/"},{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"},{"name":"代码规范","slug":"代码规范","permalink":"http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"安装","slug":"安装","permalink":"http://yoursite.com/tags/%E5%AE%89%E8%A3%85/"},{"name":"查询重复记录","slug":"查询重复记录","permalink":"http://yoursite.com/tags/%E6%9F%A5%E8%AF%A2%E9%87%8D%E5%A4%8D%E8%AE%B0%E5%BD%95/"},{"name":"工厂模式","slug":"工厂模式","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"name":"注解","slug":"注解","permalink":"http://yoursite.com/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"自动装配","slug":"自动装配","permalink":"http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"},{"name":"java锁","slug":"java锁","permalink":"http://yoursite.com/tags/java%E9%94%81/"},{"name":"命令","slug":"命令","permalink":"http://yoursite.com/tags/%E5%91%BD%E4%BB%A4/"},{"name":"util","slug":"util","permalink":"http://yoursite.com/tags/util/"},{"name":"图片","slug":"图片","permalink":"http://yoursite.com/tags/%E5%9B%BE%E7%89%87/"},{"name":"login","slug":"login","permalink":"http://yoursite.com/tags/login/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"动态代理","slug":"动态代理","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"}]}