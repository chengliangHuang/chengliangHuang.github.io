{"meta":{"title":"QWHS","subtitle":"纸上得来终觉浅","description":"CV工程师，面向搜索引擎编程","author":"宁中老程","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2020-06-07T07:19:53.000Z","updated":"2020-06-07T07:22:18.159Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-06-07T04:44:54.000Z","updated":"2020-06-07T05:08:53.141Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"16 条 yyds 的代码规范","slug":"16-条-yyds-的代码规范","date":"2021-08-10T08:22:09.000Z","updated":"2021-08-10T08:45:53.123Z","comments":true,"path":"2021/08/10/16-条-yyds-的代码规范/","link":"","permalink":"http://yoursite.com/2021/08/10/16-%E6%9D%A1-yyds-%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/","excerpt":"","text":"MyBatis 不要为了多个查询条件而写 1 = 1 当遇到多个查询条件，使用where 1=1 可以很方便的解决我们的问题，但是这样很可能会造成非常大的性能损失，因为添加了 “where 1=1 ”的过滤条件之后，数据库系统就无法使用索引等查询优化策略，数据库系统将会被迫对每行数据进行扫描（即全表扫描） 以比较此行是否满足过滤条件，当表中的数据量较大时查询速度会非常慢；此外，还会存在SQL 注入的风险。 反例： 123456789&lt;select id=\"queryBookInfo\" parameterType=\"com.tjt.platform.entity.BookInfo\" resultType=\"java.lang.Integer\"&gt; select count(*) from t_rule_BookInfo t where 1=1&lt;if test=\"title !=null and title !='' \"&gt; AND title = #&#123;title&#125;&lt;/if&gt;&lt;if test=\"author !=null and author !='' \"&gt; AND author = #&#123;author&#125;&lt;/if&gt;&lt;/select&gt; 正例： 1234567891011&lt;select id=\"queryBookInfo\" parameterType=\"com.tjt.platform.entity.BookInfo\" resultType=\"java.lang.Integer\"&gt; select count(*) from t_rule_BookInfo t&lt;where&gt;&lt;if test=\"title !=null and title !='' \"&gt; title = #&#123;title&#125;&lt;/if&gt;&lt;if test=\"author !=null and author !='' \"&gt; AND author = #&#123;author&#125;&lt;/if&gt;&lt;/where&gt;&lt;/select&gt; UPDATE 操作也一样，可以用标记代替 1=1。 迭代entrySet() 获取Map 的key 和value 当循环中只需要获取Map 的主键key时，迭代keySet() 是正确的；但是，当需要主键key 和取值value 时，迭代entrySet() 才是更高效的做法，其比先迭代keySet() 后再去通过get 取值性能更佳。 反例： 12345//Map 获取value 反例:HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();for (String key : map.keySet())&#123; String value = map.get(key);&#125; 正例： 123456//Map 获取key &amp; value 正例:HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();for (Map.Entry&lt;String,String&gt; entry : map.entrySet())&#123; String key = entry.getKey(); String value = entry.getValue();&#125; 使用Collection.isEmpty() 检测空 使用Collection.size() 来检测是否为空在逻辑上没有问题，但是使用Collection.isEmpty() 使得代码更易读，并且可以获得更好的性能；除此之外，任何Collection.isEmpty() 实现的时间复杂度都是O(1) ，不需要多次循环遍历，但是某些通过Collection.size() 方法实现的时间复杂度可能是O(n)，或者使用第三方工具类如：Hutool 提供的集合检查工具。 反例： 1234LinkedList&lt;Object&gt; collection = new LinkedList&lt;&gt;();if (collection.size() == 0)&#123; System.out.println(\"collection is empty.\");&#125; 正例： 12345678910LinkedList&lt;Object&gt; collection = new LinkedList&lt;&gt;();if (collection.isEmpty())&#123; System.out.println(\"collection is empty.\");&#125;//检测是否为null 可以使用CollectionUtils.isEmpty()if (CollectionUtils.isEmpty(collection))&#123; System.out.println(\"collection is null.\");&#125; 初始化集合时尽量指定其大小 尽量在初始化时指定集合的大小，能有效减少集合的扩容次数，因为集合每次扩容的时间复杂度很可能时O(n)，耗费时间和性能。 反例： 123456//初始化list，往list 中添加元素反例：int[] arr = new int[]&#123;1,2,3,4&#125;;List&lt;Integer&gt; list = new ArrayList&lt;&gt;();for (int i : arr)&#123; list.add(i);&#125; 正例： 1234567//初始化list，往list 中添加元素正例：int[] arr = new int[]&#123;1,2,3,4&#125;;//指定集合list 的容量大小List&lt;Integer&gt; list = new ArrayList&lt;&gt;(arr.length);for (int i : arr)&#123; list.add(i);&#125; 使用StringBuilder 拼接字符串 一般的字符串拼接在编译期Java 会对其进行优化，但是在循环中字符串的拼接Java 编译期无法执行优化，所以需要使用StringBuilder 进行替换。 反例： 123456//在循环中拼接字符串反例String str = \"\";for (int i = 0; i &lt; 10; i++)&#123; //在循环中字符串拼接Java 不会对其进行优化 str += i;&#125; 正例： 123456789//在循环中拼接字符串正例String str1 = \"Love\";String str2 = \"Courage\";String strConcat = str1 + str2; //Java 编译器会对该普通模式的字符串拼接进行优化StringBuilder sb = new StringBuilder();for (int i = 0; i &lt; 10; i++)&#123; //在循环中，Java 编译器无法进行优化，所以要手动使用StringBuilder sb.append(i);&#125; 若需频繁调用Collection.contains 方法则使用Set 在Java 集合类库中，List的contains 方法普遍时间复杂度为O(n)，若代码中需要频繁调用contains 方法查找数据则先将集合list 转换成HashSet 实现，将O(n) 的时间复杂度将为O(1)。 反例： 1234567//频繁调用Collection.contains() 反例List&lt;Object&gt; list = new ArrayList&lt;&gt;();for (int i = 0; i &lt;= Integer.MAX_VALUE; i++)&#123; //时间复杂度为O(n) if (list.contains(i)) System.out.println(\"list contains \"+ i);&#125; 正例: 123456789//频繁调用Collection.contains() 正例List&lt;Object&gt; list = new ArrayList&lt;&gt;();Set&lt;Object&gt; set = new HashSet&lt;&gt;();for (int i = 0; i &lt;= Integer.MAX_VALUE; i++)&#123; //时间复杂度为O(1) if (set.contains(i))&#123; System.out.println(\"list contains \"+ i); &#125;&#125; 使用静态代码块实现赋值静态成员变量 对于集合类型的静态成员变量，应该使用静态代码块赋值，而不是使用集合实现来赋值。 反例： 123456789101112131415//赋值静态成员变量反例private static Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;()&#123; &#123; map.put(\"Leo\",1); map.put(\"Family-loving\",2); map.put(\"Cold on the out side passionate on the inside\",3); &#125;&#125;;private static List&lt;String&gt; list = new ArrayList&lt;&gt;()&#123; &#123; list.add(\"Sagittarius\"); list.add(\"Charming\"); list.add(\"Perfectionist\"); &#125;&#125;; 正例： 1234567891011121314//赋值静态成员变量正例private static Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();static &#123; map.put(\"Leo\",1); map.put(\"Family-loving\",2); map.put(\"Cold on the out side passionate on the inside\",3);&#125;private static List&lt;String&gt; list = new ArrayList&lt;&gt;();static &#123; list.add(\"Sagittarius\"); list.add(\"Charming\"); list.add(\"Perfectionist\");&#125; 删除未使用的局部变量、方法参数、私有方法、字段和多余的括号。工具类中屏蔽构造函数 工具类是一堆静态字段和函数的集合，其不应该被实例化；但是，Java 为每个没有明确定义构造函数的类添加了一个隐式公有构造函数，为了避免不必要的实例化，应该显式定义私有构造函数来屏蔽这个隐式公有构造函数。 反例： 123456789public class PasswordUtils &#123;//工具类构造函数反例private static final Logger LOG = LoggerFactory.getLogger(PasswordUtils.class);public static final String DEFAULT_CRYPT_ALGO = \"PBEWithMD5AndDES\";public static String encryptPassword(String aPassword) throws IOException &#123; return new PasswordUtils(aPassword).encrypt();&#125; 正例： 123456789101112public class PasswordUtils &#123;//工具类构造函数正例private static final Logger LOG = LoggerFactory.getLogger(PasswordUtils.class);//定义私有构造函数来屏蔽这个隐式公有构造函数private PasswordUtils()&#123;&#125;public static final String DEFAULT_CRYPT_ALGO = \"PBEWithMD5AndDES\";public static String encryptPassword(String aPassword) throws IOException &#123; return new PasswordUtils(aPassword).encrypt();&#125; 删除多余的异常捕获并抛出 用catch 语句捕获异常后，若什么也不进行处理，就只是让异常重新抛出，这跟不捕获异常的效果一样，可以删除这块代码或添加别的处理。 反例： 123456789101112131415//多余异常反例private static String fileReader(String fileName)throws IOException&#123; try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) &#123; String line; StringBuilder builder = new StringBuilder(); while ((line = reader.readLine()) != null) &#123; builder.append(line); &#125; return builder.toString(); &#125; catch (Exception e) &#123; //仅仅是重复抛异常 未作任何处理 throw e; &#125;&#125; 正例： 12345678910111213141516//多余异常正例private static String fileReader(String fileName)throws IOException&#123; try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) &#123; String line; StringBuilder builder = new StringBuilder(); while ((line = reader.readLine()) != null) &#123; builder.append(line); &#125; return builder.toString(); //删除多余的抛异常，或增加其他处理： /*catch (Exception e) &#123; return \"fileReader exception\"; &#125;*/ &#125;&#125; 字符串转化使用String.valueOf(value) 代替 “ “ + value 把其它对象或类型转化为字符串时，使用String.valueOf(value) 比 “”+value 的效率更高。 反例： 1234//把其它对象或类型转化为字符串反例：int num = 520;// \"\" + valueString strLove = \"\" + num; 正例： 1234//把其它对象或类型转化为字符串正例：int num = 520;// String.valueOf() 效率更高String strLove = String.valueOf(num); 避免使用BigDecimal(double) BigDecimal(double) 存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。 反例： 12// BigDecimal 反例BigDecimal bigDecimal = new BigDecimal(0.11D); 正例： 12// BigDecimal 正例BigDecimal bigDecimal1 = bigDecimal.valueOf(0.11D); 返回空数组和集合而非 null 若程序运行返回null，需要调用方强制检测null，否则就会抛出空指针异常；返回空数组或空集合，有效地避免了调用方因为未检测null 而抛出空指针异常的情况，还可以删除调用方检测null 的语句使代码更简洁。 反例： 123456789101112//返回null 反例public static Result[] getResults() &#123; return null;&#125;public static List&lt;Result&gt; getResultList() &#123; return null;&#125;public static Map&lt;String, Result&gt; getResultMap() &#123; return null;&#125; 正例： 123456789101112//返回空数组和空集正例public static Result[] getResults() &#123; return new Result[0];&#125;public static List&lt;Result&gt; getResultList() &#123; return Collections.emptyList();&#125;public static Map&lt;String, Result&gt; getResultMap() &#123; return Collections.emptyMap();&#125; 优先使用常量或确定值调用equals 方法 对象的equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals 方法。 反例： 123456//调用 equals 方法反例private static boolean fileReader(String fileName)throws IOException&#123; // 可能抛空指针异常 return fileName.equals(\"Charming\");&#125; 正例： 123456789//调用 equals 方法正例private static boolean fileReader(String fileName)throws IOException&#123; // 使用常量或确定有值的对象来调用 equals 方法 return \"Charming\".equals(fileName); //或使用：java.util.Objects.equals() 方法 return Objects.equals(\"Charming\",fileName);&#125; 枚举的属性字段必须是私有且不可变 枚举通常被当做常量使用，如果枚举中存在公共属性字段或设置字段方法，那么这些枚举常量的属性很容易被修改；理想情况下，枚举中的属性字段是私有的，并在私有构造函数中赋值，没有对应的Setter 方法，最好加上final 修饰符。 反例： 123456789101112131415161718192021public enum SwitchStatus &#123; // 枚举的属性字段反例 DISABLED(0, \"禁用\"), ENABLED(1, \"启用\"); public int value; private String description; private SwitchStatus(int value, String description) &#123; this.value = value; this.description = description; &#125; public String getDescription() &#123; return description; &#125; public void setDescription(String description) &#123; this.description = description; &#125;&#125; 正例： 1234567891011121314151617181920212223public enum SwitchStatus &#123; // 枚举的属性字段正例 DISABLED(0, \"禁用\"), ENABLED(1, \"启用\"); // final 修饰 private final int value; private final String description; private SwitchStatus(int value, String description) &#123; this.value = value; this.description = description; &#125; // 没有Setter 方法 public int getValue() &#123; return value; &#125; public String getDescription() &#123; return description; &#125;&#125; tring.split(String regex)部分关键字需要转译 使用字符串String 的plit 方法时，传入的分隔字符串是正则表达式，则部分关键字（比如 .| 等）需要转义。 反例： 123456// String.split(String regex) 反例String[] split = \"a.ab.abc\".split(\".\");System.out.println(Arrays.toString(split)); // 结果为[]String[] split1 = \"a|ab|abc\".split(\"|\");System.out.println(Arrays.toString(split1)); // 结果为[\"a\", \"|\", \"a\", \"b\", \"|\", \"a\", \"b\", \"c\"] 正例： 12345678// String.split(String regex) 正例// . 需要转译String[] split2 = \"a.ab.abc\".split(\"\\\\.\");System.out.println(Arrays.toString(split2)); // 结果为[\"a\", \"ab\", \"abc\"]// | 需要转译String[] split3 = \"a|ab|abc\".split(\"\\\\|\");System.out.println(Arrays.toString(split3)); // 结果为[\"a\", \"ab\", \"abc\"]","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"},{"name":"代码规范","slug":"代码规范","permalink":"http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"}]},{"title":"win10安装Redis","slug":"win10安装Redis","date":"2021-08-05T01:57:57.000Z","updated":"2021-08-05T02:25:32.680Z","comments":true,"path":"2021/08/05/win10安装Redis/","link":"","permalink":"http://yoursite.com/2021/08/05/win10%E5%AE%89%E8%A3%85Redis/","excerpt":"","text":"win10安装redis下载下载地址： https://github.com/MicrosoftArchive/redis/releases 根据系统下载的版本：以（64位为例） 下载后一般解压到根目录下：如（E:\\Redis-x64-3.2.100） 安装打开cmd命令窗口，使用命令进行安装和注册redis到window服务 安装命令：redis-server.exe –service-install redis.windows.conf –loglevel verbose 启动服务命令：redis-server.exe –service-start 关闭服务命令：redis-server.exe –service-stop 最后返回的successfully表示安装成功。 也可以通过任务管理器中查看后台中是否有redis-service来判断是否启动成功。 我们重新打开一个cmd ,作为一个客户端调用redis服务，如下图所示，调用命令是：redis-cli.exe -h 127.0.0.1 -p 6379，如下图显示地址和端口，说明调用成功 然后我们使用set 和get 命令进行测试一下，set uname “abc”,然后使用get uname可以获取到对应set的值，说明调用成功 客户端使用redis我们重新打开一个cmd ,作为一个客户端调用redis服务，如下图所示，调用命令是：redis-cli.exe -h 127.0.0.1 -p 6379，如下图显示地址和端口，说明调用成功 然后我们使用set 和get 命令进行测试一下，set uname “abc”,然后使用get uname可以获取到对应set的值，说明调用成功 设置密码 还可以通过将字符串设置为空来清空密码：CONFIG SET requirepass “”","categories":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"},{"name":"NoSql数据库","slug":"Redis/NoSql数据库","permalink":"http://yoursite.com/categories/Redis/NoSql%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"},{"name":"安装","slug":"安装","permalink":"http://yoursite.com/tags/%E5%AE%89%E8%A3%85/"}]},{"title":"sql 查出一张表中重复的所有记录数据","slug":"sql-查出一张表中重复的所有记录数据","date":"2021-07-22T07:45:35.000Z","updated":"2021-07-22T07:51:21.858Z","comments":true,"path":"2021/07/22/sql-查出一张表中重复的所有记录数据/","link":"","permalink":"http://yoursite.com/2021/07/22/sql-%E6%9F%A5%E5%87%BA%E4%B8%80%E5%BC%A0%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%89%80%E6%9C%89%E8%AE%B0%E5%BD%95%E6%95%B0%E6%8D%AE/","excerpt":"","text":"查询重复的数据1.查询出所有数据进行分组之后，和重复数据的重复次数的查询数据，先列下： 1select count(username) as '重复次数',username from t_user group by username having count(*)&gt;1 order by username desc 2.查找表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断 1select * from people where peopleId in (select peopleId from people group by peopleId having count(peopleId) &gt; 1) 3.查找表中多余的重复记录（多个字段） 1select * from people a where (a.peopleId,a.seq) in (select peopleId,seq from people group by peopleId,seq having count(*) &gt; 1)","categories":[{"name":"sql语句","slug":"sql语句","permalink":"http://yoursite.com/categories/sql%E8%AF%AD%E5%8F%A5/"},{"name":"数据库","slug":"sql语句/数据库","permalink":"http://yoursite.com/categories/sql%E8%AF%AD%E5%8F%A5/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"},{"name":"查询重复记录","slug":"查询重复记录","permalink":"http://yoursite.com/tags/%E6%9F%A5%E8%AF%A2%E9%87%8D%E5%A4%8D%E8%AE%B0%E5%BD%95/"}]},{"title":"深入理解 Java 的 3 种工厂模式","slug":"深入理解-Java-的-3-种工厂模式","date":"2021-07-22T02:52:40.000Z","updated":"2021-07-22T07:56:36.978Z","comments":true,"path":"2021/07/22/深入理解-Java-的-3-种工厂模式/","link":"","permalink":"http://yoursite.com/2021/07/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E7%9A%84-3-%E7%A7%8D%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"简单工厂模式简单工厂的定义：提供一个创建对象实例的功能，而无须关心其具体实现。被创建实例的类型可以是接口、抽象类，也可以是具体的类 实现汽车接口 123public interface Car &#123; String getName();&#125; 奔驰类 123456public class Benz implements Car &#123; @Override public String getName() &#123; return \"Benz\"; &#125;&#125; 宝马类 123456public class BMW implements Car &#123; @Override public String getName() &#123; return \"BMW\"; &#125;&#125; 简单工厂，既能生产宝马又能生产奔驰 123456789101112public class SimpleFactory &#123; public Car getCar(String name)&#123; if (name.equals(\"BMW\"))&#123; return new BMW(); &#125;else if (name.equals(\"benz\"))&#123; return new Benz(); &#125;else &#123; System.out.println(\"不好意思，这个品牌的汽车生产不了\"); return null; &#125; &#125;&#125; 测试类 1234567public class SimpleFactoryTest &#123; public static void main(String[] args)&#123; SimpleFactory simpleFactory = new SimpleFactory(); Car car = simpleFactory.getCar(\"BMW\"); System.out.println(car.getName()); &#125;&#125; 测试结果 1BMW 根据简单工厂的定义，用户只要产品而不在乎产品如何生产，看起来好像很完美的样子这个世界存在什么都生产的工厂吗？ 显然是不存在的，每一个汽车品牌都有自己的生产工厂，都有自己生产技术。映射到spring框架中，我们有很多很多种的bean需要生产，如果只依靠一个简单工厂来实现，那么我们得在工厂类中嵌套多少个if..else if啊？ 而且我们在代码中生产一辆汽车只是new一下就出来了，但实际操作中却不知道需要进行多少操作，加载、注册等操作都将体现在工厂类中，那么这个类就会变得紊乱，管理起来也很不方便，所以说每个品牌应该有自己的生产类。 因为专一，所以专业，这个时候工厂方法就出现了。 工厂方法工厂接口 1234//定义一个工厂接口，功能就是生产汽车public interface Factory &#123; Car getCar();&#125; 奔驰工厂 123456public class BenzFactory implements Factory &#123; @Override public Car getCar() &#123; return new Benz(); &#125;&#125; 宝马工厂 1234public class BMWFactory implements Factory&#123; @Override public Car getCar() &#123;return new BMW();&#125;&#125; 测试类 12345678public class FactoryTest &#123; public static void main(String[] args) &#123; Factory bmwFactory = new BMWFactory(); System.out.println(bmwFactory.getCar().getName()); Factory benzFactory = new BenzFactory(); System.out.println(benzFactory.getCar().getName()); &#125;&#125; 测试结果 1BMWBenz 根据上述代码可以看出，不同品牌的汽车是由不同的工厂生产的，貌似又是很完美的。但大家看一下测试类，当一个人想要去买一辆宝马汽车的时候（假设没有销售商），那么他就要去找宝马工厂给他生产一辆，过几天又想要买一辆奔驰汽车的时候，又得跑到奔驰工厂请人生产，这无疑就增加了用户的操作复杂性。所以有没有一种方便用户操作的方法呢？这个时候抽象工厂模式就出现了。 抽象工厂抽象工厂 12345678910public abstract class AbstractFactory &#123; protected abstract Car getCar(); //这段代码就是动态配置的功能//固定模式的委派 public Car getCar(String name)&#123; if(\"BMW\".equalsIgnoreCase(name))&#123;return new BmwFactory().getCar();&#125; else if(\"Benz\".equalsIgnoreCase(name))&#123;return new BenzFactory().getCar();&#125; else if(\"Audi\".equalsIgnoreCase(name))&#123;return new AudiFactory().getCar();&#125; else&#123;System.out.println(\"这个产品产不出来\");return null;&#125; &#125;&#125; 默认工厂 1234public class DefaultFactory extends AbstractFactory &#123; private AudiFactory defaultFactory = new AudiFactory(); public Car getCar() &#123;return defaultFactory.getCar();&#125;&#125; 宝马工厂 123456public class BMWFactory extends AbstractFactory &#123; @Override public Car getCar() &#123; return new BMW(); &#125;&#125; 奔驰工厂 123456public class BenzFactory extends AbstractFactory &#123; @Override public Car getCar() &#123; return new Benz(); &#125;&#125; 测试类 123456public class AbstractFactoryTest &#123; public static void main(String[] args) &#123; DefaultFactory factory = new DefaultFactory(); System.out.println(factory.getCar(\"Benz\").getName()); &#125;&#125; 测试结果 1Benz 根据上述代码可以看出，用户需要一辆汽车，只需要去找默认的工厂提出自己的需求（传入参数），便能得到自己想要产品，而不用根据产品去寻找不同的生产工厂，方便用户操作。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"},{"name":"工厂模式","slug":"工厂模式","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"}]},{"title":"Spring Boot 注解原理与自动装配原理","slug":"Spring-Boot-注解原理与自动装配原理","date":"2021-07-22T02:02:09.000Z","updated":"2021-07-22T02:20:24.753Z","comments":true,"path":"2021/07/22/Spring-Boot-注解原理与自动装配原理/","link":"","permalink":"http://yoursite.com/2021/07/22/Spring-Boot-%E6%B3%A8%E8%A7%A3%E5%8E%9F%E7%90%86%E4%B8%8E%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/","excerpt":"","text":"首先，先看SpringBoot的主配置类： 12345678@SpringBootApplicationpublic class StartEurekaApplication&#123; public static void main(String[] args) &#123; SpringApplication.run(StartEurekaApplication.class, args); &#125;&#125; 点进@SpringBootApplication来看，发现@SpringBootApplication是一个组合注解。 123456789101112@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123;&#125; 首先我们先来看 @SpringBootConfiguration： 123456@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Configurationpublic @interface SpringBootConfiguration &#123;&#125; 可以看到这个注解除了元注解以外，就只有一个@Configuration，那也就是说这个注解相当于@Configuration，所以这两个注解作用是一样的，它让我们能够去注册一些额外的Bean，并且导入一些额外的配置。 那@Configuration还有一个作用就是把该类变成一个配置类，不需要额外的XML进行配置。所以@SpringBootConfiguration就相当于@Configuration。进入@Configuration，发现@Configuration核心是@Component，说明Spring的配置类也是Spring的一个组件。 12345678910@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Configuration &#123; @AliasFor( annotation = Component.class ) String value() default \"\";&#125; 继续来看下一个@EnableAutoConfiguration,这个注解是开启自动配置的功能。 12345678910111213@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;)public @interface EnableAutoConfiguration &#123; String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\"; Class&lt;?&gt;[] exclude() default &#123;&#125;; String[] excludeName() default &#123;&#125;;&#125; 可以看到它是由 @AutoConfigurationPackage，@Import(EnableAutoConfigurationImportSelector.class)这两个而组成的，我们先说@AutoConfigurationPackage，他是说：让包中的类以及子包中的类能够被自动扫描到spring容器中。 1234567@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Import(&#123;Registrar.class&#125;)public @interface AutoConfigurationPackage &#123;&#125; 使用@Import来给Spring容器中导入一个组件 ，这里导入的是Registrar.class。来看下这个Registrar： 123456789101112static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports &#123; Registrar() &#123; &#125; public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123; AutoConfigurationPackages.register(registry, (new AutoConfigurationPackages.PackageImport(metadata)).getPackageName()); &#125; public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) &#123; return Collections.singleton(new AutoConfigurationPackages.PackageImport(metadata)); &#125; &#125; 就是通过以上这个方法获取扫描的包路径，可以debug查看具体的值： 那metadata是什么呢，可以看到是标注在@SpringBootApplication注解上的DemosbApplication，也就是我们的主配置类Application： 其实就是将主配置类（即@SpringBootApplication标注的类）的所在包及子包里面所有组件扫描加载到Spring容器。因此我们要把DemoApplication放在项目的最高级中（最外层目录）。 看看注解@Import(AutoConfigurationImportSelector.class)，@Import注解就是给Spring容器中导入一些组件，这里传入了一个组件的选择器:AutoConfigurationImportSelector。 可以从图中看出AutoConfigurationImportSelector 继承了 DeferredImportSelector 继承了 ImportSelector，ImportSelector有一个方法为：selectImports。将所有需要导入的组件以全类名的方式返回，这些组件就会被添加到容器中。 12345678910public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; if (!this.isEnabled(annotationMetadata)) &#123; return NO_IMPORTS; &#125; else &#123; AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(this.beanClassLoader); AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); &#125;&#125; 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件。 有了自动配置类，免去了我们手动编写配置注入功能组件等的工作。那是如何获取到这些配置类的呢，看看下面这个方法： 12345678910111213141516protected AutoConfigurationImportSelector.AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) &#123; if (!this.isEnabled(annotationMetadata)) &#123; return EMPTY_ENTRY; &#125; else &#123; AnnotationAttributes attributes = this.getAttributes(annotationMetadata); List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes); configurations = this.removeDuplicates(configurations); Set&lt;String&gt; exclusions = this.getExclusions(annotationMetadata, attributes); this.checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = this.filter(configurations, autoConfigurationMetadata); this.fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions); &#125;&#125; 我们可以看到getCandidateConfigurations()这个方法，他的作用就是引入系统已经加载好的一些类，到底是那些类呢： 12345678910protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123; List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader()); Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.\"); return configurations;&#125;public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123; String factoryClassName = factoryClass.getName(); return (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());&#125; 会从META-INF/spring.factories中获取资源，然后通过Properties加载资源： 123456789101112131415161718192021222324252627282930313233343536private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123; MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader); if (result != null) &#123; return result; &#125; else &#123; try &#123; Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(\"META-INF/spring.factories\") : ClassLoader.getSystemResources(\"META-INF/spring.factories\"); LinkedMultiValueMap result = new LinkedMultiValueMap(); while(urls.hasMoreElements()) &#123; URL url = (URL)urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); Iterator var6 = properties.entrySet().iterator(); while(var6.hasNext()) &#123; Map.Entry&lt;?, ?&gt; entry = (Map.Entry)var6.next(); String factoryClassName = ((String)entry.getKey()).trim(); String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue()); int var10 = var9.length; for(int var11 = 0; var11 &lt; var10; ++var11) &#123; String factoryName = var9[var11]; result.add(factoryClassName, factoryName.trim()); &#125; &#125; &#125; cache.put(classLoader, result); return result; &#125; catch (IOException var13) &#123; throw new IllegalArgumentException(\"Unable to load factories from location [META-INF/spring.factories]\", var13); &#125; &#125;&#125; 可以知道SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作。以前我们需要自己配置的东西，自动配置类都帮我们完成了。如下图可以发现Spring常见的一些类已经自动导入。 接下来看@ComponentScan注解，@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })，这个注解就是扫描包，然后放入spring容器。 1234@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM,classes = &#123;TypeExcludeFilter.class&#125;), @Filter(type = FilterType.CUSTOM,classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123;&#125; 总结下@SpringbootApplication：就是说，他已经把很多东西准备好，具体是否使用取决于我们的程序或者说配置。 接下来继续看run方法： 123public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125; 来看下在执行run方法到底有没有用到哪些自动配置的东西，我们点进run： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public ConfigurableApplicationContext run(String... args) &#123; //计时器 StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList(); this.configureHeadlessProperty(); //监听器 SpringApplicationRunListeners listeners = this.getRunListeners(args); listeners.starting(); Collection exceptionReporters; try &#123; ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); ConfigurableEnvironment environment = this.prepareEnvironment(listeners, applicationArguments); this.configureIgnoreBeanInfo(environment); Banner printedBanner = this.printBanner(environment); //准备上下文 context = this.createApplicationContext(); exceptionReporters = this.getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[]&#123;ConfigurableApplicationContext.class&#125;, context); //预刷新context this.prepareContext(context, environment, listeners, applicationArguments, printedBanner); //刷新context this.refreshContext(context); //刷新之后的context this.afterRefresh(context, applicationArguments); stopWatch.stop(); if (this.logStartupInfo) &#123; (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), stopWatch); &#125; listeners.started(context); this.callRunners(context, applicationArguments); &#125; catch (Throwable var10) &#123; this.handleRunFailure(context, var10, exceptionReporters, listeners); throw new IllegalStateException(var10); &#125; try &#123; listeners.running(context); return context; &#125; catch (Throwable var9) &#123; this.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)null); throw new IllegalStateException(var9); &#125;&#125; 那我们关注的就是 refreshContext(context); 刷新context，我们点进来看。 1234567891011private void refreshContext(ConfigurableApplicationContext context) &#123; refresh(context); if (this.registerShutdownHook) &#123; try &#123; context.registerShutdownHook(); &#125; catch (AccessControlException ex) &#123; // Not allowed in some environments. &#125; &#125;&#125; 我们继续点进refresh(context); 1234protected void refresh(ApplicationContext applicationContext) &#123; Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext); ((AbstractApplicationContext) applicationContext).refresh();&#125; 他会调用 ((AbstractApplicationContext) applicationContext).refresh();方法，我们点进来看： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125;catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125;finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; 由此可知，就是一个spring的bean的加载过程。继续来看一个方法叫做 onRefresh()： 123protected void onRefresh() throws BeansException &#123; // For subclasses: do nothing by default.&#125; 他在这里并没有直接实现，但是我们找他的具体实现： 比如Tomcat跟web有关，我们可以看到有个ServletWebServerApplicationContext： 12345678910@Overrideprotected void onRefresh() &#123; super.onRefresh(); try &#123; createWebServer(); &#125; catch (Throwable ex) &#123; throw new ApplicationContextException(\"Unable to start web server\", ex); &#125;&#125; 可以看到有一个createWebServer();方法他是创建web容器的，而Tomcat不就是web容器，那是如何创建的呢，我们继续看： 123456789101112131415161718private void createWebServer() &#123; WebServer webServer = this.webServer; ServletContext servletContext = getServletContext(); if (webServer == null &amp;&amp; servletContext == null) &#123; ServletWebServerFactory factory = getWebServerFactory(); this.webServer = factory.getWebServer(getSelfInitializer()); &#125; else if (servletContext != null) &#123; try &#123; getSelfInitializer().onStartup(servletContext); &#125; catch (ServletException ex) &#123; throw new ApplicationContextException(\"Cannot initialize servlet context\", ex); &#125; &#125; initPropertySources();&#125; factory.getWebServer(getSelfInitializer());他是通过工厂的方式创建的。 123public interface ServletWebServerFactory &#123; WebServer getWebServer(ServletContextInitializer... initializers);&#125; 可以看到 它是一个接口，为什么会是接口。因为我们不止是Tomcat一种web容器。 我们看到还有Jetty，那我们来看TomcatServletWebServerFactory： 123456789101112131415161718@Overridepublic WebServer getWebServer(ServletContextInitializer... initializers) &#123; Tomcat tomcat = new Tomcat(); File baseDir = (this.baseDirectory != null) ? this.baseDirectory : createTempDir(\"tomcat\"); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); customizeConnector(connector); tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); configureEngine(tomcat.getEngine()); for (Connector additionalConnector : this.additionalTomcatConnectors) &#123; tomcat.getService().addConnector(additionalConnector); &#125; prepareContext(tomcat.getHost(), initializers); return getTomcatWebServer(tomcat);&#125; 那这块代码，就是我们要寻找的内置Tomcat，在这个过程当中，我们可以看到创建Tomcat的一个流程。 如果不明白的话， 我们在用另一种方式来理解下，大家要应该都知道stater举点例子。 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;&lt;/dependency&gt; 首先自定义一个stater。 12345678910111213141516&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt;&lt;groupId&gt;com.zgw&lt;/groupId&gt;&lt;artifactId&gt;gw-spring-boot-starter&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 我们先来看maven配置写入版本号，如果自定义一个stater的话必须依赖spring-boot-autoconfigure这个包,我们先看下项目目录。 1234567891011public class GwServiceImpl implements GwService&#123; @Autowired GwProperties properties; @Override public void Hello() &#123; String name=properties.getName(); System.out.println(name+\"说:你们好啊\"); &#125;&#125; 我们做的就是通过配置文件来定制name这个是具体实现。 1234567891011121314@Component@ConfigurationProperties(prefix = \"spring.gwname\")public class GwProperties &#123; String name=\"zgw\"; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 这个类可以通过@ConfigurationProperties读取配置文件。 1234567891011121314151617@Configuration@ConditionalOnClass(GwService.class) //扫描类@EnableConfigurationProperties(GwProperties.class) //让配置类生效public class GwAutoConfiguration &#123; /** * 功能描述 托管给spring * @author zgw * @return */ @Bean @ConditionalOnMissingBean public GwService gwService() &#123; return new GwServiceImpl(); &#125;&#125; 这个为配置类，为什么这么写因为，spring-boot的stater都是这么写的，我们可以参照他仿写stater，以达到自动配置的目的，然后我们在通过spring.factories也来进行配置。 1org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.gw.GwAutoConfiguration 然后这样一个简单的stater就完成了，然后可以进行maven的打包，在其他项目引入就可以使用。","categories":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/categories/spring/"},{"name":"springboot","slug":"spring/springboot","permalink":"http://yoursite.com/categories/spring/springboot/"},{"name":"java","slug":"spring/springboot/java","permalink":"http://yoursite.com/categories/spring/springboot/java/"}],"tags":[{"name":"注解","slug":"注解","permalink":"http://yoursite.com/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"自动装配","slug":"自动装配","permalink":"http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"}]},{"title":"图解Java中那18 把锁","slug":"图解Java中那18-把锁","date":"2021-07-21T08:00:02.000Z","updated":"2021-07-22T01:35:48.750Z","comments":true,"path":"2021/07/21/图解Java中那18-把锁/","link":"","permalink":"http://yoursite.com/2021/07/21/%E5%9B%BE%E8%A7%A3Java%E4%B8%AD%E9%82%A318-%E6%8A%8A%E9%94%81/","excerpt":"","text":"乐观锁和悲观锁 独占锁和共享锁 互斥锁和读写锁 公平锁和非公平锁 可重入锁 自旋锁 分段锁 锁升级（无锁|偏向锁|轻量级锁|重量级锁） 锁优化技术（锁粗化、锁消除） 乐观锁与悲观锁 悲观锁 悲观锁对应于生活中悲观的人，悲观的人总是想着事情往坏的方向发展。 举个生活中的例子，假设厕所只有一个坑位了，悲观锁上厕所会第一时间把门反锁上，这样其他人上厕所只能在门外等候，这种状态就是「阻塞」了。 回到代码世界中，一个共享数据加了悲观锁，那线程每次想操作这个数据前都会假设其他线程也可能会操作这个数据，所以每次操作前都会上锁，这样其他线程想操作这个数据拿不到锁只能阻塞了。 在 Java 语言中 synchronized 和 ReentrantLock等就是典型的悲观锁，还有一些使用了 synchronized 关键字的容器类如 HashTable 等也是悲观锁的应用。 乐观锁 乐观锁 对应于生活中乐观的人，乐观的人总是想着事情往好的方向发展。 举个生活中的例子，假设厕所只有一个坑位了，乐观锁认为：这荒郊野外的，又没有什么人，不会有人抢我坑位的，每次关门上锁多浪费时间，还是不加锁好了。你看乐观锁就是天生乐观！ 回到代码世界中，乐观锁操作数据时不会上锁，在更新的时候会判断一下在此期间是否有其他线程去更新这个数据。 乐观锁可以使用版本号机制和CAS算法实现。在 Java 语言中 java.util.concurrent.atomic包下的原子类就是使用CAS 乐观锁实现的。 两种锁的使用场景 悲观锁和乐观锁没有孰优孰劣，有其各自适应的场景。 乐观锁适用于写比较少（冲突比较小）的场景，因为不用上锁、释放锁，省去了锁的开销，从而提升了吞吐量。 如果是写多读少的场景，即冲突比较严重，线程间竞争激烈，使用乐观锁就是导致线程不断进行重试，这样可能还降低了性能，这种场景下使用悲观锁就比较合适。 独占锁与共享锁 独占锁 独占锁是指锁一次只能被一个线程所持有。如果一个线程对数据加上排他锁后，那么其他线程不能再对该数据加任何类型的锁。获得独占锁的线程即能读数据又能修改数据。 JDK中的synchronized和java.util.concurrent(JUC)包中Lock的实现类就是独占锁。 共享锁 共享锁是指锁可被多个线程所持有。如果一个线程对数据加上共享锁后，那么其他线程只能对数据再加共享锁，不能加独占锁。获得共享锁的线程只能读数据，不能修改数据。 在 JDK 中 ReentrantReadWriteLock 就是一种共享锁。 互斥锁和读写锁 互斥锁 互斥锁是独占锁的一种常规实现，是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。 互斥锁一次只能一个线程拥有互斥锁，其他线程只有等待。 读写锁 读写锁是共享锁的一种具体实现。读写锁管理一组锁，一个是只读的锁，一个是写锁。 读锁可以在没有写锁的时候被多个线程同时持有，而写锁是独占的。写锁的优先级要高于读锁，一个获得了读锁的线程必须能看到前一个释放的写锁所更新的内容。 读写锁相比于互斥锁并发程度更高，每次只有一个写线程，但是同时可以有多个线程并发读。 在 JDK 中定义了一个读写锁的接口：ReadWriteLock 1234567891011public interface ReadWriteLock &#123; /** * 获取读锁 */ Lock readLock(); /** * 获取写锁 */ Lock writeLock();&#125; ReentrantReadWriteLock 实现了ReadWriteLock接口，具体实现这里不展开，后续会深入源码解析。 公平锁和非公平锁 公平锁 公平锁是指多个线程按照申请锁的顺序来获取锁，这里类似排队买票，先来的人先买，后来的人在队尾排着，这是公平的。 在 java 中可以通过构造函数初始化公平锁 1234/*** 创建一个可重入锁，true 表示公平锁，false 表示非公平锁。默认非公平锁*/Lock lock = new ReentrantLock(true); 非公平锁 非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成优先级翻转，或者饥饿的状态（某个线程一直得不到锁）。 在 java 中 synchronized 关键字是非公平锁，ReentrantLock默认也是非公平锁。 1234/*** 创建一个可重入锁，true 表示公平锁，false 表示非公平锁。默认非公平锁*/Lock lock = new ReentrantLock(false); 可重入锁 可重入锁又称之为递归锁，是指同一个线程在外层方法获取了锁，在进入内层方法会自动获取锁。 对于Java ReentrantLock而言, 他的名字就可以看出是一个可重入锁。对于Synchronized而言，也是一个可重入锁。 敲黑板：可重入锁的一个好处是可一定程度避免死锁。 以 synchronized 为例，看一下下面的代码： 12345678public synchronized void mehtodA() throws Exception&#123; // Do some magic tings mehtodB();&#125;public synchronized void mehtodB() throws Exception&#123; // Do some magic tings&#125; 上面的代码中 methodA 调用 methodB，如果一个线程调用methodA 已经获取了锁再去调用 methodB 就不需要再次获取锁了，这就是可重入锁的特性。如果不是可重入锁的话，mehtodB 可能不会被当前线程执行，可能造成死锁。 自旋锁 自旋锁是指线程在没有获得锁时不是被直接挂起，而是执行一个忙循环，这个忙循环就是所谓的自旋。 自旋锁的目的是为了减少线程被挂起的几率，因为线程的挂起和唤醒也都是耗资源的操作。 如果锁被另一个线程占用的时间比较长，即使自旋了之后当前线程还是会被挂起，忙循环就会变成浪费系统资源的操作，反而降低了整体性能。因此自旋锁是不适应锁占用时间长的并发情况的。 在 Java 中，AtomicInteger 类有自旋的操作，我们看一下代码： 1234567public final int getAndAddInt(Object o, long offset, int delta) &#123; int v; do &#123; v = getIntVolatile(o, offset); &#125; while (!compareAndSwapInt(o, offset, v, v + delta)); return v;&#125; CAS 操作如果失败就会一直循环获取当前 value 值然后重试。 另外自适应自旋锁也需要了解一下。 在JDK1.6又引入了自适应自旋，这个就比较智能了，自旋时间不再固定，由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定。如果虚拟机认为这次自旋也很有可能再次成功那就会次序较多的时间，如果自旋很少成功，那以后可能就直接省略掉自旋过程，避免浪费处理器资源。 分段锁 分段锁 是一种锁的设计，并不是具体的一种锁。 分段锁设计目的是将锁的粒度进一步细化，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。 在 Java 语言中 CurrentHashMap 底层就用了分段锁，使用Segment，就可以进行并发使用了。 锁升级（无锁|偏向锁|轻量级锁|重量级锁） JDK1.6 为了提升性能减少获得锁和释放锁所带来的消耗，引入了4种锁的状态：无锁、偏向锁、轻量级锁和重量级锁，它会随着多线程的竞争情况逐渐升级，但不能降级。 无锁 无锁状态其实就是上面讲的乐观锁，这里不再赘述。 偏向锁 Java偏向锁(Biased Locking)是指它会偏向于第一个访问锁的线程，如果在运行过程中，只有一个线程访问加锁的资源，不存在多线程竞争的情况，那么线程是不需要重复获取锁的，这种情况下，就会给线程加一个偏向锁。 偏向锁的实现是通过控制对象Mark Word的标志位来实现的，如果当前是可偏向状态，需要进一步判断对象头存储的线程 ID 是否与当前线程 ID 一致，如果一致直接进入。 轻量级锁 当线程竞争变得比较激烈时，偏向锁就会升级为轻量级锁，轻量级锁认为虽然竞争是存在的，但是理想情况下竞争的程度很低，通过自旋方式等待上一个线程释放锁。 重量级锁 如果线程并发进一步加剧，线程的自旋超过了一定次数，或者一个线程持有锁，一个线程在自旋，又来了第三个线程访问时（反正就是竞争继续加大了），轻量级锁就会膨胀为重量级锁，重量级锁会使除了此时拥有锁的线程以外的线程都阻塞。 升级到重量级锁其实就是互斥锁了，一个线程拿到锁，其余线程都会处于阻塞等待状态。 在 Java 中，synchronized 关键字内部实现原理就是锁升级的过程：无锁 –&gt; 偏向锁 –&gt; 轻量级锁 –&gt; 重量级锁。 锁优化技术（锁粗化、锁消除） 锁粗化 锁粗化就是将多个同步块的数量减少，并将单个同步块的作用范围扩大，本质上就是将多次上锁、解锁的请求合并为一次同步请求。 举个例子，一个循环体中有一个代码同步块，每次循环都会执行加锁解锁操作。 1234567private static final Object LOCK = new Object();for(int i = 0;i &lt; 100; i++) &#123; synchronized(LOCK)&#123; // do some magic things &#125;&#125; 经过锁粗化后就变成下面这个样子了： 12345 synchronized(LOCK)&#123; for(int i = 0;i &lt; 100; i++) &#123; // do some magic things &#125;&#125; 锁消除 锁消除是指虚拟机编译器在运行时检测到了共享数据没有竞争的锁，从而将这些锁进行消除。 举个例子让大家更好理解。 123456public String test(String s1, String s2)&#123; StringBuffer stringBuffer = new StringBuffer(); stringBuffer.append(s1); stringBuffer.append(s2); return stringBuffer.toString();&#125; 上面代码中有一个 test 方法，主要作用是将字符串 s1 和字符串 s2 串联起来。 test 方法中三个变量s1, s2, stringBuffer， 它们都是局部变量，局部变量是在栈上的，栈是线程私有的，所以就算有多个线程访问 test 方法也是线程安全的。 我们都知道 StringBuffer 是线程安全的类，append 方法是同步方法，但是 test 方法本来就是线程安全的，为了提升效率，虚拟机帮我们消除了这些同步锁，这个过程就被称为锁消除。 12345678StringBuffer.class// append 是同步方法public synchronized StringBuffer append(String str) &#123; toStringCache = null; super.append(str); return this;&#125; 一张图总结 前面讲了 Java 语言中各种各种的锁，最后再通过六个问题统一总结一下： -- End --","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java锁","slug":"java锁","permalink":"http://yoursite.com/tags/java%E9%94%81/"}]},{"title":"Java8 实现List转map 、分组、过滤","slug":"Java8-实现List转map-、分组、过滤","date":"2020-11-10T02:40:12.000Z","updated":"2020-11-10T03:05:40.824Z","comments":true,"path":"2020/11/10/Java8-实现List转map-、分组、过滤/","link":"","permalink":"http://yoursite.com/2020/11/10/Java8-%E5%AE%9E%E7%8E%B0List%E8%BD%ACmap-%E3%80%81%E5%88%86%E7%BB%84%E3%80%81%E8%BF%87%E6%BB%A4/","excerpt":"","text":"利用java8新特性，可以用简洁高效的代码来实现一些数据处理。 定义1个Apple对象： 123456789101112131415public class Apple &#123; private Integer id; private String name; private BigDecimal money; private Integer num; public Apple(Integer id, String name, BigDecimal money, Integer num) &#123; this.id = id; this.name = name; this.money = money; this.num = num; &#125; &#125; 添加一些测试数据： 1234567891011List&lt;Apple&gt; appleList = new ArrayList&lt;&gt;();//存放apple对象集合 Apple apple1 = new Apple(1,\"苹果1\",new BigDecimal(\"3.25\"),10);Apple apple12 = new Apple(1,\"苹果2\",new BigDecimal(\"1.35\"),20);Apple apple2 = new Apple(2,\"香蕉\",new BigDecimal(\"2.89\"),30);Apple apple3 = new Apple(3,\"荔枝\",new BigDecimal(\"9.99\"),40); appleList.add(apple1);appleList.add(apple12);appleList.add(apple2);appleList.add(apple3); 1.分组List里面的对象元素，以某个属性来分组，例如，以id分组，将id相同的放在一起： 12345//List 以ID分组 Map&lt;Integer,List&lt;Apple&gt;&gt;Map&lt;Integer, List&lt;Apple&gt;&gt; groupBy = appleList.stream().collect(Collectors.groupingBy(Apple::getId)); System.err.println(\"groupBy:\"+groupBy);&#123;1=[Apple&#123;id=1, name='苹果1', money=3.25, num=10&#125;, Apple&#123;id=1, name='苹果2', money=1.35, num=20&#125;], 2=[Apple&#123;id=2, name='香蕉', money=2.89, num=30&#125;], 3=[Apple&#123;id=3, name='荔枝', money=9.99, num=40&#125;]&#125; 2、List转Mapid为key，apple对象为value，可以这么做： 12345678/** * List -&gt; Map * 需要注意的是： * toMap 如果集合对象有重复的key，会报错Duplicate key .... * apple1,apple12的id都为1。 * 可以用 (k1,k2)-&gt;k1 来设置，如果有重复的key,则保留key1,舍弃key2 */Map&lt;Integer, Apple&gt; appleMap = appleList.stream().collect(Collectors.toMap(Apple::getId, a -&gt; a,(k1,k2)-&gt;k1)); 3、过滤Filter从集合中过滤出来符合条件的元素： 12345//过滤出符合条件的数据List&lt;Apple&gt; filterList = appleList.stream().filter(a -&gt; a.getName().equals(\"香蕉\")).collect(Collectors.toList()); System.err.println(\"filterList:\"+filterList);[Apple&#123;id=2, name='香蕉', money=2.89, num=30&#125;] 4、求和将集合中的数据按照某个属性求和: 123//计算 总金额BigDecimal totalMoney = appleList.stream().map(Apple::getMoney).reduce(BigDecimal.ZERO, BigDecimal::add);System.err.println(\"totalMoney:\"+totalMoney); //totalMoney:17.48 5、查找流中最大 最小值Collectors.maxBy 和 Collectors.minBy 来计算流中的最大或最小值: 12345Optional&lt;Dish&gt; maxDish = Dish.menu.stream().collect(Collectors.maxBy(Comparator.comparing(Dish::getCalories)));maxDish.ifPresent(System.out::println); Optional&lt;Dish&gt; minDish = Dish.menu.stream().collect(Collectors.minBy(Comparator.comparing(Dish::getCalories)));minDish.ifPresent(System.out::println); 6、去重123456789import static java.util.Comparator.comparingLong;import static java.util.stream.Collectors.collectingAndThen;import static java.util.stream.Collectors.toCollection; // 根据id去重 List&lt;Person&gt; unique = appleList.stream().collect( collectingAndThen( toCollection(() -&gt; new TreeSet&lt;&gt;(comparingLong(Apple::getId))), ArrayList::new) );","categories":[{"name":"Java8","slug":"Java8","permalink":"http://yoursite.com/categories/Java8/"}],"tags":[{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"}]},{"title":"Linux实用命令及杂项","slug":"Linux实用命令及杂项","date":"2020-06-09T13:49:57.000Z","updated":"2020-06-09T13:53:42.371Z","comments":true,"path":"2020/06/09/Linux实用命令及杂项/","link":"","permalink":"http://yoursite.com/2020/06/09/Linux%E5%AE%9E%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E6%9D%82%E9%A1%B9/","excerpt":"","text":"1.关机&amp;重启命令 shutdown shutdown -h now 表示立即关机 shutdown -h 1 表示一分钟后关机 shutdown -r now 表示立即重启 halt 停机 等价于关机 reboot 重启系统 sync 把内存的数据保存到磁盘上 一般在关机或重启时先执行的命令 2.用户注销 logout 注销当前用户登录 (在图形界面无效) 3.用户管理 useradd xiaoming 添加一个用户 xiaoming（用户创建成功后会自动的创建与用户名同名的家目录与用户组） useradd -d 指定目录 用户名 创建新的用户并指定家目录 passwd xiaoming 给用户xiaoming指定密码 userdel xiaoming 删除用户xiaoming但是保留家目录 userdel -r xiaoming 删除xiaoming并删除家目录 id xiaoming 查询xiaoming的用户详细信息 su - root 切换到root用户 exit 退出 返回到原来的用户 whoami 当前用户是谁 groupadd wudang 添加一个用户组wudang groupdel wudang 删除用户组wudang useradd -g wudang xiaoming 将用户xiaoming指定到用户组wudang中 usermod -g shaolin xiaoming 将用户xiaoming修改用户组到shaolin中 4.运行级别linux一共分为7种运行级别，配置在 /etc/inittab id:5:initdefault: 这一行的数字中: 运行级别0：系统关机状态，系统默认运行级别不能设为0，否则不能正常启动 运行级别1：单用户(找回丢失密码)，root权限，用于系统维护，禁止远程登陆 运行级别2：多用户状态(没有网络服务) 运行级别3：多用户状态(有网络服务)，登陆后进入控制台命令行模式 运行级别4：系统未使用，保留 运行级别5：X11控制台，登陆后进入图形GUI模式 （图形界面） 运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动 init 3 将运行级别调整到3 5.帮助指令 man ls 查看命令ls的帮助及使用方法 help ls 查看ls命令的帮助及使用方法 6.文件目录 pwd 显示当前目录的绝对路径 ls -a 显示当前目录所有的文件和目录包括隐藏的文件 ls -l 以列表的方式显示信息 cd ~ 或 cd : 回到当前用户的家目录 cd .. 回到上一级目录 mkdir /home/dog 在home目录下创建一个dog目录 mkdir -p /home/animal/tigger 在home目录下创建多级 /animal/tigger 目录 rmdir /home/dog 删除目录/home/dog 如果目录下有内容时无法删除 rm -rf /home/dog 删除目录/home/dog 有没有内容都直接删除 touch hello.txt 创建一个hello.txt的空文件 cp hello.txt bbb/ 复制当前路径下的hello.txt到bbb文件夹中 cp -r test/ zwj/ 递归将test目录拷贝到zwj目录下 再次拷贝可能会提示覆盖 通过cp前加\\强制覆盖 mv aaa.txt bbb.txt 将当前目录的aaa.txt重命名为bbb.txt mv aaa.txt /root 将aaa.txt移动到root目录下 cat -n /etc/profile 查看etc下profile文件的内容并显示行号 cat -n /etc/profile | more 查看ect目录下profile文件的内容分页显示并显示行号 less /etc/peofile 效率比more命令高按需加载文件内容而不是一次性全部加载 ls -l &gt; aaa.txt 将ls的输出内容覆盖写入到aaa.txt中,aaa.txt不存在则创建 ls -l &gt;&gt; aaa.txt 将ls的输出内容追加写入到aaa.txt中,aaa.txt不存在则创建 echo “想要写的内容” &gt; a.txt 把双引号里的内容覆盖添加到a.txt中 echo $PATH 输出PATH环境变量 echo “hello” 输出hello文本 head -n 5 a.txt 显示a.txt文件前五行的内容 tail -n 5 a.txt 显示a.txt文件后五行的内容 tail -f a.txt 实时监控a.txt的变化 经常用到查看日志","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"命令","slug":"命令","permalink":"http://yoursite.com/tags/%E5%91%BD%E4%BB%A4/"}]},{"title":"jdk1.8下的Date与LocalDateTime的互相转换及格式化时间","slug":"jdk1-8下的Date与LocalDateTime的互相转换及格式化时间","date":"2020-06-09T13:29:12.000Z","updated":"2020-06-09T13:36:06.173Z","comments":true,"path":"2020/06/09/jdk1-8下的Date与LocalDateTime的互相转换及格式化时间/","link":"","permalink":"http://yoursite.com/2020/06/09/jdk1-8%E4%B8%8B%E7%9A%84Date%E4%B8%8ELocalDateTime%E7%9A%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2%E5%8F%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%B6%E9%97%B4/","excerpt":"","text":"不跟你多bb，上代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * @Author :liangHuang. * @Date :2019/5/8 16:28 * @Description :时间工具类 */public class DateUtil &#123; private static final ConcurrentMap&lt;String, DateTimeFormatter&gt; FORMATTER_CACHE = new ConcurrentHashMap&lt;&gt;(); private static final int PATTERN_CACHE_SIZE = 500; public static final String LOCAL_DATE_TIME = \"yyyy-MM-dd HH:mm:ss\"; public static final String LOCAL_DATE = \"yyyy-MM-dd\"; public static final String LOCAL_TIME = \"HH:mm:ss\"; /** * Date转换为格式化时间 * @param date * @param pattern * @return */ public static String format(Date date, String pattern)&#123; return format(LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault()), pattern); &#125; /** * localDateTime转换为格式化时间 * @param localDateTime localDateTime * @param pattern 格式 * @return */ public static String format(LocalDateTime localDateTime, String pattern)&#123; DateTimeFormatter formatter = createCacheFormatter(pattern); return localDateTime.format(formatter); &#125; /** * 格式化字符串转为Date * @param time 格式化时间 * @param pattern 格式 * @return */ public static Date parseDate(String time, String pattern)&#123; return Date.from(parseLocalDateTime(time, pattern).atZone(ZoneId.systemDefault()).toInstant()); &#125; /** * 格式化字符串转为LocalDateTime * @param time 格式化时间 * @param pattern 格式 * @return */ public static LocalDateTime parseLocalDateTime(String time, String pattern)&#123; DateTimeFormatter formatter = createCacheFormatter(pattern); return LocalDateTime.parse(time, formatter); &#125; /** * 在缓存中创建DateTimeFormatter * @param pattern 格式 * @return */ private static DateTimeFormatter createCacheFormatter(String pattern)&#123; if (pattern == null || pattern.length() == 0) &#123; throw new IllegalArgumentException(\"Invalid pattern specification\"); &#125; DateTimeFormatter formatter = FORMATTER_CACHE.get(pattern); if(formatter == null)&#123; if(FORMATTER_CACHE.size() &lt; PATTERN_CACHE_SIZE)&#123; formatter = DateTimeFormatter.ofPattern(pattern); DateTimeFormatter oldFormatter = FORMATTER_CACHE.putIfAbsent(pattern, formatter); if(oldFormatter != null)&#123; formatter = oldFormatter; &#125; &#125; &#125; return formatter; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"util","slug":"util","permalink":"http://yoursite.com/tags/util/"}]},{"title":".JPEG .GIF .PNG 三种图片格式的区别","slug":"JPEG-GIF-PNG-三种图片格式的区别","date":"2020-06-09T11:33:18.000Z","updated":"2020-06-09T11:37:19.363Z","comments":true,"path":"2020/06/09/JPEG-GIF-PNG-三种图片格式的区别/","link":"","permalink":"http://yoursite.com/2020/06/09/JPEG-GIF-PNG-%E4%B8%89%E7%A7%8D%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"1.JPEG格式 JPEG（JPG）图片支持的颜色较多，图片可以压缩，但是不支持透明，一般使用JPEG来保存照片等颜色丰富的图片 2.GIF GIF支持的颜色较少，只支持简单的透明，支持动态图，图片颜色单一或者是动态图时可以使用GIF格式 3.PNG PNG格式支持的颜色较多，并且支持复杂的透明，可以用来显示颜色复杂的透明的图片，开发中比较常见 开发建议 ++效果不一致，使用效果好的++ ++效果一致，使用小的++","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"图片","slug":"图片","permalink":"http://yoursite.com/tags/%E5%9B%BE%E7%89%87/"}]},{"title":"cookie、session、token、jwt介绍","slug":"cookie、session、token、jwt介绍","date":"2020-06-09T02:56:03.000Z","updated":"2020-06-09T03:04:57.983Z","comments":true,"path":"2020/06/09/cookie、session、token、jwt介绍/","link":"","permalink":"http://yoursite.com/2020/06/09/cookie%E3%80%81session%E3%80%81token%E3%80%81jwt%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"cookie cookie的诞生由于HTTP协议是无状态的，而服务器端的业务必须是要有状态的。Cookie诞生的最初目的是为了存储web中的状态信息，以方便服务器端使用。比如判断用户是否是第一次访问网站。目前最新的规范是RFC 6265，它是一个由浏览器服务器共同协作实现的规范。Cookie的处理分为：服务器像客户端发送cookie浏览器将cookie保存之后每次http请求浏览器都会将cookie发送给服务器端 session 为什么要有session的出现？答：是由于网络中http协议造成的，因为http本身是无状态协议，这样，无法确定你的本次请求和上次请求是不是你发送的。如果要进行类似论坛登陆相关的操作，就实现不了了。 session生成方式？答：浏览器第一次访问服务器，服务器会创建一个session，然后同时为该session生成一个唯一的会话的key,也就是sessionid，然后，将sessionid及对应的session分别作为key和value保存到缓存中，也可以持久化到数据库中，然后服务器再把sessionid，以cookie的形式发送给客户端。这样浏览器下次再访问时，会直接带着cookie中的sessionid。然后服务器根据sessionid找到对应的session进行匹配；还有一种是浏览器禁用了cookie或不支持cookie，这种可以通过URL重写的方式发到服务器； token 访问资源的令牌验证流程：1.把用户的用户名和密码发到后端2.后端进行校验，校验成功会生成token, 把token发送给客户端3.客户端自己保存token, 再次请求就要在Http协议的请求头中带着token去访问服务端，和在服务端保存的token信息进行比对校验。 JWT java web token 的缩写，可使用restful接口定义，也可以用在web中段落引用组成：header在header中声明一些信息payload、 签证验证流程：1.段落引用在头部信息中声明加密算法和常量， 然后把header使用json转化为字符串2.段落引用在载荷中声明用户信息，同时还有一些其他的内容；再次使用json 把载荷部分进行转化，转化为字符串3.使用在header中声明的加密算法和每个项目随机生成的secret来进行加密， 把第一步分字符串和第二部分的字符串进行加密， 生成新的字符串。词字符串是独一无二的。4.解密的时候，只要客户端带着JWT来发起请求，服务端就直接使用secret进行解密。 特点：1.三部分组成，每一部分都进行字符串的转化2.解密的时候没有使用数据库，仅仅使用的是secret进行解密。3.JWT的secret不能泄密","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"login","slug":"login","permalink":"http://yoursite.com/tags/login/"}]},{"title":"Hexo免输入密码部署到github","slug":"Hexo免输入密码部署到github","date":"2020-06-07T10:52:19.000Z","updated":"2021-07-22T01:38:07.693Z","comments":true,"path":"2020/06/07/Hexo免输入密码部署到github/","link":"","permalink":"http://yoursite.com/2020/06/07/Hexo%E5%85%8D%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81%E9%83%A8%E7%BD%B2%E5%88%B0github/","excerpt":"","text":"hexo 使用hexo d命令部署到github时，会要求你输入用户名密码，每次提交都要输入，为了方便添加如下配置： 在系统变量中添加一个环境变量： 12变量名：HOME变量值：%USERPROFILE% 接着在你的用户目录（C:\\Users\\username）下新建一个叫 _netrc的文件编辑这个文件： 123machine github.comlogin usernamepassword password 设置好这些后，当你再次部署时，就不用输入用户名和密码了。","categories":[{"name":"博客","slug":"博客","permalink":"http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"使用jdk实现动态代理","slug":"使用jdk实现动态代理","date":"2020-06-07T05:21:02.000Z","updated":"2020-06-07T07:27:25.047Z","comments":true,"path":"2020/06/07/使用jdk实现动态代理/","link":"","permalink":"http://yoursite.com/2020/06/07/%E4%BD%BF%E7%94%A8jdk%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","excerpt":"","text":"java的代理就是客户类不再直接与委托类直接打打交道，而是通过一个中间层进行访问，这个中间层就是代理，优势: 1.隐藏委托类 2.代码解耦 代理主要分为静态代理、jdk动态代理、和CGLIB 动态代理，各有优缺点，没有最好的，存在即合理。 1 计算器接口需求例如我们有一个实现计算器的接口: 1234567891011121314151617181920212223242526272829public interface Calculator &#123; /** * 两个数相加 * @param a * @param b * @return */ int sub(int a, int b); /** * 两个数相减 * @param a * @param b * @return */ int less(int a, int b); /** * 两个数相乘 * @param a * @param b * @return */ int Multiply(int a, int b); /** * 两个数相除 * @param a * @param b * @return */ int except(int a, int b); 以及接口实现类，并且在每次预算前与运算后返回入参及结果打印: 123456789101112131415161718192021222324252627282930313233public class CalculatorImpl implements Calculator &#123; @Override public int sub(int a, int b) &#123; System.out.println(\"sub计算开始，参数为[\" + a + \",\"+ b +\"]。\"); int result = a + b; System.out.println(\"sub计算结束，结果为[\" + result +\"]。\"); return result; &#125; @Override public int less(int a, int b) &#123; System.out.println(\"less计算开始，参数为[\" + a + \",\"+ b +\"]。\"); int result = a - b; System.out.println(\"less计算结束，结果为[\" + result +\"]。\"); return result; &#125; @Override public int multiply(int a, int b) &#123; System.out.println(\"multiply计算开始，参数为[\" + a + \",\"+ b +\"]。\"); int result = a * b; System.out.println(\"multiply计算结束，结果为[\" + result +\"]。\"); return result; &#125; @Override public int except(int a, int b) &#123; System.out.println(\"except计算开始，参数为[\" + a + \",\"+ b +\"]。\"); int result = a / b; System.out.println(\"except计算结束，结果为[\" + result +\"]。\"); return result; &#125;&#125; 测试 1234567891011public class Test &#123; public static void main(String[] args) &#123; Calculator calculator = new CalculatorImpl(); int sub = calculator.sub(1, 2); System.out.println(\"---&gt;\" + sub); int less = calculator.less(6, 2); System.out.println(\"---&gt;\" + less); &#125;&#125; 打印结果为： sub计算开始，参数为[1,2]。sub计算结束，结果为[3]。—&gt;3less计算开始，参数为[6,2]。less计算结束，结果为[4]。—&gt;4 虽然实现了需求但是以上代码（虽然简单）暴露了很多问题： 1.代码混乱：越来越多的非业务需求（日志与验证等）加入后，原本简单的业务代码急剧膨胀，每个方法在处理核心逻辑的同时还需要关注多个点 2.代码分散：以日志需求为例，只是为了满足这个单一需求（加减乘除），就不得不在多个模块（方法）上多次重复相同的日志代码，如果日志代码修改，需要修改所有模块 2 使用jdk动态代理实现无入侵日志打印删除计算器实中的日志记录代码并创建动态代理类 CalculatorloggingProxy 1234567891011121314151617181920212223242526272829303132333435363738public class CalculatorloggingProxy &#123; //想要代理的对象 private Calculator target; public CalculatorloggingProxy(Calculator target) &#123; this.target = target; &#125; public Calculator getLoggingProxy()&#123; Calculator proxy = null; //代理对象由哪一个类加载器度负责加载 ClassLoader loader = target.getClass().getClassLoader(); //代理对象的类型，有哪些方法 Class[] interfaces = new Class[] &#123;Calculator.class&#125;; //当调用代理对象的方法时，执行该代码 InvocationHandler invocationHandler = new InvocationHandler() &#123; /** * @param proxy 正在返回的代理对象，一般情况下在 invoke方法中都不使用该对象 * @param method 正在被调用的方法 * @param args 方法的参数 * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String methodName = method.getName(); System.out.println(\"计算器[\"+ methodName + \"]方法开始执行,参数为\" + Arrays.asList(args)); //执行方法 Object result = method.invoke(target, args); System.out.println(\"方法[\"+ methodName + \"]计算完毕,结果为\" + result); return result; &#125; &#125;; proxy = (Calculator)Proxy.newProxyInstance(loader, interfaces, invocationHandler); return proxy; &#125;&#125; 测试test更改为 123456789101112131415161718public class Test &#123; public static void main(String[] args) &#123; Calculator calculator = new CalculatorImpl(); CalculatorloggingProxy calculatorloggingProxy = new CalculatorloggingProxy(calculator); //获取计算器代理对象 Calculator loggingProxy = calculatorloggingProxy.getLoggingProxy(); //调用加法 loggingProxy.sub(1, 2); //调用减法 loggingProxy.less(6, 2); //乘法 loggingProxy.multiply(4, 4); //除法 loggingProxy.except(18,2); &#125;&#125; 执行测试，结果为： 计算器[sub]方法开始执行,参数为[1, 2]方法[sub]计算完毕,结果为3计算器[less]方法开始执行,参数为[6, 2]方法[less]计算完毕,结果为4计算器[multiply]方法开始执行,参数为[4, 4]方法[multiply]计算完毕,结果为16计算器[except]方法开始执行,参数为[18, 2]方法[except]计算完毕,结果为9 至此我们完成了动态代理，实现需求。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"},{"name":"动态代理","slug":"动态代理","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"}]}],"categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"},{"name":"NoSql数据库","slug":"Redis/NoSql数据库","permalink":"http://yoursite.com/categories/Redis/NoSql%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"sql语句","slug":"sql语句","permalink":"http://yoursite.com/categories/sql%E8%AF%AD%E5%8F%A5/"},{"name":"数据库","slug":"sql语句/数据库","permalink":"http://yoursite.com/categories/sql%E8%AF%AD%E5%8F%A5/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"spring","slug":"spring","permalink":"http://yoursite.com/categories/spring/"},{"name":"springboot","slug":"spring/springboot","permalink":"http://yoursite.com/categories/spring/springboot/"},{"name":"java","slug":"spring/springboot/java","permalink":"http://yoursite.com/categories/spring/springboot/java/"},{"name":"Java8","slug":"Java8","permalink":"http://yoursite.com/categories/Java8/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"},{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"},{"name":"代码规范","slug":"代码规范","permalink":"http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"安装","slug":"安装","permalink":"http://yoursite.com/tags/%E5%AE%89%E8%A3%85/"},{"name":"查询重复记录","slug":"查询重复记录","permalink":"http://yoursite.com/tags/%E6%9F%A5%E8%AF%A2%E9%87%8D%E5%A4%8D%E8%AE%B0%E5%BD%95/"},{"name":"工厂模式","slug":"工厂模式","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"name":"注解","slug":"注解","permalink":"http://yoursite.com/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"自动装配","slug":"自动装配","permalink":"http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"},{"name":"java锁","slug":"java锁","permalink":"http://yoursite.com/tags/java%E9%94%81/"},{"name":"命令","slug":"命令","permalink":"http://yoursite.com/tags/%E5%91%BD%E4%BB%A4/"},{"name":"util","slug":"util","permalink":"http://yoursite.com/tags/util/"},{"name":"图片","slug":"图片","permalink":"http://yoursite.com/tags/%E5%9B%BE%E7%89%87/"},{"name":"login","slug":"login","permalink":"http://yoursite.com/tags/login/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"动态代理","slug":"动态代理","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"}]}