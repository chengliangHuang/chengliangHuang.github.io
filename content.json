{"meta":{"title":"QWHS","subtitle":"纸上得来终觉浅","description":"CV工程师，面向搜索引擎编程","author":"宁中老程","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2020-06-07T07:19:53.000Z","updated":"2020-06-07T07:22:18.159Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-06-07T04:44:54.000Z","updated":"2020-06-07T05:08:53.141Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java8 实现List转map 、分组、过滤","slug":"Java8-实现List转map-、分组、过滤","date":"2020-11-10T02:40:12.000Z","updated":"2020-11-10T03:05:40.824Z","comments":true,"path":"2020/11/10/Java8-实现List转map-、分组、过滤/","link":"","permalink":"http://yoursite.com/2020/11/10/Java8-%E5%AE%9E%E7%8E%B0List%E8%BD%ACmap-%E3%80%81%E5%88%86%E7%BB%84%E3%80%81%E8%BF%87%E6%BB%A4/","excerpt":"","text":"利用java8新特性，可以用简洁高效的代码来实现一些数据处理。 定义1个Apple对象： 123456789101112131415public class Apple &#123; private Integer id; private String name; private BigDecimal money; private Integer num; public Apple(Integer id, String name, BigDecimal money, Integer num) &#123; this.id = id; this.name = name; this.money = money; this.num = num; &#125; &#125; 添加一些测试数据： 1234567891011List&lt;Apple&gt; appleList = new ArrayList&lt;&gt;();//存放apple对象集合 Apple apple1 = new Apple(1,\"苹果1\",new BigDecimal(\"3.25\"),10);Apple apple12 = new Apple(1,\"苹果2\",new BigDecimal(\"1.35\"),20);Apple apple2 = new Apple(2,\"香蕉\",new BigDecimal(\"2.89\"),30);Apple apple3 = new Apple(3,\"荔枝\",new BigDecimal(\"9.99\"),40); appleList.add(apple1);appleList.add(apple12);appleList.add(apple2);appleList.add(apple3); 1.分组List里面的对象元素，以某个属性来分组，例如，以id分组，将id相同的放在一起： 12345//List 以ID分组 Map&lt;Integer,List&lt;Apple&gt;&gt;Map&lt;Integer, List&lt;Apple&gt;&gt; groupBy = appleList.stream().collect(Collectors.groupingBy(Apple::getId)); System.err.println(\"groupBy:\"+groupBy);&#123;1=[Apple&#123;id=1, name='苹果1', money=3.25, num=10&#125;, Apple&#123;id=1, name='苹果2', money=1.35, num=20&#125;], 2=[Apple&#123;id=2, name='香蕉', money=2.89, num=30&#125;], 3=[Apple&#123;id=3, name='荔枝', money=9.99, num=40&#125;]&#125; 2、List转Mapid为key，apple对象为value，可以这么做： 12345678/** * List -&gt; Map * 需要注意的是： * toMap 如果集合对象有重复的key，会报错Duplicate key .... * apple1,apple12的id都为1。 * 可以用 (k1,k2)-&gt;k1 来设置，如果有重复的key,则保留key1,舍弃key2 */Map&lt;Integer, Apple&gt; appleMap = appleList.stream().collect(Collectors.toMap(Apple::getId, a -&gt; a,(k1,k2)-&gt;k1)); 3、过滤Filter从集合中过滤出来符合条件的元素： 12345//过滤出符合条件的数据List&lt;Apple&gt; filterList = appleList.stream().filter(a -&gt; a.getName().equals(\"香蕉\")).collect(Collectors.toList()); System.err.println(\"filterList:\"+filterList);[Apple&#123;id=2, name='香蕉', money=2.89, num=30&#125;] 4、求和将集合中的数据按照某个属性求和: 123//计算 总金额BigDecimal totalMoney = appleList.stream().map(Apple::getMoney).reduce(BigDecimal.ZERO, BigDecimal::add);System.err.println(\"totalMoney:\"+totalMoney); //totalMoney:17.48 5、查找流中最大 最小值Collectors.maxBy 和 Collectors.minBy 来计算流中的最大或最小值: 12345Optional&lt;Dish&gt; maxDish = Dish.menu.stream().collect(Collectors.maxBy(Comparator.comparing(Dish::getCalories)));maxDish.ifPresent(System.out::println); Optional&lt;Dish&gt; minDish = Dish.menu.stream().collect(Collectors.minBy(Comparator.comparing(Dish::getCalories)));minDish.ifPresent(System.out::println); 6、去重123456789import static java.util.Comparator.comparingLong;import static java.util.stream.Collectors.collectingAndThen;import static java.util.stream.Collectors.toCollection; // 根据id去重 List&lt;Person&gt; unique = appleList.stream().collect( collectingAndThen( toCollection(() -&gt; new TreeSet&lt;&gt;(comparingLong(Apple::getId))), ArrayList::new) );","categories":[{"name":"Java8","slug":"Java8","permalink":"http://yoursite.com/categories/Java8/"}],"tags":[{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"}]},{"title":"Linux实用命令及杂项","slug":"Linux实用命令及杂项","date":"2020-06-09T13:49:57.000Z","updated":"2020-06-09T13:53:42.371Z","comments":true,"path":"2020/06/09/Linux实用命令及杂项/","link":"","permalink":"http://yoursite.com/2020/06/09/Linux%E5%AE%9E%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E6%9D%82%E9%A1%B9/","excerpt":"","text":"1.关机&amp;重启命令 shutdown shutdown -h now 表示立即关机 shutdown -h 1 表示一分钟后关机 shutdown -r now 表示立即重启 halt 停机 等价于关机 reboot 重启系统 sync 把内存的数据保存到磁盘上 一般在关机或重启时先执行的命令 2.用户注销 logout 注销当前用户登录 (在图形界面无效) 3.用户管理 useradd xiaoming 添加一个用户 xiaoming（用户创建成功后会自动的创建与用户名同名的家目录与用户组） useradd -d 指定目录 用户名 创建新的用户并指定家目录 passwd xiaoming 给用户xiaoming指定密码 userdel xiaoming 删除用户xiaoming但是保留家目录 userdel -r xiaoming 删除xiaoming并删除家目录 id xiaoming 查询xiaoming的用户详细信息 su - root 切换到root用户 exit 退出 返回到原来的用户 whoami 当前用户是谁 groupadd wudang 添加一个用户组wudang groupdel wudang 删除用户组wudang useradd -g wudang xiaoming 将用户xiaoming指定到用户组wudang中 usermod -g shaolin xiaoming 将用户xiaoming修改用户组到shaolin中 4.运行级别linux一共分为7种运行级别，配置在 /etc/inittab id:5:initdefault: 这一行的数字中: 运行级别0：系统关机状态，系统默认运行级别不能设为0，否则不能正常启动 运行级别1：单用户(找回丢失密码)，root权限，用于系统维护，禁止远程登陆 运行级别2：多用户状态(没有网络服务) 运行级别3：多用户状态(有网络服务)，登陆后进入控制台命令行模式 运行级别4：系统未使用，保留 运行级别5：X11控制台，登陆后进入图形GUI模式 （图形界面） 运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动 init 3 将运行级别调整到3 5.帮助指令 man ls 查看命令ls的帮助及使用方法 help ls 查看ls命令的帮助及使用方法 6.文件目录 pwd 显示当前目录的绝对路径 ls -a 显示当前目录所有的文件和目录包括隐藏的文件 ls -l 以列表的方式显示信息 cd ~ 或 cd : 回到当前用户的家目录 cd .. 回到上一级目录 mkdir /home/dog 在home目录下创建一个dog目录 mkdir -p /home/animal/tigger 在home目录下创建多级 /animal/tigger 目录 rmdir /home/dog 删除目录/home/dog 如果目录下有内容时无法删除 rm -rf /home/dog 删除目录/home/dog 有没有内容都直接删除 touch hello.txt 创建一个hello.txt的空文件 cp hello.txt bbb/ 复制当前路径下的hello.txt到bbb文件夹中 cp -r test/ zwj/ 递归将test目录拷贝到zwj目录下 再次拷贝可能会提示覆盖 通过cp前加\\强制覆盖 mv aaa.txt bbb.txt 将当前目录的aaa.txt重命名为bbb.txt mv aaa.txt /root 将aaa.txt移动到root目录下 cat -n /etc/profile 查看etc下profile文件的内容并显示行号 cat -n /etc/profile | more 查看ect目录下profile文件的内容分页显示并显示行号 less /etc/peofile 效率比more命令高按需加载文件内容而不是一次性全部加载 ls -l &gt; aaa.txt 将ls的输出内容覆盖写入到aaa.txt中,aaa.txt不存在则创建 ls -l &gt;&gt; aaa.txt 将ls的输出内容追加写入到aaa.txt中,aaa.txt不存在则创建 echo “想要写的内容” &gt; a.txt 把双引号里的内容覆盖添加到a.txt中 echo $PATH 输出PATH环境变量 echo “hello” 输出hello文本 head -n 5 a.txt 显示a.txt文件前五行的内容 tail -n 5 a.txt 显示a.txt文件后五行的内容 tail -f a.txt 实时监控a.txt的变化 经常用到查看日志","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"命令","slug":"命令","permalink":"http://yoursite.com/tags/%E5%91%BD%E4%BB%A4/"}]},{"title":"jdk1.8下的Date与LocalDateTime的互相转换及格式化时间","slug":"jdk1-8下的Date与LocalDateTime的互相转换及格式化时间","date":"2020-06-09T13:29:12.000Z","updated":"2020-06-09T13:36:06.173Z","comments":true,"path":"2020/06/09/jdk1-8下的Date与LocalDateTime的互相转换及格式化时间/","link":"","permalink":"http://yoursite.com/2020/06/09/jdk1-8%E4%B8%8B%E7%9A%84Date%E4%B8%8ELocalDateTime%E7%9A%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2%E5%8F%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%B6%E9%97%B4/","excerpt":"","text":"不跟你多bb，上代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * @Author :liangHuang. * @Date :2019/5/8 16:28 * @Description :时间工具类 */public class DateUtil &#123; private static final ConcurrentMap&lt;String, DateTimeFormatter&gt; FORMATTER_CACHE = new ConcurrentHashMap&lt;&gt;(); private static final int PATTERN_CACHE_SIZE = 500; public static final String LOCAL_DATE_TIME = \"yyyy-MM-dd HH:mm:ss\"; public static final String LOCAL_DATE = \"yyyy-MM-dd\"; public static final String LOCAL_TIME = \"HH:mm:ss\"; /** * Date转换为格式化时间 * @param date * @param pattern * @return */ public static String format(Date date, String pattern)&#123; return format(LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault()), pattern); &#125; /** * localDateTime转换为格式化时间 * @param localDateTime localDateTime * @param pattern 格式 * @return */ public static String format(LocalDateTime localDateTime, String pattern)&#123; DateTimeFormatter formatter = createCacheFormatter(pattern); return localDateTime.format(formatter); &#125; /** * 格式化字符串转为Date * @param time 格式化时间 * @param pattern 格式 * @return */ public static Date parseDate(String time, String pattern)&#123; return Date.from(parseLocalDateTime(time, pattern).atZone(ZoneId.systemDefault()).toInstant()); &#125; /** * 格式化字符串转为LocalDateTime * @param time 格式化时间 * @param pattern 格式 * @return */ public static LocalDateTime parseLocalDateTime(String time, String pattern)&#123; DateTimeFormatter formatter = createCacheFormatter(pattern); return LocalDateTime.parse(time, formatter); &#125; /** * 在缓存中创建DateTimeFormatter * @param pattern 格式 * @return */ private static DateTimeFormatter createCacheFormatter(String pattern)&#123; if (pattern == null || pattern.length() == 0) &#123; throw new IllegalArgumentException(\"Invalid pattern specification\"); &#125; DateTimeFormatter formatter = FORMATTER_CACHE.get(pattern); if(formatter == null)&#123; if(FORMATTER_CACHE.size() &lt; PATTERN_CACHE_SIZE)&#123; formatter = DateTimeFormatter.ofPattern(pattern); DateTimeFormatter oldFormatter = FORMATTER_CACHE.putIfAbsent(pattern, formatter); if(oldFormatter != null)&#123; formatter = oldFormatter; &#125; &#125; &#125; return formatter; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"util","slug":"util","permalink":"http://yoursite.com/tags/util/"}]},{"title":".JPEG .GIF .PNG 三种图片格式的区别","slug":"JPEG-GIF-PNG-三种图片格式的区别","date":"2020-06-09T11:33:18.000Z","updated":"2020-06-09T11:37:19.363Z","comments":true,"path":"2020/06/09/JPEG-GIF-PNG-三种图片格式的区别/","link":"","permalink":"http://yoursite.com/2020/06/09/JPEG-GIF-PNG-%E4%B8%89%E7%A7%8D%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"1.JPEG格式 JPEG（JPG）图片支持的颜色较多，图片可以压缩，但是不支持透明，一般使用JPEG来保存照片等颜色丰富的图片 2.GIF GIF支持的颜色较少，只支持简单的透明，支持动态图，图片颜色单一或者是动态图时可以使用GIF格式 3.PNG PNG格式支持的颜色较多，并且支持复杂的透明，可以用来显示颜色复杂的透明的图片，开发中比较常见 开发建议 ++效果不一致，使用效果好的++ ++效果一致，使用小的++","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"图片","slug":"图片","permalink":"http://yoursite.com/tags/%E5%9B%BE%E7%89%87/"}]},{"title":"cookie、session、token、jwt介绍","slug":"cookie、session、token、jwt介绍","date":"2020-06-09T02:56:03.000Z","updated":"2020-06-09T03:04:57.983Z","comments":true,"path":"2020/06/09/cookie、session、token、jwt介绍/","link":"","permalink":"http://yoursite.com/2020/06/09/cookie%E3%80%81session%E3%80%81token%E3%80%81jwt%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"cookie cookie的诞生由于HTTP协议是无状态的，而服务器端的业务必须是要有状态的。Cookie诞生的最初目的是为了存储web中的状态信息，以方便服务器端使用。比如判断用户是否是第一次访问网站。目前最新的规范是RFC 6265，它是一个由浏览器服务器共同协作实现的规范。Cookie的处理分为：服务器像客户端发送cookie浏览器将cookie保存之后每次http请求浏览器都会将cookie发送给服务器端 session 为什么要有session的出现？答：是由于网络中http协议造成的，因为http本身是无状态协议，这样，无法确定你的本次请求和上次请求是不是你发送的。如果要进行类似论坛登陆相关的操作，就实现不了了。 session生成方式？答：浏览器第一次访问服务器，服务器会创建一个session，然后同时为该session生成一个唯一的会话的key,也就是sessionid，然后，将sessionid及对应的session分别作为key和value保存到缓存中，也可以持久化到数据库中，然后服务器再把sessionid，以cookie的形式发送给客户端。这样浏览器下次再访问时，会直接带着cookie中的sessionid。然后服务器根据sessionid找到对应的session进行匹配；还有一种是浏览器禁用了cookie或不支持cookie，这种可以通过URL重写的方式发到服务器； token 访问资源的令牌验证流程：1.把用户的用户名和密码发到后端2.后端进行校验，校验成功会生成token, 把token发送给客户端3.客户端自己保存token, 再次请求就要在Http协议的请求头中带着token去访问服务端，和在服务端保存的token信息进行比对校验。 JWT java web token 的缩写，可使用restful接口定义，也可以用在web中段落引用组成：header在header中声明一些信息payload、 签证验证流程：1.段落引用在头部信息中声明加密算法和常量， 然后把header使用json转化为字符串2.段落引用在载荷中声明用户信息，同时还有一些其他的内容；再次使用json 把载荷部分进行转化，转化为字符串3.使用在header中声明的加密算法和每个项目随机生成的secret来进行加密， 把第一步分字符串和第二部分的字符串进行加密， 生成新的字符串。词字符串是独一无二的。4.解密的时候，只要客户端带着JWT来发起请求，服务端就直接使用secret进行解密。 特点：1.三部分组成，每一部分都进行字符串的转化2.解密的时候没有使用数据库，仅仅使用的是secret进行解密。3.JWT的secret不能泄密","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"login","slug":"login","permalink":"http://yoursite.com/tags/login/"}]},{"title":"Hexo免输入密码部署到github","slug":"Hexo免输入密码部署到github","date":"2020-06-07T10:52:19.000Z","updated":"2020-06-07T11:32:39.545Z","comments":true,"path":"2020/06/07/Hexo免输入密码部署到github/","link":"","permalink":"http://yoursite.com/2020/06/07/Hexo%E5%85%8D%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81%E9%83%A8%E7%BD%B2%E5%88%B0github/","excerpt":"","text":"hexo 使用hexo d命令部署到github时，会要求你输入用户名密码，每次提交都要输入，为了方便添加如下配置： 在系统变量中添加一个环境变量： 12变量名：HOME变量值：%USERPROFILE% 接着在你的用户目录（C:\\Users\\username）下新建一个叫 _netrc的文件编辑这个文件： 123machine github.comlogin usernamepassword password 设置好这些后，当你再次部署时，就不用输入用户名和密码了。","categories":[{"name":"博客","slug":"博客","permalink":"http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"}]},{"title":"使用jdk实现动态代理","slug":"使用jdk实现动态代理","date":"2020-06-07T05:21:02.000Z","updated":"2020-06-07T07:27:25.047Z","comments":true,"path":"2020/06/07/使用jdk实现动态代理/","link":"","permalink":"http://yoursite.com/2020/06/07/%E4%BD%BF%E7%94%A8jdk%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","excerpt":"","text":"java的代理就是客户类不再直接与委托类直接打打交道，而是通过一个中间层进行访问，这个中间层就是代理，优势: 1.隐藏委托类 2.代码解耦 代理主要分为静态代理、jdk动态代理、和CGLIB 动态代理，各有优缺点，没有最好的，存在即合理。 1 计算器接口需求例如我们有一个实现计算器的接口: 1234567891011121314151617181920212223242526272829public interface Calculator &#123; /** * 两个数相加 * @param a * @param b * @return */ int sub(int a, int b); /** * 两个数相减 * @param a * @param b * @return */ int less(int a, int b); /** * 两个数相乘 * @param a * @param b * @return */ int Multiply(int a, int b); /** * 两个数相除 * @param a * @param b * @return */ int except(int a, int b); 以及接口实现类，并且在每次预算前与运算后返回入参及结果打印: 123456789101112131415161718192021222324252627282930313233public class CalculatorImpl implements Calculator &#123; @Override public int sub(int a, int b) &#123; System.out.println(\"sub计算开始，参数为[\" + a + \",\"+ b +\"]。\"); int result = a + b; System.out.println(\"sub计算结束，结果为[\" + result +\"]。\"); return result; &#125; @Override public int less(int a, int b) &#123; System.out.println(\"less计算开始，参数为[\" + a + \",\"+ b +\"]。\"); int result = a - b; System.out.println(\"less计算结束，结果为[\" + result +\"]。\"); return result; &#125; @Override public int multiply(int a, int b) &#123; System.out.println(\"multiply计算开始，参数为[\" + a + \",\"+ b +\"]。\"); int result = a * b; System.out.println(\"multiply计算结束，结果为[\" + result +\"]。\"); return result; &#125; @Override public int except(int a, int b) &#123; System.out.println(\"except计算开始，参数为[\" + a + \",\"+ b +\"]。\"); int result = a / b; System.out.println(\"except计算结束，结果为[\" + result +\"]。\"); return result; &#125;&#125; 测试 1234567891011public class Test &#123; public static void main(String[] args) &#123; Calculator calculator = new CalculatorImpl(); int sub = calculator.sub(1, 2); System.out.println(\"---&gt;\" + sub); int less = calculator.less(6, 2); System.out.println(\"---&gt;\" + less); &#125;&#125; 打印结果为： sub计算开始，参数为[1,2]。sub计算结束，结果为[3]。—&gt;3less计算开始，参数为[6,2]。less计算结束，结果为[4]。—&gt;4 虽然实现了需求但是以上代码（虽然简单）暴露了很多问题： 1.代码混乱：越来越多的非业务需求（日志与验证等）加入后，原本简单的业务代码急剧膨胀，每个方法在处理核心逻辑的同时还需要关注多个点 2.代码分散：以日志需求为例，只是为了满足这个单一需求（加减乘除），就不得不在多个模块（方法）上多次重复相同的日志代码，如果日志代码修改，需要修改所有模块 2 使用jdk动态代理实现无入侵日志打印删除计算器实中的日志记录代码并创建动态代理类 CalculatorloggingProxy 1234567891011121314151617181920212223242526272829303132333435363738public class CalculatorloggingProxy &#123; //想要代理的对象 private Calculator target; public CalculatorloggingProxy(Calculator target) &#123; this.target = target; &#125; public Calculator getLoggingProxy()&#123; Calculator proxy = null; //代理对象由哪一个类加载器度负责加载 ClassLoader loader = target.getClass().getClassLoader(); //代理对象的类型，有哪些方法 Class[] interfaces = new Class[] &#123;Calculator.class&#125;; //当调用代理对象的方法时，执行该代码 InvocationHandler invocationHandler = new InvocationHandler() &#123; /** * @param proxy 正在返回的代理对象，一般情况下在 invoke方法中都不使用该对象 * @param method 正在被调用的方法 * @param args 方法的参数 * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String methodName = method.getName(); System.out.println(\"计算器[\"+ methodName + \"]方法开始执行,参数为\" + Arrays.asList(args)); //执行方法 Object result = method.invoke(target, args); System.out.println(\"方法[\"+ methodName + \"]计算完毕,结果为\" + result); return result; &#125; &#125;; proxy = (Calculator)Proxy.newProxyInstance(loader, interfaces, invocationHandler); return proxy; &#125;&#125; 测试test更改为 123456789101112131415161718public class Test &#123; public static void main(String[] args) &#123; Calculator calculator = new CalculatorImpl(); CalculatorloggingProxy calculatorloggingProxy = new CalculatorloggingProxy(calculator); //获取计算器代理对象 Calculator loggingProxy = calculatorloggingProxy.getLoggingProxy(); //调用加法 loggingProxy.sub(1, 2); //调用减法 loggingProxy.less(6, 2); //乘法 loggingProxy.multiply(4, 4); //除法 loggingProxy.except(18,2); &#125;&#125; 执行测试，结果为： 计算器[sub]方法开始执行,参数为[1, 2]方法[sub]计算完毕,结果为3计算器[less]方法开始执行,参数为[6, 2]方法[less]计算完毕,结果为4计算器[multiply]方法开始执行,参数为[4, 4]方法[multiply]计算完毕,结果为16计算器[except]方法开始执行,参数为[18, 2]方法[except]计算完毕,结果为9 至此我们完成了动态代理，实现需求。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"},{"name":"动态代理","slug":"动态代理","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"}]}],"categories":[{"name":"Java8","slug":"Java8","permalink":"http://yoursite.com/categories/Java8/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"},{"name":"命令","slug":"命令","permalink":"http://yoursite.com/tags/%E5%91%BD%E4%BB%A4/"},{"name":"util","slug":"util","permalink":"http://yoursite.com/tags/util/"},{"name":"图片","slug":"图片","permalink":"http://yoursite.com/tags/%E5%9B%BE%E7%89%87/"},{"name":"login","slug":"login","permalink":"http://yoursite.com/tags/login/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"动态代理","slug":"动态代理","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"}]}