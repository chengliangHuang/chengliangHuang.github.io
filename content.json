{"meta":{"title":"QWHS","subtitle":"纸上得来终觉浅","description":"CV工程师，面向搜索引擎编程","author":"宁中老程","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2020-06-07T07:19:53.000Z","updated":"2020-06-07T07:22:18.159Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-06-07T04:44:54.000Z","updated":"2020-06-07T05:08:53.141Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"springboot在Windows服务器部署做成服务","slug":"springboot在Windows服务器部署做成服务","date":"2023-07-19T03:40:38.000Z","updated":"2023-07-19T03:47:57.439Z","comments":true,"path":"2023/07/19/springboot在Windows服务器部署做成服务/","link":"","permalink":"http://yoursite.com/2023/07/19/springboot%E5%9C%A8Windows%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E5%81%9A%E6%88%90%E6%9C%8D%E5%8A%A1/","excerpt":"","text":"springboot项目可以直接在cmd中使用java -jar这种方法可以快速启动但有个问题就是关掉cmd窗口程序就会停止，因此本系统采用了将后台做成windows服务的方式启动。 这里用到了winsw插件，winsw是一个开源项目，程序以及源码可以在Git Hub下载：https://github.com/kohsuke/winsw/releases winsw是一个可以将任何应用程序注册成服务的软件，使用方法如下： 1、 将Git Hub中下载的WinSW.NET4.exe和sample-minimal.xml文件及项目的jar包放在同一个文件夹中。 2、需要将winsw执行程序跟xml改成同样的名字，推荐使用项目名+Service的命名方式，比如：WinSW.NET4.exe改成xxxService.exe，sample-minmal.xml改成xxxService.xml。 3、编辑myProjectService.xml文件，内容如下 （注：此处注意，如果用的是文本编辑器修改，务必将编码格式换成Unicode编码） 4、 启动，打开系统服务功能：运行—输入cmd，然后进入到xxxService.exe所在文件夹，然后执行命令安装服务命令：xxxService.exe install 5、 命令提示符界面输入命令”net start xxxService”(服务名)启动服务。 6、在服务中可找到此服务 启动服务命令： myProjectService.exe install net start myProjectServiceName 关闭服务命令： net stop myProjectServiceName myProjectService.exe uninstall","categories":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/categories/spring/"},{"name":"springboot","slug":"spring/springboot","permalink":"http://yoursite.com/categories/spring/springboot/"},{"name":"java","slug":"spring/springboot/java","permalink":"http://yoursite.com/categories/spring/springboot/java/"}],"tags":[{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"},{"name":"demo","slug":"demo","permalink":"http://yoursite.com/tags/demo/"}]},{"title":"Springboot接口加密解密","slug":"Springboot接口加密解密","date":"2023-07-11T02:54:07.000Z","updated":"2023-07-11T06:40:44.043Z","comments":true,"path":"2023/07/11/Springboot接口加密解密/","link":"","permalink":"http://yoursite.com/2023/07/11/Springboot%E6%8E%A5%E5%8F%A3%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/","excerpt":"","text":"1. 介绍在我们日常的Java开发中，免不了和其他系统的业务交互，或者微服务之间的接口调用 如果我们想保证数据传输的安全，对接口出参加密，入参解密。 但是不想写重复代码，我们可以提供一个通用starter，提供通用加密解密功能 2. 前置知识2.1 hutool-crypto加密解密工具hutool-crypto提供了很多加密解密工具，包括对称加密，非对称加密，摘要加密等等，这不做详细介绍。 2.2 request流只能读取一次的问题2.2.1 问题：在接口调用链中，request的请求流只能调用一次，处理之后，如果之后还需要用到请求流获取数据，就会发现数据为空。 比如使用了filter或者aop在接口处理之前，获取了request中的数据，对参数进行了校验，那么之后就不能在获取request请求流了 2.2.2 解决办法继承HttpServletRequestWrapper，将请求中的流copy一份，复写getInputStream和getReader方法供外部使用。每次调用后的getInputStream方法都是从复制出来的二进制数组中进行获取，这个二进制数组在对象存在期间一致存在。 使用Filter过滤器，在一开始，替换request为自己定义的可以多次读取流的request。 这样就实现了流的重复获取 InputStreamHttpServletRequestWrapper 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package xyz.hlh.cryptotest.utils;import org.apache.commons.io.IOUtils;import javax.servlet.ReadListener;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import java.io.BufferedReader;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStreamReader;/** * 请求流支持多次获取 */public class InputStreamHttpServletRequestWrapper extends HttpServletRequestWrapper &#123; /** * 用于缓存输入流 */ private ByteArrayOutputStream cachedBytes; public InputStreamHttpServletRequestWrapper(HttpServletRequest request) &#123; super(request); &#125; @Override public ServletInputStream getInputStream() throws IOException &#123; if (cachedBytes == null) &#123; // 首次获取流时，将流放入 缓存输入流 中 cacheInputStream(); &#125; // 从 缓存输入流 中获取流并返回 return new CachedServletInputStream(cachedBytes.toByteArray()); &#125; @Override public BufferedReader getReader() throws IOException &#123; return new BufferedReader(new InputStreamReader(getInputStream())); &#125; /** * 首次获取流时，将流放入 缓存输入流 中 */ private void cacheInputStream() throws IOException &#123; // 缓存输入流以便多次读取。为了方便, 我使用 org.apache.commons IOUtils cachedBytes = new ByteArrayOutputStream(); IOUtils.copy(super.getInputStream(), cachedBytes); &#125; /** * 读取缓存的请求正文的输入流 * &lt;p&gt; * 用于根据 缓存输入流 创建一个可返回的 */ public static class CachedServletInputStream extends ServletInputStream &#123; private final ByteArrayInputStream input; public CachedServletInputStream(byte[] buf) &#123; // 从缓存的请求正文创建一个新的输入流 input = new ByteArrayInputStream(buf); &#125; @Override public boolean isFinished() &#123; return false; &#125; @Override public boolean isReady() &#123; return false; &#125; @Override public void setReadListener(ReadListener listener) &#123; &#125; @Override public int read() throws IOException &#123; return input.read(); &#125; &#125;&#125; HttpServletRequestInputStreamFilter 1234567891011121314151617181920212223242526272829303132333435363738package xyz.hlh.cryptotest.filter;import org.springframework.core.annotation.Order;import org.springframework.stereotype.Component;import xyz.hlh.cryptotest.utils.InputStreamHttpServletRequestWrapper;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import java.io.IOException;import static org.springframework.core.Ordered.HIGHEST_PRECEDENCE;/** * @author HLH * @description: * 请求流转换为多次读取的请求流 过滤器 * @email 17703595860@163.com * @date : Created in 2022/2/4 9:58 */@Component@Order(HIGHEST_PRECEDENCE + 1) // 优先级最高public class HttpServletRequestInputStreamFilter implements Filter &#123; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; // 转换为可以多次获取流的request HttpServletRequest httpServletRequest = (HttpServletRequest) request; InputStreamHttpServletRequestWrapper inputStreamHttpServletRequestWrapper = new InputStreamHttpServletRequestWrapper(httpServletRequest); // 放行 chain.doFilter(inputStreamHttpServletRequestWrapper, response); &#125;&#125; 2.3 SpringBoot的参数校验validation为了减少接口中，业务代码之前的大量冗余的参数校验代码 SpringBoot-validation提供了优雅的参数校验，入参都是实体类，在实体类字段上加上对应注解，就可以在进入方法之前，进行参数校验，如果参数错误，会抛出错误BindException，是不会进入方法的。 这种方法，必须要求在接口参数上加注解@Validated或者是@Valid 但是很多清空下，我们希望在代码中调用某个实体类的校验功能，所以需要如下工具类 ParamException 1234567891011121314151617181920212223package xyz.hlh.cryptotest.exception;import lombok.Getter;import java.util.List;/** * @author HLH * @description 自定义参数异常 * @email 17703595860@163.com * @date Created in 2021/8/10 下午10:56 */@Getterpublic class ParamException extends Exception &#123; private final List&lt;String&gt; fieldList; private final List&lt;String&gt; msgList; public ParamException(List&lt;String&gt; fieldList, List&lt;String&gt; msgList) &#123; this.fieldList = fieldList; this.msgList = msgList; &#125;&#125; ValidationUtils 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package xyz.hlh.cryptotest.utils;import xyz.hlh.cryptotest.exception.CustomizeException;import xyz.hlh.cryptotest.exception.ParamException;import javax.validation.ConstraintViolation;import javax.validation.Validation;import javax.validation.Validator;import java.util.LinkedList;import java.util.List;import java.util.Set;/** * @author HLH * @description 验证工具类 * @email 17703595860@163.com * @date Created in 2021/8/10 下午10:56 */public class ValidationUtils &#123; private static final Validator VALIDATOR = Validation.buildDefaultValidatorFactory().getValidator(); /** * 验证数据 * @param object 数据 */ public static void validate(Object object) throws CustomizeException &#123; Set&lt;ConstraintViolation&lt;Object&gt;&gt; validate = VALIDATOR.validate(object); // 验证结果异常 throwParamException(validate); &#125; /** * 验证数据(分组) * @param object 数据 * @param groups 所在组 */ public static void validate(Object object, Class&lt;?&gt; ... groups) throws CustomizeException &#123; Set&lt;ConstraintViolation&lt;Object&gt;&gt; validate = VALIDATOR.validate(object, groups); // 验证结果异常 throwParamException(validate); &#125; /** * 验证数据中的某个字段(分组) * @param object 数据 * @param propertyName 字段名称 */ public static void validate(Object object, String propertyName) throws CustomizeException &#123; Set&lt;ConstraintViolation&lt;Object&gt;&gt; validate = VALIDATOR.validateProperty(object, propertyName); // 验证结果异常 throwParamException(validate); &#125; /** * 验证数据中的某个字段(分组) * @param object 数据 * @param propertyName 字段名称 * @param groups 所在组 */ public static void validate(Object object, String propertyName, Class&lt;?&gt; ... groups) throws CustomizeException &#123; Set&lt;ConstraintViolation&lt;Object&gt;&gt; validate = VALIDATOR.validateProperty(object, propertyName, groups); // 验证结果异常 throwParamException(validate); &#125; /** * 验证结果异常 * @param validate 验证结果 */ private static void throwParamException(Set&lt;ConstraintViolation&lt;Object&gt;&gt; validate) throws CustomizeException &#123; if (validate.size() &gt; 0) &#123; List&lt;String&gt; fieldList = new LinkedList&lt;&gt;(); List&lt;String&gt; msgList = new LinkedList&lt;&gt;(); for (ConstraintViolation&lt;Object&gt; next : validate) &#123; fieldList.add(next.getPropertyPath().toString()); msgList.add(next.getMessage()); &#125; throw new ParamException(fieldList, msgList); &#125; &#125;&#125; 2.4 自定义starter自定义starter步骤 创建工厂，编写功能代码 声明自动配置类，把需要对外提供的对象创建好，通过配置类统一向外暴露 在resource目录下准备一个名为spring/spring.factories的文件，以org.springframework.boot.autoconfigure.EnableAutoConfiguration为key，自动配置类为value列表，进行注册 2.5 RequestBodyAdvice和ResponseBodyAdvice RequestBodyAdvice是对请求的json串进行处理， 一般使用环境是处理接口参数的自动解密 ResponseBodyAdvice是对请求相应的jsoin传进行处理，一般用于相应结果的加密 3. 功能介绍接口相应数据的时候，返回的是加密之后的数据 接口入参的时候，接收的是解密之后的数据，但是在进入接口之前，会自动解密，取得对应的数据 4. 功能细节加密解密使用对称加密的AES算法，使用hutool-crypto模块进行实现 所有的实体类提取一个公共父类，包含属性时间戳，用于加密数据返回之后的实效性，如果超过60分钟，那么其他接口将不进行处理。 如果接口加了加密注解EncryptionAnnotation，并且返回统一的json数据Result类，则自动对数据进行加密。如果是继承了统一父类RequestBase的数据，自动注入时间戳，确保数据的时效性 如果接口加了解密注解DecryptionAnnotation，并且参数使用RequestBody注解标注，传入json使用统一格式RequestData类，并且内容是继承了包含时间长的父类RequestBase，则自动解密，并且转为对应的数据类型 功能提供Springboot的starter，实现开箱即用 5. 代码实现5.1 项目结构 5.2 crypto-common5.2.1 结构 5.3 crypto-spring-boot-starter5.3.1 接口 5.3.2 重要代码crypto.properties AES需要的参数配置 12345678# 模式 cn.hutool.crypto.Modecrypto.mode=CTS# 补码方式 cn.hutool.crypto.Modecrypto.padding=PKCS5Padding# 秘钥crypto.key=testkey123456789# 盐crypto.iv=testiv1234567890 spring.factories 自动配置文件 12org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\xyz.hlh.crypto.config.AppConfig CryptConfig AES需要的配置参数 123456789101112131415161718192021222324252627282930313233package xyz.hlh.crypto.config;import cn.hutool.crypto.Mode;import cn.hutool.crypto.Padding;import lombok.Data;import lombok.EqualsAndHashCode;import lombok.Getter;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import java.io.Serializable;/** * @author HLH * @description: AES需要的配置参数 * @email 17703595860@163.com * @date : Created in 2022/2/4 13:16 */@Configuration@ConfigurationProperties(prefix = \"crypto\")@PropertySource(\"classpath:crypto.properties\")@Data@EqualsAndHashCode@Getterpublic class CryptConfig implements Serializable &#123; private Mode mode; private Padding padding; private String key; private String iv;&#125; AppConfig 自动配置类 123456789101112131415161718192021222324252627package xyz.hlh.crypto.config;import cn.hutool.crypto.symmetric.AES;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.annotation.Resource;import java.nio.charset.StandardCharsets;/** * @author HLH * @description: 自动配置类 * @email 17703595860@163.com * @date : Created in 2022/2/4 13:12 */@Configurationpublic class AppConfig &#123; @Resource private CryptConfig cryptConfig; @Bean public AES aes() &#123; return new AES(cryptConfig.getMode(), cryptConfig.getPadding(), cryptConfig.getKey().getBytes(StandardCharsets.UTF_8), cryptConfig.getIv().getBytes(StandardCharsets.UTF_8)); &#125;&#125; DecryptRequestBodyAdvice 请求自动解密 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148package xyz.hlh.crypto.advice;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.SneakyThrows;import org.apache.commons.lang3.StringUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.core.MethodParameter;import org.springframework.http.HttpInputMessage;import org.springframework.http.converter.HttpMessageConverter;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.context.request.RequestAttributes;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;import org.springframework.web.servlet.mvc.method.annotation.RequestBodyAdvice;import xyz.hlh.crypto.annotation.DecryptionAnnotation;import xyz.hlh.crypto.common.exception.ParamException;import xyz.hlh.crypto.constant.CryptoConstant;import xyz.hlh.crypto.entity.RequestBase;import xyz.hlh.crypto.entity.RequestData;import xyz.hlh.crypto.util.AESUtil;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServletRequest;import java.io.IOException;import java.lang.reflect.Type;/** * @author HLH * @description: requestBody 自动解密 * @email 17703595860@163.com * @date : Created in 2022/2/4 15:12 */@ControllerAdvicepublic class DecryptRequestBodyAdvice implements RequestBodyAdvice &#123; @Autowired private ObjectMapper objectMapper; /** * 方法上有DecryptionAnnotation注解的，进入此拦截器 * @param methodParameter 方法参数对象 * @param targetType 参数的类型 * @param converterType 消息转换器 * @return true，进入，false，跳过 */ @Override public boolean supports(MethodParameter methodParameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) &#123; return methodParameter.hasMethodAnnotation(DecryptionAnnotation.class); &#125; @Override public HttpInputMessage beforeBodyRead(HttpInputMessage inputMessage, MethodParameter parameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) throws IOException &#123; return inputMessage; &#125; /** * 转换之后，执行此方法，解密，赋值 * @param body spring解析完的参数 * @param inputMessage 输入参数 * @param parameter 参数对象 * @param targetType 参数类型 * @param converterType 消息转换类型 * @return 真实的参数 */ @SneakyThrows @Override public Object afterBodyRead(Object body, HttpInputMessage inputMessage, MethodParameter parameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) &#123; // 获取request RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes(); ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes) requestAttributes; if (servletRequestAttributes == null) &#123; throw new ParamException(\"request错误\"); &#125; HttpServletRequest request = servletRequestAttributes.getRequest(); // 获取数据 ServletInputStream inputStream = request.getInputStream(); RequestData requestData = objectMapper.readValue(inputStream, RequestData.class); if (requestData == null || StringUtils.isBlank(requestData.getText())) &#123; throw new ParamException(\"参数错误\"); &#125; // 获取加密的数据 String text = requestData.getText(); // 放入解密之前的数据 request.setAttribute(CryptoConstant.INPUT_ORIGINAL_DATA, text); // 解密 String decryptText = null; try &#123; decryptText = AESUtil.decrypt(text); &#125; catch (Exception e) &#123; throw new ParamException(\"解密失败\"); &#125; if (StringUtils.isBlank(decryptText)) &#123; throw new ParamException(\"解密失败\"); &#125; // 放入解密之后的数据 request.setAttribute(CryptoConstant.INPUT_DECRYPT_DATA, decryptText); // 获取结果 Object result = objectMapper.readValue(decryptText, body.getClass()); // 强制所有实体类必须继承RequestBase类，设置时间戳 if (result instanceof RequestBase) &#123; // 获取时间戳 Long currentTimeMillis = ((RequestBase) result).getCurrentTimeMillis(); // 有效期 60秒 long effective = 60*1000; // 时间差 long expire = System.currentTimeMillis() - currentTimeMillis; // 是否在有效期内 if (Math.abs(expire) &gt; effective) &#123; throw new ParamException(\"时间戳不合法\"); &#125; // 返回解密之后的数据 return result; &#125; else &#123; throw new ParamException(String.format(\"请求参数类型：%s 未继承：%s\", result.getClass().getName(), RequestBase.class.getName())); &#125; &#125; /** * 如果body为空，转为空对象 * @param body spring解析完的参数 * @param inputMessage 输入参数 * @param parameter 参数对象 * @param targetType 参数类型 * @param converterType 消息转换类型 * @return 真实的参数 */ @SneakyThrows @Override public Object handleEmptyBody(Object body, HttpInputMessage inputMessage, MethodParameter parameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) &#123; String typeName = targetType.getTypeName(); Class&lt;?&gt; bodyClass = Class.forName(typeName); return bodyClass.newInstance(); &#125;&#125; EncryptResponseBodyAdvice 相应自动加密 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package xyz.hlh.crypto.advice;import cn.hutool.json.JSONUtil;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.SneakyThrows;import org.apache.commons.lang3.StringUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.core.MethodParameter;import org.springframework.http.MediaType;import org.springframework.http.ResponseEntity;import org.springframework.http.converter.HttpMessageConverter;import org.springframework.http.server.ServerHttpRequest;import org.springframework.http.server.ServerHttpResponse;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;import sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl;import xyz.hlh.crypto.annotation.EncryptionAnnotation;import xyz.hlh.crypto.common.entity.Result;import xyz.hlh.crypto.common.exception.CryptoException;import xyz.hlh.crypto.entity.RequestBase;import xyz.hlh.crypto.util.AESUtil;import java.lang.reflect.Type;/** * @author HLH * @description: * @email 17703595860@163.com * @date : Created in 2022/2/4 15:12 */@ControllerAdvicepublic class EncryptResponseBodyAdvice implements ResponseBodyAdvice&lt;Result&lt;?&gt;&gt; &#123; @Autowired private ObjectMapper objectMapper; @Override public boolean supports(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) &#123; ParameterizedTypeImpl genericParameterType = (ParameterizedTypeImpl)returnType.getGenericParameterType(); // 如果直接是Result，则返回 if (genericParameterType.getRawType() == Result.class &amp;&amp; returnType.hasMethodAnnotation(EncryptionAnnotation.class)) &#123; return true; &#125; if (genericParameterType.getRawType() != ResponseEntity.class) &#123; return false; &#125; // 如果是ResponseEntity&lt;Result&gt; for (Type type : genericParameterType.getActualTypeArguments()) &#123; if (((ParameterizedTypeImpl) type).getRawType() == Result.class &amp;&amp; returnType.hasMethodAnnotation(EncryptionAnnotation.class)) &#123; return true; &#125; &#125; return false; &#125; @SneakyThrows @Override public Result&lt;?&gt; beforeBodyWrite(Result&lt;?&gt; body, MethodParameter returnType, MediaType selectedContentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) &#123; // 加密 Object data = body.getData(); // 如果data为空，直接返回 if (data == null) &#123; return body; &#125; // 如果是实体，并且继承了Request，则放入时间戳 if (data instanceof RequestBase) &#123; ((RequestBase)data).setCurrentTimeMillis(System.currentTimeMillis()); &#125; String dataText = JSONUtil.toJsonStr(data); // 如果data为空，直接返回 if (StringUtils.isBlank(dataText)) &#123; return body; &#125; // 如果位数小于16，报错 if (dataText.length() &lt; 16) &#123; throw new CryptoException(\"加密失败，数据小于16位\"); &#125; String encryptText = AESUtil.encryptHex(dataText); return Result.builder() .status(body.getStatus()) .data(encryptText) .message(body.getMessage()) .build(); &#125;&#125; 5.4 crypto-test5.4.1 结构 5.4.2 重要代码 application.yml 配置文件 12345678spring: mvc: format: date-time: yyyy-MM-dd HH:mm:ss date: yyyy-MM-dd # 日期格式化 jackson: date-format: yyyy-MM-dd HH:mm:ss Teacher 实体类 12345678910111213141516171819202122232425262728293031323334package xyz.hlh.crypto.entity;import lombok.AllArgsConstructor;import lombok.Data;import lombok.EqualsAndHashCode;import lombok.NoArgsConstructor;import org.hibernate.validator.constraints.Range;import javax.validation.constraints.NotBlank;import javax.validation.constraints.NotNull;import java.io.Serializable;import java.util.Date;/** * @author HLH * @description: Teacher实体类，使用SpringBoot的validation校验 * @email 17703595860@163.com * @date : Created in 2022/2/4 10:21 */@Data@NoArgsConstructor@AllArgsConstructor@EqualsAndHashCode(callSuper = true)public class Teacher extends RequestBase implements Serializable &#123; @NotBlank(message = \"姓名不能为空\") private String name; @NotNull(message = \"年龄不能为空\") @Range(min = 0, max = 150, message = \"年龄不合法\") private Integer age; @NotNull(message = \"生日不能为空\") private Date birthday;&#125; TestController 测试Controller 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package xyz.hlh.crypto.controller;import org.springframework.http.ResponseEntity;import org.springframework.validation.annotation.Validated;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RestController;import xyz.hlh.crypto.annotation.DecryptionAnnotation;import xyz.hlh.crypto.annotation.EncryptionAnnotation;import xyz.hlh.crypto.common.entity.Result;import xyz.hlh.crypto.common.entity.ResultBuilder;import xyz.hlh.crypto.entity.Teacher;/** * @author HLH * @description: 测试Controller * @email 17703595860@163.com * @date : Created in 2022/2/4 9:16 */@RestControllerpublic class TestController implements ResultBuilder &#123; /** * 直接返回对象，不加密 * @param teacher Teacher对象 * @return 不加密的对象 */ @PostMapping(\"/get\") public ResponseEntity&lt;Result&lt;?&gt;&gt; get(@Validated @RequestBody Teacher teacher) &#123; return success(teacher); &#125; /** * 返回加密后的数据 * @param teacher Teacher对象 * @return 返回加密后的数据 ResponseBody&lt;Result&gt;格式 */ @PostMapping(\"/encrypt\") @EncryptionAnnotation public ResponseEntity&lt;Result&lt;?&gt;&gt; encrypt(@Validated @RequestBody Teacher teacher) &#123; return success(teacher); &#125; /** * 返回加密后的数据 * @param teacher Teacher对象 * @return 返回加密后的数据 Result格式 */ @PostMapping(\"/encrypt1\") @EncryptionAnnotation public Result&lt;?&gt; encrypt1(@Validated @RequestBody Teacher teacher) &#123; return success(teacher).getBody(); &#125; /** * 返回解密后的数据 * @param teacher Teacher对象 * @return 返回解密后的数据 */ @PostMapping(\"/decrypt\") @DecryptionAnnotation public ResponseEntity&lt;Result&lt;?&gt;&gt; decrypt(@Validated @RequestBody Teacher teacher) &#123; return success(teacher); &#125;&#125;","categories":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/categories/spring/"},{"name":"springboot","slug":"spring/springboot","permalink":"http://yoursite.com/categories/spring/springboot/"},{"name":"java","slug":"spring/springboot/java","permalink":"http://yoursite.com/categories/spring/springboot/java/"}],"tags":[{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"},{"name":"demo","slug":"demo","permalink":"http://yoursite.com/tags/demo/"}]},{"title":"高效优雅的使用java枚举","slug":"高效优雅的使用java枚举","date":"2023-06-30T01:45:46.000Z","updated":"2023-07-11T03:18:25.763Z","comments":true,"path":"2023/06/30/高效优雅的使用java枚举/","link":"","permalink":"http://yoursite.com/2023/06/30/%E9%AB%98%E6%95%88%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8java%E6%9E%9A%E4%B8%BE/","excerpt":"","text":"背景 枚举在系统中的地位不言而喻，状态、类型、场景、标识等等，少则十几个多则上百个，相信以下这段代码很常见，而且类似的代码到处都是，目标：消除这类冗余代码。 12345678910111213141516171819202122232425/** * 根据枚举代码获取枚举 * */public static OrderStatus getByCode(String code)&#123; for (OrderStatus v : values()) &#123; if (v.getCode().equals(code)) &#123; return v; &#125; &#125; return null;&#125;/** * 根据枚举名称获取枚举 * 当枚举内的实例数越多时性能越差 */public static OrderStatus getByName(String name)&#123; for (OrderStatus v : values()) &#123; if (v.name().equals(name)) &#123; return v; &#125; &#125; return null;&#125; 枚举缓存 减少代码冗余，代码简洁 去掉for循环，性能稳定高效 源码分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153import java.util.Map;import java.util.concurrent.ConcurrentHashMap;/** * 枚举缓存 */public class EnumCache &#123; /** * 以枚举任意值构建的缓存结构 **/ static final Map&lt;Class&lt;? extends Enum&gt;, Map&lt;Object, Enum&gt;&gt; CACHE_BY_VALUE = new ConcurrentHashMap&lt;&gt;(); /** * 以枚举名称构建的缓存结构 **/ static final Map&lt;Class&lt;? extends Enum&gt;, Map&lt;Object, Enum&gt;&gt; CACHE_BY_NAME = new ConcurrentHashMap&lt;&gt;(); /** * 枚举静态块加载标识缓存结构 */ static final Map&lt;Class&lt;? extends Enum&gt;, Boolean&gt; LOADED = new ConcurrentHashMap&lt;&gt;(); /** * 以枚举名称构建缓存，在枚举的静态块里面调用 * * @param clazz * @param es * @param &lt;E&gt; */ public static &lt;E extends Enum&gt; void registerByName(Class&lt;E&gt; clazz, E[] es) &#123; Map&lt;Object, Enum&gt; map = new ConcurrentHashMap&lt;&gt;(); for (E e : es) &#123; map.put(e.name(), e); &#125; CACHE_BY_NAME.put(clazz, map); &#125; /** * 以枚举转换出的任意值构建缓存，在枚举的静态块里面调用 * * @param clazz * @param es * @param enumMapping * @param &lt;E&gt; */ public static &lt;E extends Enum&gt; void registerByValue(Class&lt;E&gt; clazz, E[] es, EnumMapping&lt;E&gt; enumMapping) &#123; if (CACHE_BY_VALUE.containsKey(clazz)) &#123; throw new RuntimeException(String.format(\"枚举%s已经构建过value缓存,不允许重复构建\", clazz.getSimpleName())); &#125; Map&lt;Object, Enum&gt; map = new ConcurrentHashMap&lt;&gt;(); for (E e : es) &#123; Object value = enumMapping.value(e); if (map.containsKey(value)) &#123; throw new RuntimeException(String.format(\"枚举%s存在相同的值%s映射同一个枚举%s.%s\", clazz.getSimpleName(), value, clazz.getSimpleName(), e)); &#125; map.put(value, e); &#125; CACHE_BY_VALUE.put(clazz, map); &#125; /** * 从以枚举名称构建的缓存中通过枚举名获取枚举 * * @param clazz * @param name * @param defaultEnum * @param &lt;E&gt; * @return */ public static &lt;E extends Enum&gt; E findByName(Class&lt;E&gt; clazz, String name, E defaultEnum) &#123; return find(clazz, name, CACHE_BY_NAME, defaultEnum); &#125; /** * 从以枚举转换值构建的缓存中通过枚举转换值获取枚举 * * @param clazz * @param value * @param defaultEnum * @param &lt;E&gt; * @return */ public static &lt;E extends Enum&gt; E findByValue(Class&lt;E&gt; clazz, Object value, E defaultEnum) &#123; return find(clazz, value, CACHE_BY_VALUE, defaultEnum); &#125; private static &lt;E extends Enum&gt; E find(Class&lt;E&gt; clazz, Object obj, Map&lt;Class&lt;? extends Enum&gt;, Map&lt;Object, Enum&gt;&gt; cache, E defaultEnum) &#123; Map&lt;Object, Enum&gt; map = null; if ((map = cache.get(clazz)) == null) &#123; executeEnumStatic(clazz);// 触发枚举静态块执行 map = cache.get(clazz);// 执行枚举静态块后重新获取缓存 &#125; if (map == null) &#123; String msg = null; if (cache == CACHE_BY_NAME) &#123; msg = String.format( \"枚举%s还没有注册到枚举缓存中，请在%s.static代码块中加入如下代码 : EnumCache.registerByName(%s.class, %s.values());\", clazz.getSimpleName(), clazz.getSimpleName(), clazz.getSimpleName(), clazz.getSimpleName() ); &#125; if (cache == CACHE_BY_VALUE) &#123; msg = String.format( \"枚举%s还没有注册到枚举缓存中，请在%s.static代码块中加入如下代码 : EnumCache.registerByValue(%s.class, %s.values(), %s::getXxx);\", clazz.getSimpleName(), clazz.getSimpleName(), clazz.getSimpleName(), clazz.getSimpleName(), clazz.getSimpleName() ); &#125; throw new RuntimeException(msg); &#125; if(obj == null)&#123; return defaultEnum; &#125; Enum result = map.get(obj); return result == null ? defaultEnum : (E) result; &#125; private static &lt;E extends Enum&gt; void executeEnumStatic(Class&lt;E&gt; clazz) &#123; if (!LOADED.containsKey(clazz)) &#123; synchronized (clazz) &#123; if (!LOADED.containsKey(clazz)) &#123; try &#123; // 目的是让枚举类的static块运行，static块没有执行完是会阻塞在此的 Class.forName(clazz.getName()); LOADED.put(clazz, true); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; &#125; &#125; &#125; /** * 枚举缓存映射器函数式接口 */ @FunctionalInterface public interface EnumMapping&lt;E extends Enum&gt; &#123; /** * 自定义映射器 * * @param e 枚举 * @return 映射关系，最终体现到缓存中 */ Object value(E e); &#125;&#125; 开闭原则什么是开闭原则？ 对修改是封闭的，对新增扩展是开放的。为了满足开闭原则，这里设计成有枚举主动注册到缓存，而不是有缓存主动加载枚举，这样设计的好处就是：当增加一个枚举时只需要在当前枚举的静态块中自主注册即可，不需要修改其他的代码 比如我们现在要新增一个状态类枚举： 1234567891011121314151617181920212223242526272829public enum StatusEnum &#123; INIT(\"I\", \"初始化\"), PROCESSING(\"P\", \"处理中\"), SUCCESS(\"S\", \"成功\"), FAIL(\"F\", \"失败\"); private String code; private String desc; StatusEnum(String code, String desc) &#123; this.code = code; this.desc = desc; &#125; public String getCode() &#123; return code; &#125; public String getDesc() &#123; return desc; &#125; static &#123; // 通过名称构建缓存,通过EnumCache.findByName(StatusEnum.class,\"SUCCESS\",null);调用能获取枚举 EnumCache.registerByName(StatusEnum.class, StatusEnum.values()); // 通过code构建缓存,通过EnumCache.findByValue(StatusEnum.class,\"S\",null);调用能获取枚举 EnumCache.registerByValue(StatusEnum.class, StatusEnum.values(), StatusEnum::getCode); &#125;&#125; 注册时机 将注册放在静态块中，那么静态块什么时候执行呢？ 1、当第一次创建某个类的新实例时 2、当第一次调用某个类的任意静态方法时 3、当第一次使用某个类或接口的任意非final静态字段时 4、当第一次Class.forName时 如果我们入StatusEnum创建枚举，那么在应用系统启动的过程中StatusEnum的静态块可能从未执行过，则枚举缓存注册失败，所有我们需要考虑延迟注册，代码如下： 123456789101112131415private static &lt;E extends Enum&gt; void executeEnumStatic(Class&lt;E&gt; clazz) &#123; if (!LOADED.containsKey(clazz)) &#123; synchronized (clazz) &#123; if (!LOADED.containsKey(clazz)) &#123; try &#123; // 目的是让枚举类的static块运行，static块没有执行完是会阻塞在此的 Class.forName(clazz.getName()); LOADED.put(clazz, true); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; &#125; &#125; &#125; Class.forName(clazz.getName())被执行的两个必备条件： 1、缓存中没有枚举class的键，也就是说没有执行过枚举向缓存注册的调用，见EnumCache.find方法对executeEnumStatic方法的调用； 2、executeEnumStatic中的LOADED.put(clazz, true);还没有被执行过，也就是Class.forName(clazz.getName());没有被执行过； 我们看到executeEnumStatic中用到了双重检查锁，所以分析一下正常情况下代码执行情况和性能： 1、当静态块还未执行时，大量的并发执行find查询。 此时executeEnumStatic中synchronized会阻塞其他线程； 第一个拿到锁的线程会执行Class.forName(clazz.getName());同时触发枚举静态块的同步执行； 之后其他线程会逐一拿到锁，第二次检查会不成立跳出executeEnumStatic； 2、当静态块已经执行，且静态块里面正常执行了缓存注册，大量的并发执行find查询。 executeEnumStatic方法不会调用，没有synchronized引发的排队问题； 3、当静态块已经执行，但是静态块里面没有调用缓存注册，大量的并发执行find查询。 find方法会调用executeEnumStatic方法，但是executeEnumStatic的第一次检查通不过； find方法会提示异常需要在静态块中添加注册缓存的代码； 总结：第一种场景下会有短暂的串行，但是这种内存计算短暂串行相比应用系统的业务逻辑执行是微不足道的，也就是说这种短暂的串行不会成为系统的性能瓶颈 样例展示 构造枚举 1234567891011121314151617181920212223242526272829public enum StatusEnum &#123; INIT(\"I\", \"初始化\"), PROCESSING(\"P\", \"处理中\"), SUCCESS(\"S\", \"成功\"), FAIL(\"F\", \"失败\"); private String code; private String desc; StatusEnum(String code, String desc) &#123; this.code = code; this.desc = desc; &#125; public String getCode() &#123; return code; &#125; public String getDesc() &#123; return desc; &#125; static &#123; // 通过名称构建缓存,通过EnumCache.findByName(StatusEnum.class,\"SUCCESS\",null);调用能获取枚举 EnumCache.registerByName(StatusEnum.class, StatusEnum.values()); // 通过code构建缓存,通过EnumCache.findByValue(StatusEnum.class,\"S\",null);调用能获取枚举 EnumCache.registerByValue(StatusEnum.class, StatusEnum.values(), StatusEnum::getCode); &#125;&#125; 测试类 1234567891011121314151617public class Test&#123; public static void main(String [] args)&#123; System.out.println(EnumCache.findByName(StatusEnum.class, \"SUCCESS\", null)); // 返回默认值StatusEnum.INIT System.out.println(EnumCache.findByName(StatusEnum.class, null, StatusEnum.INIT)); // 返回默认值StatusEnum.INIT System.out.println(EnumCache.findByName(StatusEnum.class, \"ERROR\", StatusEnum.INIT)); System.out.println(EnumCache.findByValue(StatusEnum.class, \"S\", null)); // 返回默认值StatusEnum.INIT System.out.println(EnumCache.findByValue(StatusEnum.class, null, StatusEnum.INIT)); // 返回默认值StatusEnum.INIT System.out.println(EnumCache.findByValue(StatusEnum.class, \"ERROR\", StatusEnum.INIT)); &#125;&#125; 执行结果 123456SUCCESSINITINITSUCCESSINITINIT 性能对比 对比代码，如果OrderType中的实例数越多性能差异会越大 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class Test &#123; enum OrderType &#123; _00(\"00\", \"00\"), _01(\"01\", \"01\"), _02(\"02\", \"02\"), _03(\"03\", \"03\"), _04(\"04\", \"04\"), _05(\"05\", \"05\"), _06(\"06\", \"06\"), _07(\"07\", \"07\"), _08(\"08\", \"08\"), _09(\"09\", \"09\"), _10(\"10\", \"10\") ; private String code; private String desc; OrderType(String code, String desc) &#123; this.code = code; this.desc = desc; &#125; public String getCode() &#123; return code; &#125; public String getDesc() &#123; return desc; &#125; static &#123; EnumCache.registerByValue(OrderType.class, OrderType.values(), OrderType::getCode); &#125; public static OrderType getEnumByCode(String code, OrderType def) &#123; OrderType[] values = OrderType.values(); for (OrderType value : values) &#123; if (value.getCode().equals(code)) &#123; return value; &#125; &#125; return def; &#125; &#125; private static final OrderType DEF = OrderType._00; private static final int TIMES = 10000000; static void compare(String code) &#123; long s = System.currentTimeMillis(); for (int idx = 0; idx &lt; TIMES; idx++) &#123; OrderType.getEnumByCode(code, DEF); &#125; long t = System.currentTimeMillis() - s; System.out.println(String.format(\"枚举-&gt;%s : %s\", code, t)); s = System.currentTimeMillis(); for (int idx = 0; idx &lt; TIMES; idx++) &#123; EnumCache.findByValue(OrderType.class, code, DEF); &#125; t = System.currentTimeMillis() - s; System.out.println(String.format(\"缓存-&gt;%s : %s\", code, t)); System.out.println(); &#125; public static void main(String[] args) throws Exception &#123; for (int idx = 0; idx &lt; 2; idx++) &#123; compare(\"NotExist\"); for (OrderType value : OrderType.values()) &#123; compare(value.getCode()); &#125; System.out.println(\"=================\"); &#125; &#125;&#125; 执行结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374枚举-&gt;NotExist : 312缓存-&gt;NotExist : 105枚举-&gt;00 : 199缓存-&gt;00 : 164枚举-&gt;01 : 313缓存-&gt;01 : 106枚举-&gt;02 : 227缓存-&gt;02 : 90枚举-&gt;03 : 375缓存-&gt;03 : 92枚举-&gt;04 : 260缓存-&gt;04 : 92枚举-&gt;05 : 272缓存-&gt;05 : 78枚举-&gt;06 : 284缓存-&gt;06 : 78枚举-&gt;07 : 315缓存-&gt;07 : 76枚举-&gt;08 : 351缓存-&gt;08 : 78枚举-&gt;09 : 372缓存-&gt;09 : 81枚举-&gt;10 : 402缓存-&gt;10 : 78=================枚举-&gt;NotExist : 199缓存-&gt;NotExist : 68枚举-&gt;00 : 99缓存-&gt;00 : 91枚举-&gt;01 : 141缓存-&gt;01 : 79枚举-&gt;02 : 178缓存-&gt;02 : 77枚举-&gt;03 : 202缓存-&gt;03 : 77枚举-&gt;04 : 218缓存-&gt;04 : 81枚举-&gt;05 : 259缓存-&gt;05 : 90枚举-&gt;06 : 322缓存-&gt;06 : 78枚举-&gt;07 : 318缓存-&gt;07 : 78枚举-&gt;08 : 347缓存-&gt;08 : 77枚举-&gt;09 : 373缓存-&gt;09 : 79枚举-&gt;10 : 404缓存-&gt;10 : 78================= 总结 1、代码简洁；2、枚举中实例数越多，缓存模式的性能优势越多；","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java枚举","slug":"java枚举","permalink":"http://yoursite.com/tags/java%E6%9E%9A%E4%B8%BE/"}]},{"title":"MySQL_linux下mysql数据库自动定时备份","slug":"MySQL-linux下mysql数据库自动定时备份","date":"2023-03-08T07:28:05.000Z","updated":"2023-03-08T08:05:48.235Z","comments":true,"path":"2023/03/08/MySQL-linux下mysql数据库自动定时备份/","link":"","permalink":"http://yoursite.com/2023/03/08/MySQL-linux%E4%B8%8Bmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%8A%A8%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD/","excerpt":"","text":"1.创建文件夹mysql-backup1234# 创建文件夹 mysql-backup[root@Zab mysql-backup]# pwd/home/ruoyi/mysql-backup[root@Zab mysql-backup]# 2.编写shell备份脚本1vi mysql_backup.sh 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/bin/bash#保存备份个数，备份31天数据number=31#备份保存路径backup_dir=/home/ruoyi/mysql-backup/data#日期dd=`date +%Y-%m-%d-%H-%M-%S`#备份工具tool=mysqldump#用户名username=root#密码password=123456#将要备份的数据库database_name=ry-vue#如果文件夹不存在则创建if [ ! -d $backup_dir ];then mkdir -p $backup_dir;fiecho '开始导出数据库...'#简单写法 mysqldump -uroot -p123456 ry-vue | gzip &gt; /home/ruoyi/mysql-backup/data/$(date +%Y%m%d_%H%M%S)_ry-vue.sql.gz$tool -u $username -p$password --databases $database_name | gzip &gt; $backup_dir/$database_name-$dd.sql.gz#写创建备份日志echo \"create $backup_dir/$database_name-$dd.dupm\" &gt;&gt; $backup_dir/log.txt#找出需要删除的备份delfile=`ls -l -crt $backup_dir/*.sql.gz | awk '&#123;print $9 &#125;' | head -1`#判断现在的备份数量是否大于$numbercount=`ls -l -crt $backup_dir/*.sql.gz | awk '&#123;print $9 &#125;' | wc -l`if [ $count -gt $number ]then #删除最早生成的备份，只保留number数量的备份 rm $delfile #写删除文件日志 echo \"delete $delfile\" &gt;&gt; $backup_dir/log.txtfiecho '导出成功!!! &gt;_&lt; ' 3.添加可执行权限1chmod u+x mysql_backup.sh 添加可执行权限之后先执行一下，看看脚本有没有错误，能不能正常使用； 1./mysql_backup.sh 4.设置定时任务添加计划任务执行命令 1crontab -e 这时就像使用vi编辑器一样，可以对计划任务进行编辑。 输入以下内容并保存： 12# 意思是每3分钟执行一次shell脚本“/home/ruoyi/mysql-backup/mysql_backup.sh”。*/3 * * * * /home/ruoyi/mysql-backup/mysql_backup.sh 通过一下命令可以查看定时任务 12# 通过一下命令可以查看定时任务crontab -l 测试任务是否执行 1.通过 ls 命令查看是否生成备份文件 2.如果任务执行失败了，可以通过以下命令查看任务日志： 1tail -f /var/log/cron MySQL 系统自带的 mysqldump 备份工具的使用，其实还有一个开源工具 mydumper 同样适用于 MySQL 的逻辑备份,mydumper 是一款社区开源的逻辑备份工具。该工具主要由 C 语言编写，目前由 MySQL 、Facebook 等公司人员开发维护,为多线程备份mysql工具，效率比mysqldump高很多，推荐使用。 以下为安装mydumper后shell脚本示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#备份保存个数,备份5天的数据number=5#备份保存路径backup_dir=/home/test/mysql-backup/dumper/data#日期dd=`date +%Y-%m-%d`#备份方式 mydumper可执行路径tool=/usr/local/test/bin/mydumper#地址address=127.0.0.1#端口port=3306#用户名username=root#密码password=123456#将要备份的数据库database_name=test#如果文件夹不存在则创建if [ ! -d $backup_dir ];then mkdir -p $backup_dir;fiecho '开始导出数据库...'$tool -u $username -p $password -p $port -h $address -B $database_name -c -o $backup_dir/$dd#写创建备份日志echo \"create $backup_dir/$database_name-$dd.dumper\" &gt;&gt; $backup_dir/log.txt#找出需要删除的备份文件夹delfile=`ls -ltr /home/test/mysql-backup/dumper/data/ | awk '/^d/ &#123;print $NF&#125;' | head -1`#判断现在的备份数量是否大于$numbercount=`ls -lt /home/test/mysql-backup/dumper/data/ | awk '/^d/ &#123;print $NF&#125;' | wc -l`if [ $count -gt $number ]then #删除最早生成的备份，只保留number数量的备份 rm -rf $backup_dir/$delfile #写删除文件日志 echo \"delete $delfile\" &gt;&gt; $backup_dir/log.txtfiecho '备份成功!!! &gt;_&lt; '","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"数据库备份","slug":"数据库备份","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD/"}]},{"title":"妙用Java8中的Function接口","slug":"妙用Java8中的Function接口","date":"2022-05-16T14:37:30.000Z","updated":"2022-05-16T15:29:21.006Z","comments":true,"path":"2022/05/16/妙用Java8中的Function接口/","link":"","permalink":"http://yoursite.com/2022/05/16/%E5%A6%99%E7%94%A8Java8%E4%B8%AD%E7%9A%84Function%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"Function 函数式接口 Supplier供给型函数 Consumer消费型函数 Runnable无参无返回型函数 Function函数的表现形式为接收一个参数，并返回一个值。Supplier、Consumer和Runnable可以看作Function的一种特殊表现形式 使用小技巧 处理抛出异常的if 处理if分支操作 如果存在值执行消费操作，否则执行基于空的操作 在开发过程中经常会使用if...else...进行判断抛出异常、分支处理等操作。这些if...else...充斥在代码中严重影响了代码代码的美观，这时我们可以利用Java 8的Function接口来消灭if...else...。 123456789if (...)&#123; throw new RuntimeException(\"出现异常了\")；&#125; if (...)&#123; doSomething();&#125; else &#123; doOther();&#125; Function 函数式接口使用注解@FunctionalInterface标识，并且只包含一个抽象方法的接口是函数式接口。函数式接口主要分为Supplier供给型函数、Consumer消费型函数、Runnable无参无返回型函数和Function有参有返回型函数。 Function可以看作转换型函数 Supplier 供给型函数Supplier的表现形式为不接受参数、只返回数据 12345678910@FunctionalInterfacepublic interface Supplier&lt;T&gt; &#123; /** * Gets a result. * * @return a result */ T get();&#125; Consumer 消费型函数Consumer消费型函数和Supplier刚好相反。Consumer接收一个参数，没有返回值 12345678910@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123; void accept(T t); default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) &#123; Objects.requireNonNull(after); return (T t) -&gt; &#123; accept(t); after.accept(t); &#125;; &#125;&#125; Runnable 无参无返回型函数Runnable的表现形式为即没有参数也没有返回值 12345@FunctionalInterfacepublic interface Runnable &#123; public abstract void run();&#125; Function 函数的表现形式为接收一个参数，并返回一个值。Supplier、Consumer 和 Runnable 可以看作 Function 的一种特殊表现形式123456789101112131415161718@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; R apply(T t); default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) &#123; Objects.requireNonNull(before); return (V v) -&gt; apply(before.apply(v)); &#125; default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) &#123; Objects.requireNonNull(after); return (T t) -&gt; after.apply(apply(t)); &#125; static &lt;T&gt; Function&lt;T, T&gt; identity() &#123; return t -&gt; t; &#125; 使用小技巧处理抛出异常的if 定义函数 定义一个抛出异常的形式的函数式接口, 这个接口只有参数没有返回值是个消费型接口 1234567891011121314/** * 抛异常接口 **/@FunctionalInterfacepublic interface ThrowExceptionFunction &#123; /** * 抛出异常信息 * * @param message 异常信息 * @return void **/ void throwMessage(String message);&#125; 编写判断方法 创建工具类VUtils并创建一个isTure方法，方法的返回值为刚才定义的函数式接口-ThrowExceptionFunction。ThrowExceptionFunction的接口实现逻辑为当参数b为true时抛出异常 1234567891011121314/** * 如果参数为true抛出异常 * * @param b * @return com.example.demo.func.ThrowExceptionFunction **/public static ThrowExceptionFunction isTure(boolean b)&#123; return (errorMessage) -&gt; &#123; if (b)&#123; throw new RuntimeException(errorMessage); &#125; &#125;;&#125; 使用方式 调用工具类参数参数后，调用函数式接口的throwMessage方法传入异常信息。当出入的参数为false时正常执行，当出入的参数为true时抛出异常 12345@Testvoid isTrue()&#123; VUtils.isTrue(false).throwMessage(\"抛出异常啦\"); VUtils.isTrue(true).throwMessage(\"抛出异常啦\");&#125; 处理if分支操作 定义函数式接口 创建一个名为BranchHandle的函数式接口，接口的参数为两个Runnable接口。这两个两个Runnable接口分别代表了为true或false时要进行的操作 12345678910111213141516/** * 分支处理接口 **/@FunctionalInterfacepublic interface BranchHandle &#123; /** * 分支操作 * * @param trueHandle 为true时要进行的操作 * @param falseHandle 为false时要进行的操作 * @return void **/ void trueOrFalseHandle(Runnable trueHandle, Runnable falseHandle);&#125; 编写判断方法 创建一个名为isTureOrFalse的方法，方法的返回值为刚才定义的函数式接口-BranchHandle。 12345678910111213141516/** * 参数为true或false时，分别进行不同的操作 * * @param b * @return com.example.demo.func.BranchHandle **/public static BranchHandle isTureOrFalse(boolean b)&#123; return (trueHandle, falseHandle) -&gt; &#123; if (b)&#123; trueHandle.run(); &#125; else &#123; falseHandle.run(); &#125; &#125;;&#125; 使用方式 参数为true时，执行trueHandle,参数为false时，执行falseHandle 12345678@Testvoid isTrueOrFalse()&#123; VUtils.isTrueOrFalse(true).trueOrFalseHandle(&#123;() -&gt; &#123; System.out.println(\"true,开始秀\");&#125;,() -&gt; &#123; System.out.println(\"true,开始跑\");&#125;);&#125; 如果存在执行消费操作，否则执行基于空的操作 定义函数 创建一个名为PresentOrElseHandler的函数式接口，接口的参数一个为Consumer接口。一个为Runnable,分别代表值不为空时执行消费操作和值为空时执行的其他操作 12345678910111213141516/** * 空值与非空值分支处理 */public interface PresentOrElseHandler&lt;T extends Object&gt; &#123; /** * 值不为空时执行消费操作 * 值为空时执行其他的操作 * * @param action 值不为空时，执行的消费操作 * @param emptyAction 值为空时，执行的操作 * @return void **/ void presentOrElseHandle(Consumer&lt;? super T&gt; action, Runnable emptyAction);&#125; 编写判断方法 创建一个名为isBlankOrNoBlank的方法，方法的返回值为刚才定义的函数式接口-PresentOrElseHandler。 12345678910111213141516/** * 参数为true或false时，分别进行不同的操作 * * @param b * @return com.example.demo.func.BranchHandle **/public static PresentOrElseHandler&lt;?&gt; isBlankOrNoBlank(String str)&#123; return (consumer, runnable) -&gt; &#123; if (str == null || str.length() == 0)&#123; runnable.run(); &#125; else &#123; consumer.accept(str); &#125; &#125;;&#125; 使用方式 调用工具类参数参数后，调用函数式接口的presentOrElseHandle方法传入一个Consumer和Runnable 参数不为空时，打印参数 12345@Testervoid isBlankOrNoBlank(\"hello\").presentOrElseHandle(System.out::println,() -&gt; &#123; System.out.println(\"空字符串\");&#125;);","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"Java8","slug":"java/Java8","permalink":"http://yoursite.com/categories/java/Java8/"}],"tags":[{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"},{"name":"函数式接口","slug":"函数式接口","permalink":"http://yoursite.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"}]},{"title":"Spring Boot内置工具类","slug":"Spring-Boot内置工具类","date":"2022-05-14T01:35:43.000Z","updated":"2022-05-14T02:16:40.421Z","comments":true,"path":"2022/05/14/Spring-Boot内置工具类/","link":"","permalink":"http://yoursite.com/2022/05/14/Spring-Boot%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"","text":"断言 断言是一个逻辑判断，用于检查不应该发生的情况 Assert 关键字在 JDK1.4 中引入，可通过 JVM 参数-enableassertions开启 SpringBoot 中提供了 Assert 断言工具类，通常用于数据合法性检查 123456789101112131415161718// 要求参数 object 必须为非空（Not Null），否则抛出异常，不予放行// 参数 message 参数用于定制异常信息。void notNull(Object object, String message)// 要求参数必须空（Null），否则抛出异常，不予『放行』。// 和 notNull() 方法断言规则相反void isNull(Object object, String message)// 要求参数必须为真（True），否则抛出异常，不予『放行』。void isTrue(boolean expression, String message)// 要求参数（List/Set）必须非空（Not Empty），否则抛出异常，不予放行void notEmpty(Collection collection, String message)// 要求参数（String）必须有长度（即，Not Empty），否则抛出异常，不予放行void hasLength(String text, String message)// 要求参数（String）必须有内容（即，Not Blank），否则抛出异常，不予放行void hasText(String text, String message)// 要求参数是指定类型的实例，否则抛出异常，不予放行void isInstanceOf(Class type, Object obj, String message)// 要求参数 `subType` 必须是参数 superType 的子类或实现类，否则抛出异常，不予放行void isAssignable(Class superType, Class subType, String message) 对象、数组、集合ObjectUtils1.获取对象的基本信息 123456789101112// 获取对象的类名。参数为 null 时，返回字符串：\"null\"String nullSafeClassName(Object obj)// 参数为 null 时，返回 0int nullSafeHashCode(Object object)// 参数为 null 时，返回字符串：\"null\"String nullSafeToString(boolean[] array)// 获取对象 HashCode（十六进制形式字符串）。参数为 null 时，返回 0String getIdentityHexString(Object obj)// 获取对象的类名和 HashCode。参数为 null 时，返回字符串：\"\"String identityToString(Object obj)// 相当于 toString()方法，但参数为 null 时，返回字符串：\"\"String getDisplayString(Object obj) 判断工具 1234567891011121314151617// 判断数组是否为空boolean isEmpty(Object[] array)// 判断参数对象是否是数组boolean isArray(Object obj)// 判断数组中是否包含指定元素boolean containsElement(Object[] array, Object element)// 相等，或同为 null时，返回 trueboolean nullSafeEquals(Object o1, Object o2)/*判断参数对象是否为空，判断标准为： Optional: Optional.empty() Array: length == 0CharSequence: length == 0 Collection: Collection.isEmpty() Map: Map.isEmpty() */boolean isEmpty(Object obj) 其他工具方法 1234// 向参数数组的末尾追加新元素，并返回一个新数组&lt;A, O extends A&gt; A[] addObjectToArray(A[] array, O obj)// 原生基础类型数组 --&gt; 包装类数组Object[] toObjectArray(Object source) StringUtils 字符串判断工具 12345678910111213141516// 判断字符串是否为 null，或 \"\"。注意，包含空白符的字符串为非空boolean isEmpty(Object str)// 判断字符串是否是以指定内容结束。忽略大小写boolean endsWithIgnoreCase(String str, String suffix)// 判断字符串是否已指定内容开头。忽略大小写boolean startsWithIgnoreCase(String str, String prefix)// 是否包含空白符boolean containsWhitespace(String str)// 判断字符串非空且长度不为 0，即，Not Emptyboolean hasLength(CharSequence str)// 判断字符串是否包含实际内容，即非仅包含空白符，也就是 Not Blankboolean hasText(CharSequence str)// 判断字符串指定索引处是否包含一个子串。boolean substringMatch(CharSequence str, int index, CharSequence substring)// 计算一个字符串中指定子串的出现次数int countOccurrencesOf(String str, String sub) 字符串操作工具 12345678910111213141516171819202122// 查找并替换指定子串String replace(String inString, String oldPattern, String newPattern)// 去除尾部的特定字符String trimTrailingCharacter(String str, char trailingCharacter)// 去除头部的特定字符String trimLeadingCharacter(String str, char leadingCharacter)// 去除头部的空白符String trimLeadingWhitespace(String str)// 去除头部的空白符String trimTrailingWhitespace(String str)// 去除头部和尾部的空白符String trimWhitespace(String str)// 删除开头、结尾和中间的空白符String trimAllWhitespace(String str)// 删除指定子串String delete(String inString, String pattern)// 删除指定字符（可以是多个）String deleteAny(String inString, String charsToDelete)// 对数组的每一项执行 trim() 方法String[] trimArrayElements(String[] array)// 将 URL 字符串进行解码String uriDecode(String source, Charset charset) 路径相关工具方法 1234567891011121314// 解析路径字符串，优化其中的 “..”String cleanPath(String path)// 解析路径字符串，解析出文件名部分String getFilename(String path)// 解析路径字符串，解析出文件后缀名String getFilenameExtension(String path)// 比较两个两个字符串，判断是否是同一个路径。会自动处理路径中的 “..”boolean pathEquals(String path1, String path2)// 删除文件路径名中的后缀部分String stripFilenameExtension(String path)// 以 “. 作为分隔符，获取其最后一部分String unqualify(String qualifiedName)// 以指定字符作为分隔符，获取其最后一部分String unqualify(String qualifiedName, char separator) CollectionUtils 集合判断工具 123456789101112// 判断 List/Set 是否为空boolean isEmpty(Collection&lt;?&gt; collection)// 判断 Map 是否为空boolean isEmpty(Map&lt;?,?&gt; map)// 判断 List/Set 中是否包含某个对象boolean containsInstance(Collection&lt;?&gt; collection, Object element)// 以迭代器的方式，判断 List/Set 中是否包含某个对象boolean contains(Iterator&lt;?&gt; iterator, Object element)// 判断 List/Set 是否包含某些对象中的任意一个boolean containsAny(Collection&lt;?&gt; source, Collection&lt;?&gt; candidates)// 判断 List/Set 中的每个元素是否唯一。即 List/Set 中不存在重复元素boolean hasUniqueObject(Collection&lt;?&gt; collection) 集合操作工具 12345678910111213141516// 将 Array 中的元素都添加到 List/Set 中&lt;E&gt; void mergeArrayIntoCollection(Object array, Collection&lt;E&gt; collection)// 将 Properties 中的键值对都添加到 Map 中&lt;K,V&gt; void mergePropertiesIntoMap(Properties props, Map&lt;K,V&gt; map)// 返回 List 中最后一个元素&lt;T&gt; T lastElement(List&lt;T&gt; list)// 返回 Set 中最后一个元素&lt;T&gt; T lastElement(Set&lt;T&gt; set)// 返回参数 candidates 中第一个存在于参数 source 中的元素&lt;E&gt; E findFirstMatch(Collection&lt;?&gt; source, Collection&lt;E&gt; candidates)// 返回 List/Set 中指定类型的元素。&lt;T&gt; T findValueOfType(Collection&lt;?&gt; collection, Class&lt;T&gt; type)// 返回 List/Set 中指定类型的元素。如果第一种类型未找到，则查找第二种类型，以此类推Object findValueOfType(Collection&lt;?&gt; collection, Class&lt;?&gt;[] types)// 返回 List/Set 中元素的类型Class&lt;?&gt; findCommonElementType(Collection&lt;?&gt; collection) 文件、资源、IO 流FileCopyUtils 输入 123456// 从文件中读入到字节数组中byte[] copyToByteArray(File in)// 从输入流中读入到字节数组中byte[] copyToByteArray(InputStream in)// 从输入流中读入到字符串中String copyToString(Reader in) 输出 123456789101112// 从字节数组到文件void copy(byte[] in, File out)// 从文件到文件int copy(File in, File out)// 从字节数组到输出流void copy(byte[] in, OutputStream out)// 从输入流到输出流int copy(InputStream in, OutputStream out)// 从输入流到输出流int copy(Reader in, Writer out)// 从字符串到输出流void copy(String in, Writer out) ResourceUtils 从资源路径获取文件 123456// 判断字符串是否是一个合法的 URL 字符串。static boolean isUrl(String resourceLocation)// 获取 URLstatic URL getURL(String resourceLocation)// 获取文件（在 JAR 包内无法正常使用，需要是一个独立的文件）static File getFile(String resourceLocation) Resource 1234567891011121314151617181920// 文件系统资源 D:\\...FileSystemResource// URL 资源，如 file://... http://...UrlResource// 类路径下的资源，classpth:...ClassPathResource// Web 容器上下文中的资源（jar 包、war 包）ServletContextResource// 判断资源是否存在boolean exists()// 从资源中获得 File 对象File getFile()// 从资源中获得 URI 对象URI getURI()// 从资源中获得 URI 对象URL getURL()// 获得资源的 InputStreamInputStream getInputStream()// 获得资源的描述信息String getDescription() StreamUtils 输入 1234void copy(byte[] in, OutputStream out)int copy(InputStream in, OutputStream out)void copy(String in, Charset charset, OutputStream out)long copyRange(InputStream in, OutputStream out, long start, long end) 2.输出 1234byte[] copyToByteArray(InputStream in)String copyToString(InputStream in, Charset charset)// 舍弃输入流中的内容int drain(InputStream in) 反射、AOPReflectionUtils 获取方法 123456789101112131415161718// 在类中查找指定方法Method findMethod(Class&lt;?&gt; clazz, String name)// 同上，额外提供方法参数类型作查找条件Method findMethod(Class&lt;?&gt; clazz, String name, Class&lt;?&gt;... paramTypes)// 获得类中所有方法，包括继承而来的Method[] getAllDeclaredMethods(Class&lt;?&gt; leafClass)// 在类中查找指定构造方法Constructor&lt;T&gt; accessibleConstructor(Class&lt;T&gt; clazz, Class&lt;?&gt;... parameterTypes)// 是否是 equals() 方法boolean isEqualsMethod(Method method)// 是否是 hashCode() 方法boolean isHashCodeMethod(Method method)// 是否是 toString() 方法boolean isToStringMethod(Method method)// 是否是从 Object 类继承而来的方法boolean isObjectMethod(Method method)// 检查一个方法是否声明抛出指定异常boolean declaresException(Method method, Class&lt;?&gt; exceptionType) 执行方法 12345678// 执行方法Object invokeMethod(Method method, Object target)// 同上，提供方法参数Object invokeMethod(Method method, Object target, Object... args)// 取消 Java 权限检查。以便后续执行该私有方法void makeAccessible(Method method)// 取消 Java 权限检查。以便后续执行私有构造方法void makeAccessible(Constructor&lt;?&gt; ctor) 获取字段 123456// 在类中查找指定属性Field findField(Class&lt;?&gt; clazz, String name)// 同上，多提供了属性的类型Field findField(Class&lt;?&gt; clazz, String name, Class&lt;?&gt; type)// 是否为一个 \"public static final\" 属性boolean isPublicStaticFinal(Field field) 设置字段 123456789101112131415// 获取 target 对象的 field 属性值Object getField(Field field, Object target)// 设置 target 对象的 field 属性值，值为 valuevoid setField(Field field, Object target, Object value)// 同类对象属性对等赋值void shallowCopyFieldState(Object src, Object dest)// 取消 Java 的权限控制检查。以便后续读写该私有属性void makeAccessible(Field field)// 对类的每个属性执行 callbackvoid doWithFields(Class&lt;?&gt; clazz, ReflectionUtils.FieldCallback fc)// 同上，多了个属性过滤功能。void doWithFields(Class&lt;?&gt; clazz, ReflectionUtils.FieldCallback fc, ReflectionUtils.FieldFilter ff)// 同上，但不包括继承而来的属性void doWithLocalFields(Class&lt;?&gt; clazz, ReflectionUtils.FieldCallback fc) AopUtils 判断代理类型 123456// 判断是不是 Spring 代理对象boolean isAopProxy()// 判断是不是 jdk 动态代理对象isJdkDynamicProxy()// 判断是不是 CGLIB 代理对象boolean isCglibProxy() 获取被代理对象的 class 12// 获取被代理的目标 classClass&lt;?&gt; getTargetClass() AopContext 获取当前对象的代理对象 1Object currentProxy()","categories":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/categories/spring/"},{"name":"springboot","slug":"spring/springboot","permalink":"http://yoursite.com/categories/spring/springboot/"},{"name":"java","slug":"spring/springboot/java","permalink":"http://yoursite.com/categories/spring/springboot/java/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"title":"Spring MVC 请求处理过程","slug":"Spring-MVC-请求处理过程","date":"2021-09-08T08:03:11.000Z","updated":"2021-09-08T08:45:50.342Z","comments":true,"path":"2021/09/08/Spring-MVC-请求处理过程/","link":"","permalink":"http://yoursite.com/2021/09/08/Spring-MVC-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/","excerpt":"","text":"九大组件SpringMVC几乎所有的功能都由九大组件来完成，所以明白九大组件的作用，对于学习SpringMVC来说非常重要。 1234567891011121314151617181920212223242526/** 文件上传解析器 */private MultipartResolver multipartResolver;/** 区域解析器，用于国际化 */private LocaleResolver localeResolver;/** 主题解析器 */private ThemeResolver themeResolver;/** Handler映射信息 */private List&lt;HandlerMapping&gt; handlerMappings;/** Handler适配器*/private List&lt;HandlerAdapter&gt; handlerAdapters;/** Handler执行异常解析器 */private List&lt;HandlerExceptionResolver&gt; handlerExceptionResolvers;/** 请求到视图的转换器 */private RequestToViewNameTranslator viewNameTranslator;/** SpringMVC允许重定向时携带参数，存在session中，用完就销毁，所以叫FlashMap */private FlashMapManager flashMapManager;/** 视图解析器 */private List&lt;ViewResolver&gt; viewResolvers; HandlerMapping：Handler映射信息，根据请求携带的url信息查找处理器（Handler）。每个请求都需要对应的Handler处理。 HandlerAdapter：Handler适配器，SpringMVC没有直接调用处理器（Handler），而是通过HandlerAdapter来调用，主要是为了统一Handler的调用方式 ViewResolver：视图解析器，用来将字符串类型的视图名称解析为View类型的视图。ViewResolver需要找到渲染所用的模板和所用的技术（也就是视图的类型）进行渲染，具体的渲染过程则交由不同的视图自己完成。 MultipartResolver：文件上传解析器，主要用来处理文件上传请求 HandlerExceptionResolver：Handler执行异常解析器，用来对异常进行统一处理 RequestToViewNameTranslator：请求到视图的转换器 LocaleResolver：区域解析器，用于支持国际化 FlashMapManager：SpringMVC允许重定向时携带参数，存在session中，用完就销毁，所以叫FlashMap ThemeResolver：主题解析器，用于支持不同的主题 九大组件中最重的的前三个，HandlerMapping、HandlerAdapter和ViewResolver，因为这是阅读源码时，避不开的三个组件。 调试准备 搭建一个基本的Spring web项目 Controller部分 12345678910111213141516171819202122232425@Controllerpublic class IndexController &#123; @RequestMapping(\"/index/home\") public String home(String id, Student student, @RequestParam(\"code\") String code) &#123; System.out.println(student.getName()); return \"index\"; &#125; @ResponseBody @RequestMapping(\"/index/list\") public String list() &#123; return \"success\"; &#125;&#125;Entity部分public class Student &#123; private String name; private Integer gender; // getter、setter&#125; 核心方法我们都知道，SpringMVC有一个用来分发请求的前端控制器DispatcherServlet，其中用来处理请求的方法就是doService，该方法定义如下 doService 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Exposes the DispatcherServlet-specific request attributes and delegates to &#123;@link #doDispatch&#125; * for the actual dispatching. */@Overrideprotected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; logRequest(request); // Keep a snapshot of the request attributes in case of an include, // to be able to restore the original attributes after the include. Map&lt;String, Object&gt; attributesSnapshot = null; if (WebUtils.isIncludeRequest(request)) &#123; attributesSnapshot = new HashMap&lt;&gt;(); Enumeration&lt;?&gt; attrNames = request.getAttributeNames(); while (attrNames.hasMoreElements()) &#123; String attrName = (String) attrNames.nextElement(); if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123; attributesSnapshot.put(attrName, request.getAttribute(attrName)); &#125; &#125; &#125; // Make framework objects available to handlers and view objects. request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext()); request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver); request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver); request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource()); if (this.flashMapManager != null) &#123; FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response); if (inputFlashMap != null) &#123; request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap)); &#125; request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap()); request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager); &#125; try &#123; // 真正执行的方法 doDispatch(request, response); &#125; finally &#123; if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123; // Restore the original attribute snapshot, in case of an include. if (attributesSnapshot != null) &#123; restoreAttributesAfterInclude(request, attributesSnapshot); &#125; &#125; &#125;&#125; doDispatchdoDispatch是doService中真正用来处理请求的方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** * 实际处理请求的方法 */protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; // 校验是否是文件上传请求 processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // Determine handler for the current request. // 为当前请求找到一个合适的处理器（Handler） // 返回值是一个HandlerExecutionChain，也就是处理器执行链 mappedHandler = getHandler(processedRequest); if (mappedHandler == null) &#123; noHandlerFound(processedRequest, response); return; &#125; // Determine handler adapter for the current request. // 根据HandlerExecutionChain携带的Handler找到合适的HandlerAdapter HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler. // 处理GET请求的缓存 String method = request.getMethod(); boolean isGet = \"GET\".equals(method); if (isGet || \"HEAD\".equals(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; // 执行拦截器的preHandle方法 if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; // Actually invoke the handler. // 利用HandlerAdapter来执行Handler里对应的处理方法 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; // 如果没有设置视图，则应用默认的视图名 applyDefaultViewName(processedRequest, mv); // 执行拦截器的postHandle方法 mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; catch (Exception ex) &#123; dispatchException = ex; &#125; catch (Throwable err) &#123; // As of 4.3, we're processing Errors thrown from handler methods as well, // making them available for @ExceptionHandler methods and other scenarios. dispatchException = new NestedServletException(\"Handler dispatch failed\", err); &#125; // 根据ModelAndView对象解析视图 processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; catch (Exception ex) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, ex); &#125; catch (Throwable err) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(\"Handler processing failed\", err)); &#125; finally &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; // Instead of postHandle and afterCompletion if (mappedHandler != null) &#123; mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); &#125; &#125; else &#123; // Clean up any resources used by a multipart request. if (multipartRequestParsed) &#123; cleanupMultipart(processedRequest); &#125; &#125; &#125;&#125; 该方法就是SpringMVC处理请求的整体流程，其中涉及到几个重要的方法。 getHandler该方法定义如下 12345678910111213141516/** * Return the HandlerExecutionChain for this request. * 为这个request返回一个HandlerExecutionChain */@Nullableprotected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; if (this.handlerMappings != null) &#123; for (HandlerMapping mapping : this.handlerMappings) &#123; HandlerExecutionChain handler = mapping.getHandler(request); if (handler != null) &#123; return handler; &#125; &#125; &#125; return null;&#125; 调试信息如下 根据调试信息可以看出，getHandler方法主要是从List&lt;HandlerMapping&gt; handlerMappings集合中遍历查找一个合适的处理器（Handler），返回的结果是一个HandlerExecutionChain。然后再根据HandlerExecutionChain里携带的Handler去获取HandlerAdapter。 getHandlerAdaptergetHandlerAdapter方法定义如下 12345678910111213141516/** * Return the HandlerAdapter for this handler object. * @param handler the handler object to find an adapter for * @throws ServletException if no HandlerAdapter can be found for the handler. This is a fatal error. */ protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException &#123; if (this.handlerAdapters != null) &#123; for (HandlerAdapter adapter : this.handlerAdapters) &#123; if (adapter.supports(handler)) &#123; return adapter; &#125; &#125; &#125; throw new ServletException(\"No adapter for handler [\" + handler + \"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler\"); &#125; 同样getHandlerAdapter方法主要是从List&lt;HandlerAdapter&gt; handlerAdapters集合中遍历查找一个合适的处理器适配器（HandlerAdapter），返回的结果是一个HandlerAdapter。 可以看到此处HandlerAdapter真正的实现类是RequestMappingHandlerAdapter。 processDispatchResultprocessDispatchResult方法主要根据方法执行完成后封装的ModelAndView，转发到对应页面，定义如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Handle the result of handler selection and handler invocation, which is * either a ModelAndView or an Exception to be resolved to a ModelAndView. */private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv, @Nullable Exception exception) throws Exception &#123; boolean errorView = false; if (exception != null) &#123; if (exception instanceof ModelAndViewDefiningException) &#123; logger.debug(\"ModelAndViewDefiningException encountered\", exception); mv = ((ModelAndViewDefiningException) exception).getModelAndView(); &#125; else &#123; Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null); mv = processHandlerException(request, response, handler, exception); errorView = (mv != null); &#125; &#125; // Did the handler return a view to render? if (mv != null &amp;&amp; !mv.wasCleared()) &#123; // 主要调用该方法渲染视图 render(mv, request, response); if (errorView) &#123; WebUtils.clearErrorRequestAttributes(request); &#125; &#125; else &#123; if (logger.isTraceEnabled()) &#123; logger.trace(\"No view rendering, null ModelAndView returned.\"); &#125; &#125; if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123; // Concurrent handling started during a forward return; &#125; if (mappedHandler != null) &#123; // Exception (if any) is already handled.. mappedHandler.triggerAfterCompletion(request, response, null); &#125;&#125; renderrender方法定义如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Render the given ModelAndView. * &lt;p&gt;This is the last stage in handling a request. It may involve resolving the view by name. * @param mv the ModelAndView to render * @param request current HTTP servlet request * @param response current HTTP servlet response * @throws ServletException if view is missing or cannot be resolved * @throws Exception if there's a problem rendering the view */protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; // Determine locale for request and apply it to the response. Locale locale = (this.localeResolver != null ? this.localeResolver.resolveLocale(request) : request.getLocale()); response.setLocale(locale); View view; String viewName = mv.getViewName(); if (viewName != null) &#123; // We need to resolve the view name. // 根据给定的视图名称，解析获取View对象 view = resolveViewName(viewName, mv.getModelInternal(), locale, request); if (view == null) &#123; throw new ServletException(\"Could not resolve view with name '\" + mv.getViewName() + \"' in servlet with name '\" + getServletName() + \"'\"); &#125; &#125; else &#123; // No need to lookup: the ModelAndView object contains the actual View object. view = mv.getView(); if (view == null) &#123; throw new ServletException(\"ModelAndView [\" + mv + \"] neither contains a view name nor a \" + \"View object in servlet with name '\" + getServletName() + \"'\"); &#125; &#125; // Delegate to the View object for rendering. if (logger.isTraceEnabled()) &#123; logger.trace(\"Rendering view [\" + view + \"] \"); &#125; try &#123; if (mv.getStatus() != null) &#123; response.setStatus(mv.getStatus().value()); &#125; view.render(mv.getModelInternal(), request, response); &#125; catch (Exception ex) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Error rendering view [\" + view + \"]\", ex); &#125; throw ex; &#125;&#125; resolveViewNameresolveViewName方法定义如下 1234567891011121314@Nullableprotected View resolveViewName(String viewName, @Nullable Map&lt;String, Object&gt; model, Locale locale, HttpServletRequest request) throws Exception &#123; if (this.viewResolvers != null) &#123; for (ViewResolver viewResolver : this.viewResolvers) &#123; View view = viewResolver.resolveViewName(viewName, locale); if (view != null) &#123; return view; &#125; &#125; &#125; return null;&#125; 根据调试信息可以看到真正解析视图的ViewResolver的是InternalResourceViewResolver类，也就是我们经常配置的一项类型 12345&lt;!-- 定义视图文件解析 --&gt;&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/views/\" /&gt; &lt;property name=\"suffix\" value=\".html\" /&gt;&lt;/bean&gt; 至此我们就得到了SpringMVC处理请求的完整逻辑 但是，有两个重要的问题没有解决，那就是：参数绑定和返回值处理。 &gt; 因为在编写Controller里面的方法的时候，各种类型的参数都有，SpringMVC是怎么处理不同类型的参数的呢？&gt; SpringMVC处理请求完成后，一定会返回ModelAndView吗，如果加了@ResponseBody注解呢？ 参数绑定在整个流程中，还有一个最重要的方法，那就是真正执行handler的方法，参数的绑定和返回值的处理都在这个方法里，也就是 12// Actually invoke the handler.mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); handlehandle方法的作用是根据请求参数，执行真正的处理方法，并且返回合适的ModelAndView对象，也有可能返回null。该方法定义如下在AbstractHandlerMethodAdapter类中 12345678910/** * This implementation expects the handler to be an &#123;@link HandlerMethod&#125;. */@Override@Nullablepublic final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return handleInternal(request, response, (HandlerMethod) handler);&#125; 可以看到这个方法实现只有一行代码 handleInternal继续深入handleInternal方法 123456789101112131415161718192021222324252627282930313233343536373839@Overrideprotected ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; ModelAndView mav; // 校验指定的请求以获取受支持的方法类型（GET、POST等）和所需的session checkRequest(request); // Execute invokeHandlerMethod in synchronized block if required. if (this.synchronizeOnSession) &#123; HttpSession session = request.getSession(false); if (session != null) &#123; Object mutex = WebUtils.getSessionMutex(session); synchronized (mutex) &#123; mav = invokeHandlerMethod(request, response, handlerMethod); &#125; &#125; else &#123; // No HttpSession available -&gt; no mutex necessary mav = invokeHandlerMethod(request, response, handlerMethod); &#125; &#125; else &#123; // No synchronization on session demanded at all... // 真正执行handler的方法 mav = invokeHandlerMethod(request, response, handlerMethod); &#125; if (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123; if (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123; applyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers); &#125; else &#123; prepareResponse(response); &#125; &#125; return mav;&#125; invokeHandlerMethod继续深入invokeHandlerMethod方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * Invoke the &#123;@link RequestMapping&#125; handler method preparing a &#123;@link ModelAndView&#125; * if view resolution is required. * 执行@RequestMapping标注的handler方法，如果需要解析视图就准备一个ModelAndView */@Nullableprotected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; ServletWebRequest webRequest = new ServletWebRequest(request, response); try &#123; WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod); ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory); // HandlerMethod接口封装执行方法的信息，提供对方法参数，方法返回值，方法注释等的便捷访问。 ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod); if (this.argumentResolvers != null) &#123; invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers); &#125; if (this.returnValueHandlers != null) &#123; invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers); &#125; invocableMethod.setDataBinderFactory(binderFactory); invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer); // ModelAndViewContainer可以看做ModelAndView的上下文容器，关联着Model和View的信息 ModelAndViewContainer mavContainer = new ModelAndViewContainer(); mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request)); modelFactory.initModel(webRequest, mavContainer, invocableMethod); mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect); AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response); asyncWebRequest.setTimeout(this.asyncRequestTimeout); WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); asyncManager.setTaskExecutor(this.taskExecutor); asyncManager.setAsyncWebRequest(asyncWebRequest); asyncManager.registerCallableInterceptors(this.callableInterceptors); asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors); if (asyncManager.hasConcurrentResult()) &#123; Object result = asyncManager.getConcurrentResult(); mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0]; asyncManager.clearConcurrentResult(); LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123; String formatted = LogFormatUtils.formatValue(result, !traceOn); return \"Resume with async result [\" + formatted + \"]\"; &#125;); invocableMethod = invocableMethod.wrapConcurrentResult(result); &#125; // 真正执行Handler的方法 invocableMethod.invokeAndHandle(webRequest, mavContainer); if (asyncManager.isConcurrentHandlingStarted()) &#123; return null; &#125; // 获取ModelAndeView对象 return getModelAndView(mavContainer, modelFactory, webRequest); &#125; finally &#123; webRequest.requestCompleted(); &#125;&#125; invokeAndHandle invokeAndHandle方法的作用是执行并处理真正响应请求的方法，该方法定义如下 123456789101112131415161718192021222324252627282930313233343536373839/** * Invoke the method and handle the return value through one of the * configured &#123;@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers&#125;. * @param webRequest the current request * @param mavContainer the ModelAndViewContainer for this request * @param providedArgs \"given\" arguments matched by type (not resolved) */public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; // 执行handler的方法 Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs); setResponseStatus(webRequest); if (returnValue == null) &#123; if (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) &#123; disableContentCachingIfNecessary(webRequest); mavContainer.setRequestHandled(true); return; &#125; &#125; else if (StringUtils.hasText(getResponseStatusReason())) &#123; mavContainer.setRequestHandled(true); return; &#125; mavContainer.setRequestHandled(false); Assert.state(this.returnValueHandlers != null, \"No return value handlers\"); try &#123; this.returnValueHandlers.handleReturnValue( returnValue, getReturnValueType(returnValue), mavContainer, webRequest); &#125; catch (Exception ex) &#123; if (logger.isTraceEnabled()) &#123; logger.trace(formatErrorForReturnValue(returnValue), ex); &#125; throw ex; &#125;&#125; invokeForRequest12345678910111213141516171819202122232425262728293031/** * Invoke the method after resolving its argument values in the context of the given request. * &lt;p&gt;Argument values are commonly resolved through * &#123;@link HandlerMethodArgumentResolver HandlerMethodArgumentResolvers&#125;. * The &#123;@code providedArgs&#125; parameter however may supply argument values to be used directly, * i.e. without argument resolution. Examples of provided argument values include a * &#123;@link WebDataBinder&#125;, a &#123;@link SessionStatus&#125;, or a thrown exception instance. * Provided argument values are checked before argument resolvers. * &lt;p&gt;Delegates to &#123;@link #getMethodArgumentValues&#125; and calls &#123;@link #doInvoke&#125; with the * resolved arguments. * @param request the current request * @param mavContainer the ModelAndViewContainer for this request * @param providedArgs \"given\" arguments matched by type, not resolved * @return the raw value returned by the invoked method * @throws Exception raised if no suitable argument resolver can be found, * or if the method raised an exception * @see #getMethodArgumentValues * @see #doInvoke */@Nullablepublic Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; // 获取参数 Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs); if (logger.isTraceEnabled()) &#123; logger.trace(\"Arguments: \" + Arrays.toString(args)); &#125; // 执行 return doInvoke(args);&#125; 真正的执行无非就是通过反射invoke，所以更重要的是参数是如何绑定的，详情就在getMethodArgumentValues方法 getMethodArgumentValuesgetMethodArgumentValues方法用于从request请求中获取真正的参数，返回的是Object数组，该方法定义如下 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Get the method argument values for the current request, checking the provided * argument values and falling back to the configured argument resolvers. * &lt;p&gt;The resulting array will be passed into &#123;@link #doInvoke&#125;. * @since 5.1.2 */protected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; // 获取方法上所有的参数 MethodParameter[] parameters = getMethodParameters(); if (ObjectUtils.isEmpty(parameters)) &#123; return EMPTY_ARGS; &#125; Object[] args = new Object[parameters.length]; for (int i = 0; i &lt; parameters.length; i++) &#123; MethodParameter parameter = parameters[i]; parameter.initParameterNameDiscovery(this.parameterNameDiscoverer); args[i] = findProvidedArgument(parameter, providedArgs); if (args[i] != null) &#123; continue; &#125; if (!this.resolvers.supportsParameter(parameter)) &#123; throw new IllegalStateException(formatArgumentError(parameter, \"No suitable resolver\")); &#125; try &#123; args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory); &#125; catch (Exception ex) &#123; // Leave stack trace for later, exception may actually be resolved and handled... if (logger.isDebugEnabled()) &#123; String exMsg = ex.getMessage(); if (exMsg != null &amp;&amp; !exMsg.contains(parameter.getExecutable().toGenericString())) &#123; logger.debug(formatArgumentError(parameter, exMsg)); &#125; &#125; throw ex; &#125; &#125; return args;&#125; 根据调试信息可以看到，用来处理请求参数的类是HandlerMethodArgumentResolver接口的实现类HandlerMethodArgumentResolverComposite，此时正在处理的参数是一个Student对象，并且已经把值注绑定了，也就是说真正执行绑定的是方法resolveArgument resolveArgumentresolveArgument是真正执行绑定的的方法 1234567891011121314151617181920/** * Iterate over registered * &#123;@link HandlerMethodArgumentResolver HandlerMethodArgumentResolvers&#125; * and invoke the one that supports it. * @throws IllegalArgumentException if no suitable argument resolver is found */@Override@Nullablepublic Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123; // 获取合适的参数解析器 HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter); if (resolver == null) &#123; throw new IllegalArgumentException(\"Unsupported parameter type [\" + parameter.getParameterType().getName() + \"]. supportsParameter should be called first.\"); &#125; // 执行参数绑定 return resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);&#125; getArgumentResolvergetArgumentResolver该方法用于执行参数的绑定，定义如下 123456789101112131415161718/** * Find a registered &#123;@link HandlerMethodArgumentResolver&#125; that supports * the given method parameter. */@Nullableprivate HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) &#123; HandlerMethodArgumentResolver result = this.argumentResolverCache.get(parameter); if (result == null) &#123; for (HandlerMethodArgumentResolver resolver : this.argumentResolvers) &#123; if (resolver.supportsParameter(parameter)) &#123; result = resolver; this.argumentResolverCache.put(parameter, result); break; &#125; &#125; &#125; return result;&#125; 该方法的逻辑就是先从argumentResolver缓存中找到能够执行参数绑定的HandlerMethodArgumentResolver，如果找不到就从HandlerMethodArgumentResolver找，SpringMVC支持的HandlerMethodArgumentResolver一共有26种，用来解析各种类型的参数 RequestParamMethodArgumentResolver：处理普通参数（基本类型、包装类型、String），不管加不加@RequestParam注解 ServletModelAttributeMethodProcessor：处理POJO类型的参数，比如自定义的Student对象 RequestResponseBodyMethodProcessor：处理@RequestBody注解类型的参数 resolveArgument由于不同类型的参数有不同的HandlerMethodArgumentResolver来处理，此处选取POJO类型参数的注入实现，对应的参数解析类是ModelAttributeMethodProcessor，其中resolveArgument方法用来解析（绑定）参数方法定义如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * Resolve the argument from the model or if not found instantiate it with * its default if it is available. The model attribute is then populated * with request values via data binding and optionally validated * if &#123;@code @java.validation.Valid&#125; is present on the argument. * @throws BindException if data binding and validation result in an error * and the next method parameter is not of type &#123;@link Errors&#125; * @throws Exception if WebDataBinder initialization fails */@Override@Nullablepublic final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123; Assert.state(mavContainer != null, \"ModelAttributeMethodProcessor requires ModelAndViewContainer\"); Assert.state(binderFactory != null, \"ModelAttributeMethodProcessor requires WebDataBinderFactory\"); // 获取参数名 String name = ModelFactory.getNameForParameter(parameter); // 获取参数上的ModelAttribute注解 ModelAttribute ann = parameter.getParameterAnnotation(ModelAttribute.class); if (ann != null) &#123; mavContainer.setBinding(name, ann.binding()); &#125; Object attribute = null; BindingResult bindingResult = null; if (mavContainer.containsAttribute(name)) &#123; attribute = mavContainer.getModel().get(name); &#125; else &#123; // Create attribute instance try &#123; // 创建参数类型的实例（未注入值），底层就是通过反射调用构造方法 attribute = createAttribute(name, parameter, binderFactory, webRequest); &#125; catch (BindException ex) &#123; if (isBindExceptionRequired(parameter)) &#123; // No BindingResult parameter -&gt; fail with BindException throw ex; &#125; // Otherwise, expose null/empty value and associated BindingResult if (parameter.getParameterType() == Optional.class) &#123; attribute = Optional.empty(); &#125; bindingResult = ex.getBindingResult(); &#125; &#125; if (bindingResult == null) &#123; // Bean property binding and validation; // skipped in case of binding failure on construction. WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name); if (binder.getTarget() != null) &#123; if (!mavContainer.isBindingDisabled(name)) &#123; // 真正执行绑定（值注入）的方法 bindRequestParameters(binder, webRequest); &#125; validateIfApplicable(binder, parameter); if (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123; throw new BindException(binder.getBindingResult()); &#125; &#125; // Value type adaptation, also covering java.util.Optional if (!parameter.getParameterType().isInstance(attribute)) &#123; attribute = binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter); &#125; bindingResult = binder.getBindingResult(); &#125; // Add resolved attribute and BindingResult at the end of the model Map&lt;String, Object&gt; bindingResultModel = bindingResult.getModel(); mavContainer.removeAttributes(bindingResultModel); mavContainer.addAllAttributes(bindingResultModel); return attribute;&#125; 根据调试信息也可以看到bindRequestParameters(binder, webRequest)执行完成之后，POJO类型的参数已经完成了绑定。 bindRequestParameters12345678910111213/** * This implementation downcasts &#123;@link WebDataBinder&#125; to * &#123;@link ServletRequestDataBinder&#125; before binding. * @see ServletRequestDataBinderFactory */@Overrideprotected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) &#123; ServletRequest servletRequest = request.getNativeRequest(ServletRequest.class); Assert.state(servletRequest != null, \"No ServletRequest\"); ServletRequestDataBinder servletBinder = (ServletRequestDataBinder) binder; // 执行绑定的方法 servletBinder.bind(servletRequest);&#125; bind继续深入bind方法 12345678910111213public void bind(ServletRequest request) &#123; // 获取所有参数的键值对 MutablePropertyValues mpvs = new ServletRequestParameterPropertyValues(request); // 处理文件上传请求 MultipartRequest multipartRequest = WebUtils.getNativeRequest(request, MultipartRequest.class); if (multipartRequest != null) &#123; bindMultipart(multipartRequest.getMultiFileMap(), mpvs); &#125; // 把url中携带的参数也加入到MutablePropertyValues addBindValues(mpvs, request); // 执行绑定（注入值） doBind(mpvs);&#125; 由于调用层次过深，所以无法一步步列出下面的步骤，doBind方法的原理还是通过调用POJO对象里的setter方法设置值，可以查看最终的调试信息 根据调试信息可以看到，最终执行的还是POJO对象的setter方法，具体执行的类是BeanWrapperImpl。 了解了参数的绑定，再来看返回值的处理。 返回值处理invokeAndHandle回到源码invokeAndHandle方法处（ServletInvocableHandlerMethod类中），该方法定义如下 123456789101112131415161718192021222324252627282930313233343536373839/** * Invoke the method and handle the return value through one of the * configured &#123;@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers&#125;. * @param webRequest the current request * @param mavContainer the ModelAndViewContainer for this request * @param providedArgs \"given\" arguments matched by type (not resolved) */public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs); setResponseStatus(webRequest); if (returnValue == null) &#123; if (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) &#123; disableContentCachingIfNecessary(webRequest); mavContainer.setRequestHandled(true); return; &#125; &#125; else if (StringUtils.hasText(getResponseStatusReason())) &#123; mavContainer.setRequestHandled(true); return; &#125; mavContainer.setRequestHandled(false); Assert.state(this.returnValueHandlers != null, \"No return value handlers\"); try &#123; // 真正处理不同类型返回值的方法 this.returnValueHandlers.handleReturnValue( returnValue, getReturnValueType(returnValue), mavContainer, webRequest); &#125; catch (Exception ex) &#123; if (logger.isTraceEnabled()) &#123; logger.trace(formatErrorForReturnValue(returnValue), ex); &#125; throw ex; &#125;&#125; 真正处理不同类型的返回值的方法是handleReturnValue方法 handleReturnValue12345678910111213141516/** * Iterate over registered &#123;@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers&#125; and invoke the one that supports it. * @throws IllegalStateException if no suitable &#123;@link HandlerMethodReturnValueHandler&#125; is found. */@Overridepublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception &#123; // 根据返回值个返回值类型选取合适的HandlerMethodReturnValueHandler HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType); if (handler == null) &#123; throw new IllegalArgumentException(\"Unknown return value type: \" + returnType.getParameterType().getName()); &#125; // 真正的处理返回值 handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);&#125; selectHandler12345678910111213@Nullableprivate HandlerMethodReturnValueHandler selectHandler(@Nullable Object value, MethodParameter returnType) &#123; boolean isAsyncValue = isAsyncReturnValue(value, returnType); for (HandlerMethodReturnValueHandler handler : this.returnValueHandlers) &#123; if (isAsyncValue &amp;&amp; !(handler instanceof AsyncHandlerMethodReturnValueHandler)) &#123; continue; &#125; if (handler.supportsReturnType(returnType)) &#123; return handler; &#125; &#125; return null;&#125; 根据调试信息可以看到，SpringMVC为返回值提供了15个HandlerMethodReturnValueHandler的实现了来处理不同类型的返回值。 事实上，用来处理@ResponseBody类型的是RequestResponseBodyMethodProcessor。 如果对前文参数绑定还有印象的话，会发现@RequestBody类型参数绑定也是用的这个类。 继续跟进RequestResponseBodyMethodProcessor类的handleReturnValue方法 handleReturnValueRequestResponseBodyMethodProcessor类的handleReturnValue方法定义如下 这里设置了一个非常重要的属性requestHandled，这个属性关系到是否需要返回ModelAndView对象 1234567891011121314151617@Overridepublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException &#123; // 设置该请求是否已在处理程序中完全处理，例如@ResponseBody方法不需要视图解析器，此处就可以设置为true。 // 当控制器方法声明类型为ServletResponse或OutputStream的参数时，也可以设置此标志为true。 // 这个属性设置成true之后，上层getModelAndView获取ModelAndView时会返回Null，因为不需要视图。 // 默认值为false mavContainer.setRequestHandled(true); ServletServerHttpRequest inputMessage = createInputMessage(webRequest); ServletServerHttpResponse outputMessage = createOutputMessage(webRequest); // Try even with null return value. ResponseBodyAdvice could get involved. // 底层就是利用java.io.OutputStreamWriter类把返回值写到网络IO writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);&#125; 继续深入writeWithMessageConverters方法，一步步调试到最后，底层就是利用java.io.OutputStreamWriter类把返回值写到网络IO 由于handleReturnValue把requestHandled设置成了true，上层在调用getModelAndView方法时会返回null，表示该请求不需要视图。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"spring","slug":"java/spring","permalink":"http://yoursite.com/categories/java/spring/"},{"name":"springMVC","slug":"java/spring/springMVC","permalink":"http://yoursite.com/categories/java/spring/springMVC/"}],"tags":[{"name":"mvc","slug":"mvc","permalink":"http://yoursite.com/tags/mvc/"}]},{"title":"16 条 yyds 的代码规范","slug":"16-条-yyds-的代码规范","date":"2021-08-10T08:22:09.000Z","updated":"2023-06-25T01:55:29.801Z","comments":true,"path":"2021/08/10/16-条-yyds-的代码规范/","link":"","permalink":"http://yoursite.com/2021/08/10/16-%E6%9D%A1-yyds-%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/","excerpt":"","text":"MyBatis 不要为了多个查询条件而写 1 = 1 当遇到多个查询条件，使用where 1=1 可以很方便的解决我们的问题，但是这样很可能会造成非常大的性能损失，因为添加了 “where 1=1 ”的过滤条件之后，数据库系统就无法使用索引等查询优化策略，数据库系统将会被迫对每行数据进行扫描（即全表扫描） 以比较此行是否满足过滤条件，当表中的数据量较大时查询速度会非常慢；此外，还会存在SQL 注入的风险。 反例： 123456789&lt;select id=\"queryBookInfo\" parameterType=\"com.tjt.platform.entity.BookInfo\" resultType=\"java.lang.Integer\"&gt; select count(*) from t_rule_BookInfo t where 1=1&lt;if test=\"title !=null and title !='' \"&gt; AND title = #&#123;title&#125;&lt;/if&gt;&lt;if test=\"author !=null and author !='' \"&gt; AND author = #&#123;author&#125;&lt;/if&gt;&lt;/select&gt; 正例： 1234567891011&lt;select id=\"queryBookInfo\" parameterType=\"com.tjt.platform.entity.BookInfo\" resultType=\"java.lang.Integer\"&gt; select count(*) from t_rule_BookInfo t&lt;where&gt;&lt;if test=\"title !=null and title !='' \"&gt; title = #&#123;title&#125;&lt;/if&gt;&lt;if test=\"author !=null and author !='' \"&gt; AND author = #&#123;author&#125;&lt;/if&gt;&lt;/where&gt;&lt;/select&gt; UPDATE 操作也一样，可以用标记代替 1=1。 迭代entrySet() 获取Map 的key 和value 当循环中只需要获取Map 的主键key时，迭代keySet() 是正确的；但是，当需要主键key 和取值value 时，迭代entrySet() 才是更高效的做法，其比先迭代keySet() 后再去通过get 取值性能更佳。 反例： 12345//Map 获取value 反例:HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();for (String key : map.keySet())&#123; String value = map.get(key);&#125; 正例： 123456//Map 获取key &amp; value 正例:HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();for (Map.Entry&lt;String,String&gt; entry : map.entrySet())&#123; String key = entry.getKey(); String value = entry.getValue();&#125; 使用Collection.isEmpty() 检测空 使用Collection.size() 来检测是否为空在逻辑上没有问题，但是使用Collection.isEmpty() 使得代码更易读，并且可以获得更好的性能；除此之外，任何Collection.isEmpty() 实现的时间复杂度都是O(1) ，不需要多次循环遍历，但是某些通过Collection.size() 方法实现的时间复杂度可能是O(n)，或者使用第三方工具类如：Hutool 提供的集合检查工具。 反例： 1234LinkedList&lt;Object&gt; collection = new LinkedList&lt;&gt;();if (collection.size() == 0)&#123; System.out.println(\"collection is empty.\");&#125; 正例： 12345678910LinkedList&lt;Object&gt; collection = new LinkedList&lt;&gt;();if (collection.isEmpty())&#123; System.out.println(\"collection is empty.\");&#125;//检测是否为null 可以使用CollectionUtils.isEmpty()if (CollectionUtils.isEmpty(collection))&#123; System.out.println(\"collection is null.\");&#125; 初始化集合时尽量指定其大小 尽量在初始化时指定集合的大小，能有效减少集合的扩容次数，因为集合每次扩容的时间复杂度很可能时O(n)，耗费时间和性能。 反例： 123456//初始化list，往list 中添加元素反例：int[] arr = new int[]&#123;1,2,3,4&#125;;List&lt;Integer&gt; list = new ArrayList&lt;&gt;();for (int i : arr)&#123; list.add(i);&#125; 正例： 1234567//初始化list，往list 中添加元素正例：int[] arr = new int[]&#123;1,2,3,4&#125;;//指定集合list 的容量大小List&lt;Integer&gt; list = new ArrayList&lt;&gt;(arr.length);for (int i : arr)&#123; list.add(i);&#125; 使用StringBuilder 拼接字符串 一般的字符串拼接在编译期Java 会对其进行优化，但是在循环中字符串的拼接Java 编译期无法执行优化，所以需要使用StringBuilder 进行替换。 反例： 123456//在循环中拼接字符串反例String str = \"\";for (int i = 0; i &lt; 10; i++)&#123; //在循环中字符串拼接Java 不会对其进行优化 str += i;&#125; 正例： 123456789//在循环中拼接字符串正例String str1 = \"Love\";String str2 = \"Courage\";String strConcat = str1 + str2; //Java 编译器会对该普通模式的字符串拼接进行优化StringBuilder sb = new StringBuilder();for (int i = 0; i &lt; 10; i++)&#123; //在循环中，Java 编译器无法进行优化，所以要手动使用StringBuilder sb.append(i);&#125; 若需频繁调用Collection.contains 方法则使用Set 在Java 集合类库中，List的contains 方法普遍时间复杂度为O(n)，若代码中需要频繁调用contains 方法查找数据则先将集合list 转换成HashSet 实现，将O(n) 的时间复杂度将为O(1)。 反例： 1234567//频繁调用Collection.contains() 反例List&lt;Object&gt; list = new ArrayList&lt;&gt;();for (int i = 0; i &lt;= Integer.MAX_VALUE; i++)&#123; //时间复杂度为O(n) if (list.contains(i)) System.out.println(\"list contains \"+ i);&#125; 正例: 123456789//频繁调用Collection.contains() 正例List&lt;Object&gt; list = new ArrayList&lt;&gt;();Set&lt;Object&gt; set = new HashSet&lt;&gt;();for (int i = 0; i &lt;= Integer.MAX_VALUE; i++)&#123; //时间复杂度为O(1) if (set.contains(i))&#123; System.out.println(\"list contains \"+ i); &#125;&#125; 使用静态代码块实现赋值静态成员变量 对于集合类型的静态成员变量，应该使用静态代码块赋值，而不是使用集合实现来赋值。 反例： 123456789101112131415//赋值静态成员变量反例private static Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;()&#123; &#123; map.put(\"Leo\",1); map.put(\"Family-loving\",2); map.put(\"Cold on the out side passionate on the inside\",3); &#125;&#125;;private static List&lt;String&gt; list = new ArrayList&lt;&gt;()&#123; &#123; list.add(\"Sagittarius\"); list.add(\"Charming\"); list.add(\"Perfectionist\"); &#125;&#125;; 正例： 1234567891011121314//赋值静态成员变量正例private static Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();static &#123; map.put(\"Leo\",1); map.put(\"Family-loving\",2); map.put(\"Cold on the out side passionate on the inside\",3);&#125;private static List&lt;String&gt; list = new ArrayList&lt;&gt;();static &#123; list.add(\"Sagittarius\"); list.add(\"Charming\"); list.add(\"Perfectionist\");&#125; 删除未使用的局部变量、方法参数、私有方法、字段和多余的括号。工具类中屏蔽构造函数 工具类是一堆静态字段和函数的集合，其不应该被实例化；但是，Java 为每个没有明确定义构造函数的类添加了一个隐式公有构造函数，为了避免不必要的实例化，应该显式定义私有构造函数来屏蔽这个隐式公有构造函数。 反例： 123456789public class PasswordUtils &#123;//工具类构造函数反例private static final Logger LOG = LoggerFactory.getLogger(PasswordUtils.class);public static final String DEFAULT_CRYPT_ALGO = \"PBEWithMD5AndDES\";public static String encryptPassword(String aPassword) throws IOException &#123; return new PasswordUtils(aPassword).encrypt();&#125; 正例： 123456789101112public class PasswordUtils &#123;//工具类构造函数正例private static final Logger LOG = LoggerFactory.getLogger(PasswordUtils.class);//定义私有构造函数来屏蔽这个隐式公有构造函数private PasswordUtils()&#123;&#125;public static final String DEFAULT_CRYPT_ALGO = \"PBEWithMD5AndDES\";public static String encryptPassword(String aPassword) throws IOException &#123; return new PasswordUtils(aPassword).encrypt();&#125; 删除多余的异常捕获并抛出 用catch 语句捕获异常后，若什么也不进行处理，就只是让异常重新抛出，这跟不捕获异常的效果一样，可以删除这块代码或添加别的处理。 反例： 123456789101112131415//多余异常反例private static String fileReader(String fileName)throws IOException&#123; try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) &#123; String line; StringBuilder builder = new StringBuilder(); while ((line = reader.readLine()) != null) &#123; builder.append(line); &#125; return builder.toString(); &#125; catch (Exception e) &#123; //仅仅是重复抛异常 未作任何处理 throw e; &#125;&#125; 正例： 12345678910111213141516//多余异常正例private static String fileReader(String fileName)throws IOException&#123; try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) &#123; String line; StringBuilder builder = new StringBuilder(); while ((line = reader.readLine()) != null) &#123; builder.append(line); &#125; return builder.toString(); //删除多余的抛异常，或增加其他处理： /*catch (Exception e) &#123; return \"fileReader exception\"; &#125;*/ &#125;&#125; 字符串转化使用String.valueOf(value) 代替 “ “ + value 把其它对象或类型转化为字符串时，使用String.valueOf(value) 比 “”+value 的效率更高。 反例： 1234//把其它对象或类型转化为字符串反例：int num = 520;// \"\" + valueString strLove = \"\" + num; 正例： 1234//把其它对象或类型转化为字符串正例：int num = 520;// String.valueOf() 效率更高String strLove = String.valueOf(num); 避免使用BigDecimal(double) BigDecimal(double) 存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。 反例： 12// BigDecimal 反例BigDecimal bigDecimal = new BigDecimal(0.11D); 正例： 12// BigDecimal 正例BigDecimal bigDecimal1 = bigDecimal.valueOf(0.11D); 返回空数组和集合而非 null 若程序运行返回null，需要调用方强制检测null，否则就会抛出空指针异常；返回空数组或空集合，有效地避免了调用方因为未检测null 而抛出空指针异常的情况，还可以删除调用方检测null 的语句使代码更简洁。 反例： 123456789101112//返回null 反例public static Result[] getResults() &#123; return null;&#125;public static List&lt;Result&gt; getResultList() &#123; return null;&#125;public static Map&lt;String, Result&gt; getResultMap() &#123; return null;&#125; 正例： 123456789101112//返回空数组和空集正例public static Result[] getResults() &#123; return new Result[0];&#125;public static List&lt;Result&gt; getResultList() &#123; return Collections.emptyList();&#125;public static Map&lt;String, Result&gt; getResultMap() &#123; return Collections.emptyMap();&#125; 优先使用常量或确定值调用equals 方法 对象的equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals 方法。 反例： 123456//调用 equals 方法反例private static boolean fileReader(String fileName)throws IOException&#123; // 可能抛空指针异常 return fileName.equals(\"Charming\");&#125; 正例： 123456789//调用 equals 方法正例private static boolean fileReader(String fileName)throws IOException&#123; // 使用常量或确定有值的对象来调用 equals 方法 return \"Charming\".equals(fileName); //或使用：java.util.Objects.equals() 方法 return Objects.equals(\"Charming\",fileName);&#125; 枚举的属性字段必须是私有且不可变 枚举通常被当做常量使用，如果枚举中存在公共属性字段或设置字段方法，那么这些枚举常量的属性很容易被修改；理想情况下，枚举中的属性字段是私有的，并在私有构造函数中赋值，没有对应的Setter 方法，最好加上final 修饰符。 反例： 123456789101112131415161718192021public enum SwitchStatus &#123; // 枚举的属性字段反例 DISABLED(0, \"禁用\"), ENABLED(1, \"启用\"); public int value; private String description; private SwitchStatus(int value, String description) &#123; this.value = value; this.description = description; &#125; public String getDescription() &#123; return description; &#125; public void setDescription(String description) &#123; this.description = description; &#125;&#125; 正例： 1234567891011121314151617181920212223public enum SwitchStatus &#123; // 枚举的属性字段正例 DISABLED(0, \"禁用\"), ENABLED(1, \"启用\"); // final 修饰 private final int value; private final String description; private SwitchStatus(int value, String description) &#123; this.value = value; this.description = description; &#125; // 没有Setter 方法 public int getValue() &#123; return value; &#125; public String getDescription() &#123; return description; &#125;&#125; String.split(String regex)部分关键字需要转译 使用字符串String 的plit 方法时，传入的分隔字符串是正则表达式，则部分关键字（比如 .| 等）需要转义。 反例： 123456// String.split(String regex) 反例String[] split = \"a.ab.abc\".split(\".\");System.out.println(Arrays.toString(split)); // 结果为[]String[] split1 = \"a|ab|abc\".split(\"|\");System.out.println(Arrays.toString(split1)); // 结果为[\"a\", \"|\", \"a\", \"b\", \"|\", \"a\", \"b\", \"c\"] 正例： 12345678// String.split(String regex) 正例// . 需要转译String[] split2 = \"a.ab.abc\".split(\"\\\\.\");System.out.println(Arrays.toString(split2)); // 结果为[\"a\", \"ab\", \"abc\"]// | 需要转译String[] split3 = \"a|ab|abc\".split(\"\\\\|\");System.out.println(Arrays.toString(split3)); // 结果为[\"a\", \"ab\", \"abc\"]","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"},{"name":"代码规范","slug":"代码规范","permalink":"http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"}]},{"title":"win10安装Redis","slug":"win10安装Redis","date":"2021-08-05T01:57:57.000Z","updated":"2021-08-05T02:25:32.680Z","comments":true,"path":"2021/08/05/win10安装Redis/","link":"","permalink":"http://yoursite.com/2021/08/05/win10%E5%AE%89%E8%A3%85Redis/","excerpt":"","text":"win10安装redis下载下载地址： https://github.com/MicrosoftArchive/redis/releases 根据系统下载的版本：以（64位为例） 下载后一般解压到根目录下：如（E:\\Redis-x64-3.2.100） 安装打开cmd命令窗口，使用命令进行安装和注册redis到window服务 安装命令：redis-server.exe –service-install redis.windows.conf –loglevel verbose 启动服务命令：redis-server.exe –service-start 关闭服务命令：redis-server.exe –service-stop 最后返回的successfully表示安装成功。 也可以通过任务管理器中查看后台中是否有redis-service来判断是否启动成功。 我们重新打开一个cmd ,作为一个客户端调用redis服务，如下图所示，调用命令是：redis-cli.exe -h 127.0.0.1 -p 6379，如下图显示地址和端口，说明调用成功 然后我们使用set 和get 命令进行测试一下，set uname “abc”,然后使用get uname可以获取到对应set的值，说明调用成功 客户端使用redis我们重新打开一个cmd ,作为一个客户端调用redis服务，如下图所示，调用命令是：redis-cli.exe -h 127.0.0.1 -p 6379，如下图显示地址和端口，说明调用成功 然后我们使用set 和get 命令进行测试一下，set uname “abc”,然后使用get uname可以获取到对应set的值，说明调用成功 设置密码 还可以通过将字符串设置为空来清空密码：CONFIG SET requirepass “”","categories":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"},{"name":"NoSql数据库","slug":"Redis/NoSql数据库","permalink":"http://yoursite.com/categories/Redis/NoSql%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"},{"name":"安装","slug":"安装","permalink":"http://yoursite.com/tags/%E5%AE%89%E8%A3%85/"}]},{"title":"sql 查出一张表中重复的所有记录数据","slug":"sql-查出一张表中重复的所有记录数据","date":"2021-07-22T07:45:35.000Z","updated":"2023-03-08T07:34:45.782Z","comments":true,"path":"2021/07/22/sql-查出一张表中重复的所有记录数据/","link":"","permalink":"http://yoursite.com/2021/07/22/sql-%E6%9F%A5%E5%87%BA%E4%B8%80%E5%BC%A0%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%89%80%E6%9C%89%E8%AE%B0%E5%BD%95%E6%95%B0%E6%8D%AE/","excerpt":"","text":"查询重复的数据1.查询出所有数据进行分组之后，和重复数据的重复次数的查询数据，先列下： 1select count(username) as '重复次数',username from t_user group by username having count(*)&gt;1 order by username desc 2.查找表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断 1select * from people where peopleId in (select peopleId from people group by peopleId having count(peopleId) &gt; 1) 3.查找表中多余的重复记录（多个字段） 1select * from people a where (a.peopleId,a.seq) in (select peopleId,seq from people group by peopleId,seq having count(*) &gt; 1)","categories":[{"name":"sql语句","slug":"sql语句","permalink":"http://yoursite.com/categories/sql%E8%AF%AD%E5%8F%A5/"},{"name":"数据库","slug":"sql语句/数据库","permalink":"http://yoursite.com/categories/sql%E8%AF%AD%E5%8F%A5/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"},{"name":"查询重复记录","slug":"查询重复记录","permalink":"http://yoursite.com/tags/%E6%9F%A5%E8%AF%A2%E9%87%8D%E5%A4%8D%E8%AE%B0%E5%BD%95/"}]},{"title":"深入理解 Java 的 3 种工厂模式","slug":"深入理解-Java-的-3-种工厂模式","date":"2021-07-22T02:52:40.000Z","updated":"2021-07-22T07:56:36.978Z","comments":true,"path":"2021/07/22/深入理解-Java-的-3-种工厂模式/","link":"","permalink":"http://yoursite.com/2021/07/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E7%9A%84-3-%E7%A7%8D%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"简单工厂模式简单工厂的定义：提供一个创建对象实例的功能，而无须关心其具体实现。被创建实例的类型可以是接口、抽象类，也可以是具体的类 实现汽车接口 123public interface Car &#123; String getName();&#125; 奔驰类 123456public class Benz implements Car &#123; @Override public String getName() &#123; return \"Benz\"; &#125;&#125; 宝马类 123456public class BMW implements Car &#123; @Override public String getName() &#123; return \"BMW\"; &#125;&#125; 简单工厂，既能生产宝马又能生产奔驰 123456789101112public class SimpleFactory &#123; public Car getCar(String name)&#123; if (name.equals(\"BMW\"))&#123; return new BMW(); &#125;else if (name.equals(\"benz\"))&#123; return new Benz(); &#125;else &#123; System.out.println(\"不好意思，这个品牌的汽车生产不了\"); return null; &#125; &#125;&#125; 测试类 1234567public class SimpleFactoryTest &#123; public static void main(String[] args)&#123; SimpleFactory simpleFactory = new SimpleFactory(); Car car = simpleFactory.getCar(\"BMW\"); System.out.println(car.getName()); &#125;&#125; 测试结果 1BMW 根据简单工厂的定义，用户只要产品而不在乎产品如何生产，看起来好像很完美的样子这个世界存在什么都生产的工厂吗？ 显然是不存在的，每一个汽车品牌都有自己的生产工厂，都有自己生产技术。映射到spring框架中，我们有很多很多种的bean需要生产，如果只依靠一个简单工厂来实现，那么我们得在工厂类中嵌套多少个if..else if啊？ 而且我们在代码中生产一辆汽车只是new一下就出来了，但实际操作中却不知道需要进行多少操作，加载、注册等操作都将体现在工厂类中，那么这个类就会变得紊乱，管理起来也很不方便，所以说每个品牌应该有自己的生产类。 因为专一，所以专业，这个时候工厂方法就出现了。 工厂方法工厂接口 1234//定义一个工厂接口，功能就是生产汽车public interface Factory &#123; Car getCar();&#125; 奔驰工厂 123456public class BenzFactory implements Factory &#123; @Override public Car getCar() &#123; return new Benz(); &#125;&#125; 宝马工厂 1234public class BMWFactory implements Factory&#123; @Override public Car getCar() &#123;return new BMW();&#125;&#125; 测试类 12345678public class FactoryTest &#123; public static void main(String[] args) &#123; Factory bmwFactory = new BMWFactory(); System.out.println(bmwFactory.getCar().getName()); Factory benzFactory = new BenzFactory(); System.out.println(benzFactory.getCar().getName()); &#125;&#125; 测试结果 1BMWBenz 根据上述代码可以看出，不同品牌的汽车是由不同的工厂生产的，貌似又是很完美的。但大家看一下测试类，当一个人想要去买一辆宝马汽车的时候（假设没有销售商），那么他就要去找宝马工厂给他生产一辆，过几天又想要买一辆奔驰汽车的时候，又得跑到奔驰工厂请人生产，这无疑就增加了用户的操作复杂性。所以有没有一种方便用户操作的方法呢？这个时候抽象工厂模式就出现了。 抽象工厂抽象工厂 12345678910public abstract class AbstractFactory &#123; protected abstract Car getCar(); //这段代码就是动态配置的功能//固定模式的委派 public Car getCar(String name)&#123; if(\"BMW\".equalsIgnoreCase(name))&#123;return new BmwFactory().getCar();&#125; else if(\"Benz\".equalsIgnoreCase(name))&#123;return new BenzFactory().getCar();&#125; else if(\"Audi\".equalsIgnoreCase(name))&#123;return new AudiFactory().getCar();&#125; else&#123;System.out.println(\"这个产品产不出来\");return null;&#125; &#125;&#125; 默认工厂 1234public class DefaultFactory extends AbstractFactory &#123; private AudiFactory defaultFactory = new AudiFactory(); public Car getCar() &#123;return defaultFactory.getCar();&#125;&#125; 宝马工厂 123456public class BMWFactory extends AbstractFactory &#123; @Override public Car getCar() &#123; return new BMW(); &#125;&#125; 奔驰工厂 123456public class BenzFactory extends AbstractFactory &#123; @Override public Car getCar() &#123; return new Benz(); &#125;&#125; 测试类 123456public class AbstractFactoryTest &#123; public static void main(String[] args) &#123; DefaultFactory factory = new DefaultFactory(); System.out.println(factory.getCar(\"Benz\").getName()); &#125;&#125; 测试结果 1Benz 根据上述代码可以看出，用户需要一辆汽车，只需要去找默认的工厂提出自己的需求（传入参数），便能得到自己想要产品，而不用根据产品去寻找不同的生产工厂，方便用户操作。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"},{"name":"工厂模式","slug":"工厂模式","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"}]},{"title":"Spring Boot 注解原理与自动装配原理","slug":"Spring-Boot-注解原理与自动装配原理","date":"2021-07-22T02:02:09.000Z","updated":"2021-07-22T02:20:24.753Z","comments":true,"path":"2021/07/22/Spring-Boot-注解原理与自动装配原理/","link":"","permalink":"http://yoursite.com/2021/07/22/Spring-Boot-%E6%B3%A8%E8%A7%A3%E5%8E%9F%E7%90%86%E4%B8%8E%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/","excerpt":"","text":"首先，先看SpringBoot的主配置类： 12345678@SpringBootApplicationpublic class StartEurekaApplication&#123; public static void main(String[] args) &#123; SpringApplication.run(StartEurekaApplication.class, args); &#125;&#125; 点进@SpringBootApplication来看，发现@SpringBootApplication是一个组合注解。 123456789101112@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123;&#125; 首先我们先来看 @SpringBootConfiguration： 123456@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Configurationpublic @interface SpringBootConfiguration &#123;&#125; 可以看到这个注解除了元注解以外，就只有一个@Configuration，那也就是说这个注解相当于@Configuration，所以这两个注解作用是一样的，它让我们能够去注册一些额外的Bean，并且导入一些额外的配置。 那@Configuration还有一个作用就是把该类变成一个配置类，不需要额外的XML进行配置。所以@SpringBootConfiguration就相当于@Configuration。进入@Configuration，发现@Configuration核心是@Component，说明Spring的配置类也是Spring的一个组件。 12345678910@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Configuration &#123; @AliasFor( annotation = Component.class ) String value() default \"\";&#125; 继续来看下一个@EnableAutoConfiguration,这个注解是开启自动配置的功能。 12345678910111213@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;)public @interface EnableAutoConfiguration &#123; String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\"; Class&lt;?&gt;[] exclude() default &#123;&#125;; String[] excludeName() default &#123;&#125;;&#125; 可以看到它是由 @AutoConfigurationPackage，@Import(EnableAutoConfigurationImportSelector.class)这两个而组成的，我们先说@AutoConfigurationPackage，他是说：让包中的类以及子包中的类能够被自动扫描到spring容器中。 1234567@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Import(&#123;Registrar.class&#125;)public @interface AutoConfigurationPackage &#123;&#125; 使用@Import来给Spring容器中导入一个组件 ，这里导入的是Registrar.class。来看下这个Registrar： 123456789101112static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports &#123; Registrar() &#123; &#125; public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123; AutoConfigurationPackages.register(registry, (new AutoConfigurationPackages.PackageImport(metadata)).getPackageName()); &#125; public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) &#123; return Collections.singleton(new AutoConfigurationPackages.PackageImport(metadata)); &#125; &#125; 就是通过以上这个方法获取扫描的包路径，可以debug查看具体的值： 那metadata是什么呢，可以看到是标注在@SpringBootApplication注解上的DemosbApplication，也就是我们的主配置类Application： 其实就是将主配置类（即@SpringBootApplication标注的类）的所在包及子包里面所有组件扫描加载到Spring容器。因此我们要把DemoApplication放在项目的最高级中（最外层目录）。 看看注解@Import(AutoConfigurationImportSelector.class)，@Import注解就是给Spring容器中导入一些组件，这里传入了一个组件的选择器:AutoConfigurationImportSelector。 可以从图中看出AutoConfigurationImportSelector 继承了 DeferredImportSelector 继承了 ImportSelector，ImportSelector有一个方法为：selectImports。将所有需要导入的组件以全类名的方式返回，这些组件就会被添加到容器中。 12345678910public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; if (!this.isEnabled(annotationMetadata)) &#123; return NO_IMPORTS; &#125; else &#123; AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(this.beanClassLoader); AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); &#125;&#125; 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件。 有了自动配置类，免去了我们手动编写配置注入功能组件等的工作。那是如何获取到这些配置类的呢，看看下面这个方法： 12345678910111213141516protected AutoConfigurationImportSelector.AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) &#123; if (!this.isEnabled(annotationMetadata)) &#123; return EMPTY_ENTRY; &#125; else &#123; AnnotationAttributes attributes = this.getAttributes(annotationMetadata); List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes); configurations = this.removeDuplicates(configurations); Set&lt;String&gt; exclusions = this.getExclusions(annotationMetadata, attributes); this.checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = this.filter(configurations, autoConfigurationMetadata); this.fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions); &#125;&#125; 我们可以看到getCandidateConfigurations()这个方法，他的作用就是引入系统已经加载好的一些类，到底是那些类呢： 12345678910protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123; List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader()); Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.\"); return configurations;&#125;public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123; String factoryClassName = factoryClass.getName(); return (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());&#125; 会从META-INF/spring.factories中获取资源，然后通过Properties加载资源： 123456789101112131415161718192021222324252627282930313233343536private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123; MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader); if (result != null) &#123; return result; &#125; else &#123; try &#123; Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(\"META-INF/spring.factories\") : ClassLoader.getSystemResources(\"META-INF/spring.factories\"); LinkedMultiValueMap result = new LinkedMultiValueMap(); while(urls.hasMoreElements()) &#123; URL url = (URL)urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); Iterator var6 = properties.entrySet().iterator(); while(var6.hasNext()) &#123; Map.Entry&lt;?, ?&gt; entry = (Map.Entry)var6.next(); String factoryClassName = ((String)entry.getKey()).trim(); String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue()); int var10 = var9.length; for(int var11 = 0; var11 &lt; var10; ++var11) &#123; String factoryName = var9[var11]; result.add(factoryClassName, factoryName.trim()); &#125; &#125; &#125; cache.put(classLoader, result); return result; &#125; catch (IOException var13) &#123; throw new IllegalArgumentException(\"Unable to load factories from location [META-INF/spring.factories]\", var13); &#125; &#125;&#125; 可以知道SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作。以前我们需要自己配置的东西，自动配置类都帮我们完成了。如下图可以发现Spring常见的一些类已经自动导入。 接下来看@ComponentScan注解，@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })，这个注解就是扫描包，然后放入spring容器。 1234@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM,classes = &#123;TypeExcludeFilter.class&#125;), @Filter(type = FilterType.CUSTOM,classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123;&#125; 总结下@SpringbootApplication：就是说，他已经把很多东西准备好，具体是否使用取决于我们的程序或者说配置。 接下来继续看run方法： 123public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125; 来看下在执行run方法到底有没有用到哪些自动配置的东西，我们点进run： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public ConfigurableApplicationContext run(String... args) &#123; //计时器 StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList(); this.configureHeadlessProperty(); //监听器 SpringApplicationRunListeners listeners = this.getRunListeners(args); listeners.starting(); Collection exceptionReporters; try &#123; ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); ConfigurableEnvironment environment = this.prepareEnvironment(listeners, applicationArguments); this.configureIgnoreBeanInfo(environment); Banner printedBanner = this.printBanner(environment); //准备上下文 context = this.createApplicationContext(); exceptionReporters = this.getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[]&#123;ConfigurableApplicationContext.class&#125;, context); //预刷新context this.prepareContext(context, environment, listeners, applicationArguments, printedBanner); //刷新context this.refreshContext(context); //刷新之后的context this.afterRefresh(context, applicationArguments); stopWatch.stop(); if (this.logStartupInfo) &#123; (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), stopWatch); &#125; listeners.started(context); this.callRunners(context, applicationArguments); &#125; catch (Throwable var10) &#123; this.handleRunFailure(context, var10, exceptionReporters, listeners); throw new IllegalStateException(var10); &#125; try &#123; listeners.running(context); return context; &#125; catch (Throwable var9) &#123; this.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)null); throw new IllegalStateException(var9); &#125;&#125; 那我们关注的就是 refreshContext(context); 刷新context，我们点进来看。 1234567891011private void refreshContext(ConfigurableApplicationContext context) &#123; refresh(context); if (this.registerShutdownHook) &#123; try &#123; context.registerShutdownHook(); &#125; catch (AccessControlException ex) &#123; // Not allowed in some environments. &#125; &#125;&#125; 我们继续点进refresh(context); 1234protected void refresh(ApplicationContext applicationContext) &#123; Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext); ((AbstractApplicationContext) applicationContext).refresh();&#125; 他会调用 ((AbstractApplicationContext) applicationContext).refresh();方法，我们点进来看： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125;catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125;finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; 由此可知，就是一个spring的bean的加载过程。继续来看一个方法叫做 onRefresh()： 123protected void onRefresh() throws BeansException &#123; // For subclasses: do nothing by default.&#125; 他在这里并没有直接实现，但是我们找他的具体实现： 比如Tomcat跟web有关，我们可以看到有个ServletWebServerApplicationContext： 12345678910@Overrideprotected void onRefresh() &#123; super.onRefresh(); try &#123; createWebServer(); &#125; catch (Throwable ex) &#123; throw new ApplicationContextException(\"Unable to start web server\", ex); &#125;&#125; 可以看到有一个createWebServer();方法他是创建web容器的，而Tomcat不就是web容器，那是如何创建的呢，我们继续看： 123456789101112131415161718private void createWebServer() &#123; WebServer webServer = this.webServer; ServletContext servletContext = getServletContext(); if (webServer == null &amp;&amp; servletContext == null) &#123; ServletWebServerFactory factory = getWebServerFactory(); this.webServer = factory.getWebServer(getSelfInitializer()); &#125; else if (servletContext != null) &#123; try &#123; getSelfInitializer().onStartup(servletContext); &#125; catch (ServletException ex) &#123; throw new ApplicationContextException(\"Cannot initialize servlet context\", ex); &#125; &#125; initPropertySources();&#125; factory.getWebServer(getSelfInitializer());他是通过工厂的方式创建的。 123public interface ServletWebServerFactory &#123; WebServer getWebServer(ServletContextInitializer... initializers);&#125; 可以看到 它是一个接口，为什么会是接口。因为我们不止是Tomcat一种web容器。 我们看到还有Jetty，那我们来看TomcatServletWebServerFactory： 123456789101112131415161718@Overridepublic WebServer getWebServer(ServletContextInitializer... initializers) &#123; Tomcat tomcat = new Tomcat(); File baseDir = (this.baseDirectory != null) ? this.baseDirectory : createTempDir(\"tomcat\"); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); customizeConnector(connector); tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); configureEngine(tomcat.getEngine()); for (Connector additionalConnector : this.additionalTomcatConnectors) &#123; tomcat.getService().addConnector(additionalConnector); &#125; prepareContext(tomcat.getHost(), initializers); return getTomcatWebServer(tomcat);&#125; 那这块代码，就是我们要寻找的内置Tomcat，在这个过程当中，我们可以看到创建Tomcat的一个流程。 如果不明白的话， 我们在用另一种方式来理解下，大家要应该都知道stater举点例子。 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;&lt;/dependency&gt; 首先自定义一个stater。 12345678910111213141516&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt;&lt;groupId&gt;com.zgw&lt;/groupId&gt;&lt;artifactId&gt;gw-spring-boot-starter&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 我们先来看maven配置写入版本号，如果自定义一个stater的话必须依赖spring-boot-autoconfigure这个包,我们先看下项目目录。 1234567891011public class GwServiceImpl implements GwService&#123; @Autowired GwProperties properties; @Override public void Hello() &#123; String name=properties.getName(); System.out.println(name+\"说:你们好啊\"); &#125;&#125; 我们做的就是通过配置文件来定制name这个是具体实现。 1234567891011121314@Component@ConfigurationProperties(prefix = \"spring.gwname\")public class GwProperties &#123; String name=\"zgw\"; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 这个类可以通过@ConfigurationProperties读取配置文件。 1234567891011121314151617@Configuration@ConditionalOnClass(GwService.class) //扫描类@EnableConfigurationProperties(GwProperties.class) //让配置类生效public class GwAutoConfiguration &#123; /** * 功能描述 托管给spring * @author zgw * @return */ @Bean @ConditionalOnMissingBean public GwService gwService() &#123; return new GwServiceImpl(); &#125;&#125; 这个为配置类，为什么这么写因为，spring-boot的stater都是这么写的，我们可以参照他仿写stater，以达到自动配置的目的，然后我们在通过spring.factories也来进行配置。 1org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.gw.GwAutoConfiguration 然后这样一个简单的stater就完成了，然后可以进行maven的打包，在其他项目引入就可以使用。","categories":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/categories/spring/"},{"name":"springboot","slug":"spring/springboot","permalink":"http://yoursite.com/categories/spring/springboot/"},{"name":"java","slug":"spring/springboot/java","permalink":"http://yoursite.com/categories/spring/springboot/java/"}],"tags":[{"name":"注解","slug":"注解","permalink":"http://yoursite.com/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"自动装配","slug":"自动装配","permalink":"http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"}]},{"title":"图解Java中那18 把锁","slug":"图解Java中那18-把锁","date":"2021-07-21T08:00:02.000Z","updated":"2023-06-30T01:46:20.312Z","comments":true,"path":"2021/07/21/图解Java中那18-把锁/","link":"","permalink":"http://yoursite.com/2021/07/21/%E5%9B%BE%E8%A7%A3Java%E4%B8%AD%E9%82%A318-%E6%8A%8A%E9%94%81/","excerpt":"","text":"乐观锁和悲观锁 独占锁和共享锁 互斥锁和读写锁 公平锁和非公平锁 可重入锁 自旋锁 分段锁 锁升级（无锁|偏向锁|轻量级锁|重量级锁） 锁优化技术（锁粗化、锁消除） 乐观锁与悲观锁 悲观锁 悲观锁对应于生活中悲观的人，悲观的人总是想着事情往坏的方向发展。 举个生活中的例子，假设厕所只有一个坑位了，悲观锁上厕所会第一时间把门反锁上，这样其他人上厕所只能在门外等候，这种状态就是「阻塞」了。 回到代码世界中，一个共享数据加了悲观锁，那线程每次想操作这个数据前都会假设其他线程也可能会操作这个数据，所以每次操作前都会上锁，这样其他线程想操作这个数据拿不到锁只能阻塞了。 在 Java 语言中 synchronized 和 ReentrantLock等就是典型的悲观锁，还有一些使用了 synchronized 关键字的容器类如 HashTable 等也是悲观锁的应用。 乐观锁 乐观锁 对应于生活中乐观的人，乐观的人总是想着事情往好的方向发展。 举个生活中的例子，假设厕所只有一个坑位了，乐观锁认为：这荒郊野外的，又没有什么人，不会有人抢我坑位的，每次关门上锁多浪费时间，还是不加锁好了。你看乐观锁就是天生乐观！ 回到代码世界中，乐观锁操作数据时不会上锁，在更新的时候会判断一下在此期间是否有其他线程去更新这个数据。 乐观锁可以使用版本号机制和CAS算法实现。在 Java 语言中 java.util.concurrent.atomic包下的原子类就是使用CAS 乐观锁实现的。 两种锁的使用场景 悲观锁和乐观锁没有孰优孰劣，有其各自适应的场景。 乐观锁适用于写比较少（冲突比较小）的场景，因为不用上锁、释放锁，省去了锁的开销，从而提升了吞吐量。 如果是写多读少的场景，即冲突比较严重，线程间竞争激烈，使用乐观锁就是导致线程不断进行重试，这样可能还降低了性能，这种场景下使用悲观锁就比较合适。 独占锁与共享锁 独占锁 独占锁是指锁一次只能被一个线程所持有。如果一个线程对数据加上排他锁后，那么其他线程不能再对该数据加任何类型的锁。获得独占锁的线程即能读数据又能修改数据。 JDK中的synchronized和java.util.concurrent(JUC)包中Lock的实现类就是独占锁。 共享锁 共享锁是指锁可被多个线程所持有。如果一个线程对数据加上共享锁后，那么其他线程只能对数据再加共享锁，不能加独占锁。获得共享锁的线程只能读数据，不能修改数据。 在 JDK 中 ReentrantReadWriteLock 就是一种共享锁。 互斥锁和读写锁 互斥锁 互斥锁是独占锁的一种常规实现，是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。 互斥锁一次只能一个线程拥有互斥锁，其他线程只有等待。 读写锁 读写锁是共享锁的一种具体实现。读写锁管理一组锁，一个是只读的锁，一个是写锁。 读锁可以在没有写锁的时候被多个线程同时持有，而写锁是独占的。写锁的优先级要高于读锁，一个获得了读锁的线程必须能看到前一个释放的写锁所更新的内容。 读写锁相比于互斥锁并发程度更高，每次只有一个写线程，但是同时可以有多个线程并发读。 在 JDK 中定义了一个读写锁的接口：ReadWriteLock 1234567891011public interface ReadWriteLock &#123; /** * 获取读锁 */ Lock readLock(); /** * 获取写锁 */ Lock writeLock();&#125; ReentrantReadWriteLock 实现了ReadWriteLock接口，具体实现这里不展开，后续会深入源码解析。 公平锁和非公平锁 公平锁 公平锁是指多个线程按照申请锁的顺序来获取锁，这里类似排队买票，先来的人先买，后来的人在队尾排着，这是公平的。 在 java 中可以通过构造函数初始化公平锁 1234/*** 创建一个可重入锁，true 表示公平锁，false 表示非公平锁。默认非公平锁*/Lock lock = new ReentrantLock(true); 非公平锁 非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成优先级翻转，或者饥饿的状态（某个线程一直得不到锁）。 在 java 中 synchronized 关键字是非公平锁，ReentrantLock默认也是非公平锁。 1234/*** 创建一个可重入锁，true 表示公平锁，false 表示非公平锁。默认非公平锁*/Lock lock = new ReentrantLock(false); 可重入锁 可重入锁又称之为递归锁，是指同一个线程在外层方法获取了锁，在进入内层方法会自动获取锁。 对于Java ReentrantLock而言, 他的名字就可以看出是一个可重入锁。对于Synchronized而言，也是一个可重入锁。 敲黑板：可重入锁的一个好处是可一定程度避免死锁。 以 synchronized 为例，看一下下面的代码： 12345678public synchronized void mehtodA() throws Exception&#123; // Do some magic tings mehtodB();&#125;public synchronized void mehtodB() throws Exception&#123; // Do some magic tings&#125; 上面的代码中 methodA 调用 methodB，如果一个线程调用methodA 已经获取了锁再去调用 methodB 就不需要再次获取锁了，这就是可重入锁的特性。如果不是可重入锁的话，mehtodB 可能不会被当前线程执行，可能造成死锁。 自旋锁 自旋锁是指线程在没有获得锁时不是被直接挂起，而是执行一个忙循环，这个忙循环就是所谓的自旋。 自旋锁的目的是为了减少线程被挂起的几率，因为线程的挂起和唤醒也都是耗资源的操作。 如果锁被另一个线程占用的时间比较长，即使自旋了之后当前线程还是会被挂起，忙循环就会变成浪费系统资源的操作，反而降低了整体性能。因此自旋锁是不适应锁占用时间长的并发情况的。 在 Java 中，AtomicInteger 类有自旋的操作，我们看一下代码： 1234567public final int getAndAddInt(Object o, long offset, int delta) &#123; int v; do &#123; v = getIntVolatile(o, offset); &#125; while (!compareAndSwapInt(o, offset, v, v + delta)); return v;&#125; CAS 操作如果失败就会一直循环获取当前 value 值然后重试。 另外自适应自旋锁也需要了解一下。 在JDK1.6又引入了自适应自旋，这个就比较智能了，自旋时间不再固定，由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定。如果虚拟机认为这次自旋也很有可能再次成功那就会次序较多的时间，如果自旋很少成功，那以后可能就直接省略掉自旋过程，避免浪费处理器资源。 分段锁 分段锁 是一种锁的设计，并不是具体的一种锁。 分段锁设计目的是将锁的粒度进一步细化，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。 在 Java 语言中 CurrentHashMap 底层就用了分段锁，使用Segment，就可以进行并发使用了。 锁升级（无锁|偏向锁|轻量级锁|重量级锁） JDK1.6 为了提升性能减少获得锁和释放锁所带来的消耗，引入了4种锁的状态：无锁、偏向锁、轻量级锁和重量级锁，它会随着多线程的竞争情况逐渐升级，但不能降级。 无锁 无锁状态其实就是上面讲的乐观锁，这里不再赘述。 偏向锁 Java偏向锁(Biased Locking)是指它会偏向于第一个访问锁的线程，如果在运行过程中，只有一个线程访问加锁的资源，不存在多线程竞争的情况，那么线程是不需要重复获取锁的，这种情况下，就会给线程加一个偏向锁。 偏向锁的实现是通过控制对象Mark Word的标志位来实现的，如果当前是可偏向状态，需要进一步判断对象头存储的线程 ID 是否与当前线程 ID 一致，如果一致直接进入。 轻量级锁 当线程竞争变得比较激烈时，偏向锁就会升级为轻量级锁，轻量级锁认为虽然竞争是存在的，但是理想情况下竞争的程度很低，通过自旋方式等待上一个线程释放锁。 重量级锁 如果线程并发进一步加剧，线程的自旋超过了一定次数，或者一个线程持有锁，一个线程在自旋，又来了第三个线程访问时（反正就是竞争继续加大了），轻量级锁就会膨胀为重量级锁，重量级锁会使除了此时拥有锁的线程以外的线程都阻塞。 升级到重量级锁其实就是互斥锁了，一个线程拿到锁，其余线程都会处于阻塞等待状态。 在 Java 中，synchronized 关键字内部实现原理就是锁升级的过程：无锁 –&gt; 偏向锁 –&gt; 轻量级锁 –&gt; 重量级锁。 锁优化技术（锁粗化、锁消除） 锁粗化 锁粗化就是将多个同步块的数量减少，并将单个同步块的作用范围扩大，本质上就是将多次上锁、解锁的请求合并为一次同步请求。 举个例子，一个循环体中有一个代码同步块，每次循环都会执行加锁解锁操作。 1234567private static final Object LOCK = new Object();for(int i = 0;i &lt; 100; i++) &#123; synchronized(LOCK)&#123; // do some magic things &#125;&#125; 经过锁粗化后就变成下面这个样子了： 12345 synchronized(LOCK)&#123; for(int i = 0;i &lt; 100; i++) &#123; // do some magic things &#125;&#125; 锁消除 锁消除是指虚拟机编译器在运行时检测到了共享数据没有竞争的锁，从而将这些锁进行消除。 举个例子让大家更好理解。 123456public String test(String s1, String s2)&#123; StringBuffer stringBuffer = new StringBuffer(); stringBuffer.append(s1); stringBuffer.append(s2); return stringBuffer.toString();&#125; 上面代码中有一个 test 方法，主要作用是将字符串 s1 和字符串 s2 串联起来。 test 方法中三个变量s1, s2, stringBuffer， 它们都是局部变量，局部变量是在栈上的，栈是线程私有的，所以就算有多个线程访问 test 方法也是线程安全的。 我们都知道 StringBuffer 是线程安全的类，append 方法是同步方法，但是 test 方法本来就是线程安全的，为了提升效率，虚拟机帮我们消除了这些同步锁，这个过程就被称为锁消除。 12345678StringBuffer.class// append 是同步方法public synchronized StringBuffer append(String str) &#123; toStringCache = null; super.append(str); return this;&#125; 一张图总结 前面讲了 Java 语言中各种各种的锁，最后再通过六个问题统一总结一下： -- End --","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java锁","slug":"java锁","permalink":"http://yoursite.com/tags/java%E9%94%81/"}]},{"title":"Java8 实现List转map 、分组、过滤","slug":"Java8-实现List转map-、分组、过滤","date":"2020-11-10T02:40:12.000Z","updated":"2023-07-11T02:55:20.893Z","comments":true,"path":"2020/11/10/Java8-实现List转map-、分组、过滤/","link":"","permalink":"http://yoursite.com/2020/11/10/Java8-%E5%AE%9E%E7%8E%B0List%E8%BD%ACmap-%E3%80%81%E5%88%86%E7%BB%84%E3%80%81%E8%BF%87%E6%BB%A4/","excerpt":"","text":"利用java8新特性，可以用简洁高效的代码来实现一些数据处理。 定义1个Apple对象： 123456789101112131415public class Apple &#123; private Integer id; private String name; private BigDecimal money; private Integer num; public Apple(Integer id, String name, BigDecimal money, Integer num) &#123; this.id = id; this.name = name; this.money = money; this.num = num; &#125;&#125; 添加一些测试数据： 1234567891011List&lt;Apple&gt; appleList = new ArrayList&lt;&gt;();//存放apple对象集合Apple apple1 = new Apple(1,\"苹果1\",new BigDecimal(\"3.25\"),10);Apple apple12 = new Apple(1,\"苹果2\",new BigDecimal(\"1.35\"),20);Apple apple2 = new Apple(2,\"香蕉\",new BigDecimal(\"2.89\"),30);Apple apple3 = new Apple(3,\"荔枝\",new BigDecimal(\"9.99\"),40);appleList.add(apple1);appleList.add(apple12);appleList.add(apple2);appleList.add(apple3); 1.分组List里面的对象元素，以某个属性来分组，例如，以id分组，将id相同的放在一起： 12345//List 以ID分组 Map&lt;Integer,List&lt;Apple&gt;&gt;Map&lt;Integer, List&lt;Apple&gt;&gt; groupBy = appleList.stream().collect(Collectors.groupingBy(Apple::getId));System.err.println(\"groupBy:\"+groupBy);&#123;1=[Apple&#123;id=1, name='苹果1', money=3.25, num=10&#125;, Apple&#123;id=1, name='苹果2', money=1.35, num=20&#125;], 2=[Apple&#123;id=2, name='香蕉', money=2.89, num=30&#125;], 3=[Apple&#123;id=3, name='荔枝', money=9.99, num=40&#125;]&#125; 2、List转Mapid为key，apple对象为value，可以这么做： 12345678/** * List -&gt; Map * 需要注意的是： * toMap 如果集合对象有重复的key，会报错Duplicate key .... * apple1,apple12的id都为1。 * 可以用 (k1,k2)-&gt;k1 来设置，如果有重复的key,则保留key1,舍弃key2 */Map&lt;Integer, Apple&gt; appleMap = appleList.stream().collect(Collectors.toMap(Apple::getId, a -&gt; a,(k1,k2)-&gt;k1)); 3、过滤Filter从集合中过滤出来符合条件的元素： 12345//过滤出符合条件的数据List&lt;Apple&gt; filterList = appleList.stream().filter(a -&gt; a.getName().equals(\"香蕉\")).collect(Collectors.toList());System.err.println(\"filterList:\"+filterList);[Apple&#123;id=2, name='香蕉', money=2.89, num=30&#125;] 4、求和将集合中的数据按照某个属性求和: 123//计算 总金额BigDecimal totalMoney = appleList.stream().map(Apple::getMoney).reduce(BigDecimal.ZERO, BigDecimal::add);System.err.println(\"totalMoney:\"+totalMoney); //totalMoney:17.48 5、查找流中最大 最小值Collectors.maxBy 和 Collectors.minBy 来计算流中的最大或最小值: 12345Optional&lt;Dish&gt; maxDish = Dish.menu.stream().collect(Collectors.maxBy(Comparator.comparing(Dish::getCalories)));maxDish.ifPresent(System.out::println);Optional&lt;Dish&gt; minDish = Dish.menu.stream().collect(Collectors.minBy(Comparator.comparing(Dish::getCalories)));minDish.ifPresent(System.out::println); 6、去重123456789import static java.util.Comparator.comparingLong;import static java.util.stream.Collectors.collectingAndThen;import static java.util.stream.Collectors.toCollection;// 根据id去重 List&lt;Person&gt; unique = appleList.stream().collect( collectingAndThen( toCollection(() -&gt; new TreeSet&lt;&gt;(comparingLong(Apple::getId))), ArrayList::new) );","categories":[{"name":"Java8","slug":"Java8","permalink":"http://yoursite.com/categories/Java8/"}],"tags":[{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"}]},{"title":"Linux实用命令及杂项","slug":"Linux实用命令及杂项","date":"2020-06-09T13:49:57.000Z","updated":"2020-06-09T13:53:42.371Z","comments":true,"path":"2020/06/09/Linux实用命令及杂项/","link":"","permalink":"http://yoursite.com/2020/06/09/Linux%E5%AE%9E%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E6%9D%82%E9%A1%B9/","excerpt":"","text":"1.关机&amp;重启命令 shutdown shutdown -h now 表示立即关机 shutdown -h 1 表示一分钟后关机 shutdown -r now 表示立即重启 halt 停机 等价于关机 reboot 重启系统 sync 把内存的数据保存到磁盘上 一般在关机或重启时先执行的命令 2.用户注销 logout 注销当前用户登录 (在图形界面无效) 3.用户管理 useradd xiaoming 添加一个用户 xiaoming（用户创建成功后会自动的创建与用户名同名的家目录与用户组） useradd -d 指定目录 用户名 创建新的用户并指定家目录 passwd xiaoming 给用户xiaoming指定密码 userdel xiaoming 删除用户xiaoming但是保留家目录 userdel -r xiaoming 删除xiaoming并删除家目录 id xiaoming 查询xiaoming的用户详细信息 su - root 切换到root用户 exit 退出 返回到原来的用户 whoami 当前用户是谁 groupadd wudang 添加一个用户组wudang groupdel wudang 删除用户组wudang useradd -g wudang xiaoming 将用户xiaoming指定到用户组wudang中 usermod -g shaolin xiaoming 将用户xiaoming修改用户组到shaolin中 4.运行级别linux一共分为7种运行级别，配置在 /etc/inittab id:5:initdefault: 这一行的数字中: 运行级别0：系统关机状态，系统默认运行级别不能设为0，否则不能正常启动 运行级别1：单用户(找回丢失密码)，root权限，用于系统维护，禁止远程登陆 运行级别2：多用户状态(没有网络服务) 运行级别3：多用户状态(有网络服务)，登陆后进入控制台命令行模式 运行级别4：系统未使用，保留 运行级别5：X11控制台，登陆后进入图形GUI模式 （图形界面） 运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动 init 3 将运行级别调整到3 5.帮助指令 man ls 查看命令ls的帮助及使用方法 help ls 查看ls命令的帮助及使用方法 6.文件目录 pwd 显示当前目录的绝对路径 ls -a 显示当前目录所有的文件和目录包括隐藏的文件 ls -l 以列表的方式显示信息 cd ~ 或 cd : 回到当前用户的家目录 cd .. 回到上一级目录 mkdir /home/dog 在home目录下创建一个dog目录 mkdir -p /home/animal/tigger 在home目录下创建多级 /animal/tigger 目录 rmdir /home/dog 删除目录/home/dog 如果目录下有内容时无法删除 rm -rf /home/dog 删除目录/home/dog 有没有内容都直接删除 touch hello.txt 创建一个hello.txt的空文件 cp hello.txt bbb/ 复制当前路径下的hello.txt到bbb文件夹中 cp -r test/ zwj/ 递归将test目录拷贝到zwj目录下 再次拷贝可能会提示覆盖 通过cp前加\\强制覆盖 mv aaa.txt bbb.txt 将当前目录的aaa.txt重命名为bbb.txt mv aaa.txt /root 将aaa.txt移动到root目录下 cat -n /etc/profile 查看etc下profile文件的内容并显示行号 cat -n /etc/profile | more 查看ect目录下profile文件的内容分页显示并显示行号 less /etc/peofile 效率比more命令高按需加载文件内容而不是一次性全部加载 ls -l &gt; aaa.txt 将ls的输出内容覆盖写入到aaa.txt中,aaa.txt不存在则创建 ls -l &gt;&gt; aaa.txt 将ls的输出内容追加写入到aaa.txt中,aaa.txt不存在则创建 echo “想要写的内容” &gt; a.txt 把双引号里的内容覆盖添加到a.txt中 echo $PATH 输出PATH环境变量 echo “hello” 输出hello文本 head -n 5 a.txt 显示a.txt文件前五行的内容 tail -n 5 a.txt 显示a.txt文件后五行的内容 tail -f a.txt 实时监控a.txt的变化 经常用到查看日志","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"命令","slug":"命令","permalink":"http://yoursite.com/tags/%E5%91%BD%E4%BB%A4/"}]},{"title":"jdk1.8下的Date与LocalDateTime的互相转换及格式化时间","slug":"jdk1-8下的Date与LocalDateTime的互相转换及格式化时间","date":"2020-06-09T13:29:12.000Z","updated":"2020-06-09T13:36:06.173Z","comments":true,"path":"2020/06/09/jdk1-8下的Date与LocalDateTime的互相转换及格式化时间/","link":"","permalink":"http://yoursite.com/2020/06/09/jdk1-8%E4%B8%8B%E7%9A%84Date%E4%B8%8ELocalDateTime%E7%9A%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2%E5%8F%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%B6%E9%97%B4/","excerpt":"","text":"不跟你多bb，上代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * @Author :liangHuang. * @Date :2019/5/8 16:28 * @Description :时间工具类 */public class DateUtil &#123; private static final ConcurrentMap&lt;String, DateTimeFormatter&gt; FORMATTER_CACHE = new ConcurrentHashMap&lt;&gt;(); private static final int PATTERN_CACHE_SIZE = 500; public static final String LOCAL_DATE_TIME = \"yyyy-MM-dd HH:mm:ss\"; public static final String LOCAL_DATE = \"yyyy-MM-dd\"; public static final String LOCAL_TIME = \"HH:mm:ss\"; /** * Date转换为格式化时间 * @param date * @param pattern * @return */ public static String format(Date date, String pattern)&#123; return format(LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault()), pattern); &#125; /** * localDateTime转换为格式化时间 * @param localDateTime localDateTime * @param pattern 格式 * @return */ public static String format(LocalDateTime localDateTime, String pattern)&#123; DateTimeFormatter formatter = createCacheFormatter(pattern); return localDateTime.format(formatter); &#125; /** * 格式化字符串转为Date * @param time 格式化时间 * @param pattern 格式 * @return */ public static Date parseDate(String time, String pattern)&#123; return Date.from(parseLocalDateTime(time, pattern).atZone(ZoneId.systemDefault()).toInstant()); &#125; /** * 格式化字符串转为LocalDateTime * @param time 格式化时间 * @param pattern 格式 * @return */ public static LocalDateTime parseLocalDateTime(String time, String pattern)&#123; DateTimeFormatter formatter = createCacheFormatter(pattern); return LocalDateTime.parse(time, formatter); &#125; /** * 在缓存中创建DateTimeFormatter * @param pattern 格式 * @return */ private static DateTimeFormatter createCacheFormatter(String pattern)&#123; if (pattern == null || pattern.length() == 0) &#123; throw new IllegalArgumentException(\"Invalid pattern specification\"); &#125; DateTimeFormatter formatter = FORMATTER_CACHE.get(pattern); if(formatter == null)&#123; if(FORMATTER_CACHE.size() &lt; PATTERN_CACHE_SIZE)&#123; formatter = DateTimeFormatter.ofPattern(pattern); DateTimeFormatter oldFormatter = FORMATTER_CACHE.putIfAbsent(pattern, formatter); if(oldFormatter != null)&#123; formatter = oldFormatter; &#125; &#125; &#125; return formatter; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"util","slug":"util","permalink":"http://yoursite.com/tags/util/"}]},{"title":".JPEG .GIF .PNG 三种图片格式的区别","slug":"JPEG-GIF-PNG-三种图片格式的区别","date":"2020-06-09T11:33:18.000Z","updated":"2020-06-09T11:37:19.363Z","comments":true,"path":"2020/06/09/JPEG-GIF-PNG-三种图片格式的区别/","link":"","permalink":"http://yoursite.com/2020/06/09/JPEG-GIF-PNG-%E4%B8%89%E7%A7%8D%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"1.JPEG格式 JPEG（JPG）图片支持的颜色较多，图片可以压缩，但是不支持透明，一般使用JPEG来保存照片等颜色丰富的图片 2.GIF GIF支持的颜色较少，只支持简单的透明，支持动态图，图片颜色单一或者是动态图时可以使用GIF格式 3.PNG PNG格式支持的颜色较多，并且支持复杂的透明，可以用来显示颜色复杂的透明的图片，开发中比较常见 开发建议 ++效果不一致，使用效果好的++ ++效果一致，使用小的++","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"图片","slug":"图片","permalink":"http://yoursite.com/tags/%E5%9B%BE%E7%89%87/"}]},{"title":"cookie、session、token、jwt介绍","slug":"cookie、session、token、jwt介绍","date":"2020-06-09T02:56:03.000Z","updated":"2020-06-09T03:04:57.983Z","comments":true,"path":"2020/06/09/cookie、session、token、jwt介绍/","link":"","permalink":"http://yoursite.com/2020/06/09/cookie%E3%80%81session%E3%80%81token%E3%80%81jwt%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"cookie cookie的诞生由于HTTP协议是无状态的，而服务器端的业务必须是要有状态的。Cookie诞生的最初目的是为了存储web中的状态信息，以方便服务器端使用。比如判断用户是否是第一次访问网站。目前最新的规范是RFC 6265，它是一个由浏览器服务器共同协作实现的规范。Cookie的处理分为：服务器像客户端发送cookie浏览器将cookie保存之后每次http请求浏览器都会将cookie发送给服务器端 session 为什么要有session的出现？答：是由于网络中http协议造成的，因为http本身是无状态协议，这样，无法确定你的本次请求和上次请求是不是你发送的。如果要进行类似论坛登陆相关的操作，就实现不了了。 session生成方式？答：浏览器第一次访问服务器，服务器会创建一个session，然后同时为该session生成一个唯一的会话的key,也就是sessionid，然后，将sessionid及对应的session分别作为key和value保存到缓存中，也可以持久化到数据库中，然后服务器再把sessionid，以cookie的形式发送给客户端。这样浏览器下次再访问时，会直接带着cookie中的sessionid。然后服务器根据sessionid找到对应的session进行匹配；还有一种是浏览器禁用了cookie或不支持cookie，这种可以通过URL重写的方式发到服务器； token 访问资源的令牌验证流程：1.把用户的用户名和密码发到后端2.后端进行校验，校验成功会生成token, 把token发送给客户端3.客户端自己保存token, 再次请求就要在Http协议的请求头中带着token去访问服务端，和在服务端保存的token信息进行比对校验。 JWT java web token 的缩写，可使用restful接口定义，也可以用在web中段落引用组成：header在header中声明一些信息payload、 签证验证流程：1.段落引用在头部信息中声明加密算法和常量， 然后把header使用json转化为字符串2.段落引用在载荷中声明用户信息，同时还有一些其他的内容；再次使用json 把载荷部分进行转化，转化为字符串3.使用在header中声明的加密算法和每个项目随机生成的secret来进行加密， 把第一步分字符串和第二部分的字符串进行加密， 生成新的字符串。词字符串是独一无二的。4.解密的时候，只要客户端带着JWT来发起请求，服务端就直接使用secret进行解密。 特点：1.三部分组成，每一部分都进行字符串的转化2.解密的时候没有使用数据库，仅仅使用的是secret进行解密。3.JWT的secret不能泄密","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"login","slug":"login","permalink":"http://yoursite.com/tags/login/"}]},{"title":"Hexo免输入密码部署到github","slug":"Hexo免输入密码部署到github","date":"2020-06-07T10:52:19.000Z","updated":"2021-07-22T01:38:07.693Z","comments":true,"path":"2020/06/07/Hexo免输入密码部署到github/","link":"","permalink":"http://yoursite.com/2020/06/07/Hexo%E5%85%8D%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81%E9%83%A8%E7%BD%B2%E5%88%B0github/","excerpt":"","text":"hexo 使用hexo d命令部署到github时，会要求你输入用户名密码，每次提交都要输入，为了方便添加如下配置： 在系统变量中添加一个环境变量： 12变量名：HOME变量值：%USERPROFILE% 接着在你的用户目录（C:\\Users\\username）下新建一个叫 _netrc的文件编辑这个文件： 123machine github.comlogin usernamepassword password 设置好这些后，当你再次部署时，就不用输入用户名和密码了。","categories":[{"name":"博客","slug":"博客","permalink":"http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"}]},{"title":"使用jdk实现动态代理","slug":"使用jdk实现动态代理","date":"2020-06-07T05:21:02.000Z","updated":"2020-06-07T07:27:25.047Z","comments":true,"path":"2020/06/07/使用jdk实现动态代理/","link":"","permalink":"http://yoursite.com/2020/06/07/%E4%BD%BF%E7%94%A8jdk%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","excerpt":"","text":"java的代理就是客户类不再直接与委托类直接打打交道，而是通过一个中间层进行访问，这个中间层就是代理，优势: 1.隐藏委托类 2.代码解耦 代理主要分为静态代理、jdk动态代理、和CGLIB 动态代理，各有优缺点，没有最好的，存在即合理。 1 计算器接口需求例如我们有一个实现计算器的接口: 1234567891011121314151617181920212223242526272829public interface Calculator &#123; /** * 两个数相加 * @param a * @param b * @return */ int sub(int a, int b); /** * 两个数相减 * @param a * @param b * @return */ int less(int a, int b); /** * 两个数相乘 * @param a * @param b * @return */ int Multiply(int a, int b); /** * 两个数相除 * @param a * @param b * @return */ int except(int a, int b); 以及接口实现类，并且在每次预算前与运算后返回入参及结果打印: 123456789101112131415161718192021222324252627282930313233public class CalculatorImpl implements Calculator &#123; @Override public int sub(int a, int b) &#123; System.out.println(\"sub计算开始，参数为[\" + a + \",\"+ b +\"]。\"); int result = a + b; System.out.println(\"sub计算结束，结果为[\" + result +\"]。\"); return result; &#125; @Override public int less(int a, int b) &#123; System.out.println(\"less计算开始，参数为[\" + a + \",\"+ b +\"]。\"); int result = a - b; System.out.println(\"less计算结束，结果为[\" + result +\"]。\"); return result; &#125; @Override public int multiply(int a, int b) &#123; System.out.println(\"multiply计算开始，参数为[\" + a + \",\"+ b +\"]。\"); int result = a * b; System.out.println(\"multiply计算结束，结果为[\" + result +\"]。\"); return result; &#125; @Override public int except(int a, int b) &#123; System.out.println(\"except计算开始，参数为[\" + a + \",\"+ b +\"]。\"); int result = a / b; System.out.println(\"except计算结束，结果为[\" + result +\"]。\"); return result; &#125;&#125; 测试 1234567891011public class Test &#123; public static void main(String[] args) &#123; Calculator calculator = new CalculatorImpl(); int sub = calculator.sub(1, 2); System.out.println(\"---&gt;\" + sub); int less = calculator.less(6, 2); System.out.println(\"---&gt;\" + less); &#125;&#125; 打印结果为： sub计算开始，参数为[1,2]。sub计算结束，结果为[3]。—&gt;3less计算开始，参数为[6,2]。less计算结束，结果为[4]。—&gt;4 虽然实现了需求但是以上代码（虽然简单）暴露了很多问题： 1.代码混乱：越来越多的非业务需求（日志与验证等）加入后，原本简单的业务代码急剧膨胀，每个方法在处理核心逻辑的同时还需要关注多个点 2.代码分散：以日志需求为例，只是为了满足这个单一需求（加减乘除），就不得不在多个模块（方法）上多次重复相同的日志代码，如果日志代码修改，需要修改所有模块 2 使用jdk动态代理实现无入侵日志打印删除计算器实中的日志记录代码并创建动态代理类 CalculatorloggingProxy 1234567891011121314151617181920212223242526272829303132333435363738public class CalculatorloggingProxy &#123; //想要代理的对象 private Calculator target; public CalculatorloggingProxy(Calculator target) &#123; this.target = target; &#125; public Calculator getLoggingProxy()&#123; Calculator proxy = null; //代理对象由哪一个类加载器度负责加载 ClassLoader loader = target.getClass().getClassLoader(); //代理对象的类型，有哪些方法 Class[] interfaces = new Class[] &#123;Calculator.class&#125;; //当调用代理对象的方法时，执行该代码 InvocationHandler invocationHandler = new InvocationHandler() &#123; /** * @param proxy 正在返回的代理对象，一般情况下在 invoke方法中都不使用该对象 * @param method 正在被调用的方法 * @param args 方法的参数 * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String methodName = method.getName(); System.out.println(\"计算器[\"+ methodName + \"]方法开始执行,参数为\" + Arrays.asList(args)); //执行方法 Object result = method.invoke(target, args); System.out.println(\"方法[\"+ methodName + \"]计算完毕,结果为\" + result); return result; &#125; &#125;; proxy = (Calculator)Proxy.newProxyInstance(loader, interfaces, invocationHandler); return proxy; &#125;&#125; 测试test更改为 123456789101112131415161718public class Test &#123; public static void main(String[] args) &#123; Calculator calculator = new CalculatorImpl(); CalculatorloggingProxy calculatorloggingProxy = new CalculatorloggingProxy(calculator); //获取计算器代理对象 Calculator loggingProxy = calculatorloggingProxy.getLoggingProxy(); //调用加法 loggingProxy.sub(1, 2); //调用减法 loggingProxy.less(6, 2); //乘法 loggingProxy.multiply(4, 4); //除法 loggingProxy.except(18,2); &#125;&#125; 执行测试，结果为： 计算器[sub]方法开始执行,参数为[1, 2]方法[sub]计算完毕,结果为3计算器[less]方法开始执行,参数为[6, 2]方法[less]计算完毕,结果为4计算器[multiply]方法开始执行,参数为[4, 4]方法[multiply]计算完毕,结果为16计算器[except]方法开始执行,参数为[18, 2]方法[except]计算完毕,结果为9 至此我们完成了动态代理，实现需求。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"},{"name":"动态代理","slug":"动态代理","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"}]}],"categories":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/categories/spring/"},{"name":"springboot","slug":"spring/springboot","permalink":"http://yoursite.com/categories/spring/springboot/"},{"name":"java","slug":"spring/springboot/java","permalink":"http://yoursite.com/categories/spring/springboot/java/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Java8","slug":"java/Java8","permalink":"http://yoursite.com/categories/java/Java8/"},{"name":"spring","slug":"java/spring","permalink":"http://yoursite.com/categories/java/spring/"},{"name":"springMVC","slug":"java/spring/springMVC","permalink":"http://yoursite.com/categories/java/spring/springMVC/"},{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"},{"name":"NoSql数据库","slug":"Redis/NoSql数据库","permalink":"http://yoursite.com/categories/Redis/NoSql%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"sql语句","slug":"sql语句","permalink":"http://yoursite.com/categories/sql%E8%AF%AD%E5%8F%A5/"},{"name":"数据库","slug":"sql语句/数据库","permalink":"http://yoursite.com/categories/sql%E8%AF%AD%E5%8F%A5/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Java8","slug":"Java8","permalink":"http://yoursite.com/categories/Java8/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"},{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"},{"name":"demo","slug":"demo","permalink":"http://yoursite.com/tags/demo/"},{"name":"java枚举","slug":"java枚举","permalink":"http://yoursite.com/tags/java%E6%9E%9A%E4%B8%BE/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"数据库备份","slug":"数据库备份","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD/"},{"name":"函数式接口","slug":"函数式接口","permalink":"http://yoursite.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"},{"name":"工具类","slug":"工具类","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"mvc","slug":"mvc","permalink":"http://yoursite.com/tags/mvc/"},{"name":"代码规范","slug":"代码规范","permalink":"http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"安装","slug":"安装","permalink":"http://yoursite.com/tags/%E5%AE%89%E8%A3%85/"},{"name":"查询重复记录","slug":"查询重复记录","permalink":"http://yoursite.com/tags/%E6%9F%A5%E8%AF%A2%E9%87%8D%E5%A4%8D%E8%AE%B0%E5%BD%95/"},{"name":"工厂模式","slug":"工厂模式","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"name":"注解","slug":"注解","permalink":"http://yoursite.com/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"自动装配","slug":"自动装配","permalink":"http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"},{"name":"java锁","slug":"java锁","permalink":"http://yoursite.com/tags/java%E9%94%81/"},{"name":"命令","slug":"命令","permalink":"http://yoursite.com/tags/%E5%91%BD%E4%BB%A4/"},{"name":"util","slug":"util","permalink":"http://yoursite.com/tags/util/"},{"name":"图片","slug":"图片","permalink":"http://yoursite.com/tags/%E5%9B%BE%E7%89%87/"},{"name":"login","slug":"login","permalink":"http://yoursite.com/tags/login/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"动态代理","slug":"动态代理","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"}]}