{"meta":{"title":"QWHS","subtitle":"纸上得来终觉浅","description":"CV工程师，面向搜索引擎编程","author":"宁中老程","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2020-06-07T07:19:53.000Z","updated":"2020-06-07T07:22:18.159Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-06-07T04:44:54.000Z","updated":"2020-06-07T05:08:53.141Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":".JPEG .GIF .PNG 三种图片格式的区别","slug":"JPEG-GIF-PNG-三种图片格式的区别","date":"2020-06-09T11:33:18.000Z","updated":"2020-06-09T11:37:19.363Z","comments":true,"path":"2020/06/09/JPEG-GIF-PNG-三种图片格式的区别/","link":"","permalink":"http://yoursite.com/2020/06/09/JPEG-GIF-PNG-%E4%B8%89%E7%A7%8D%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"1.JPEG格式 JPEG（JPG）图片支持的颜色较多，图片可以压缩，但是不支持透明，一般使用JPEG来保存照片等颜色丰富的图片 2.GIF GIF支持的颜色较少，只支持简单的透明，支持动态图，图片颜色单一或者是动态图时可以使用GIF格式 3.PNG PNG格式支持的颜色较多，并且支持复杂的透明，可以用来显示颜色复杂的透明的图片，开发中比较常见 开发建议 ++效果不一致，使用效果好的++ ++效果一致，使用小的++","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"图片","slug":"图片","permalink":"http://yoursite.com/tags/%E5%9B%BE%E7%89%87/"}]},{"title":"cookie、session、token、jwt介绍","slug":"cookie、session、token、jwt介绍","date":"2020-06-09T02:56:03.000Z","updated":"2020-06-09T03:04:57.983Z","comments":true,"path":"2020/06/09/cookie、session、token、jwt介绍/","link":"","permalink":"http://yoursite.com/2020/06/09/cookie%E3%80%81session%E3%80%81token%E3%80%81jwt%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"cookie cookie的诞生由于HTTP协议是无状态的，而服务器端的业务必须是要有状态的。Cookie诞生的最初目的是为了存储web中的状态信息，以方便服务器端使用。比如判断用户是否是第一次访问网站。目前最新的规范是RFC 6265，它是一个由浏览器服务器共同协作实现的规范。Cookie的处理分为：服务器像客户端发送cookie浏览器将cookie保存之后每次http请求浏览器都会将cookie发送给服务器端 session 为什么要有session的出现？答：是由于网络中http协议造成的，因为http本身是无状态协议，这样，无法确定你的本次请求和上次请求是不是你发送的。如果要进行类似论坛登陆相关的操作，就实现不了了。 session生成方式？答：浏览器第一次访问服务器，服务器会创建一个session，然后同时为该session生成一个唯一的会话的key,也就是sessionid，然后，将sessionid及对应的session分别作为key和value保存到缓存中，也可以持久化到数据库中，然后服务器再把sessionid，以cookie的形式发送给客户端。这样浏览器下次再访问时，会直接带着cookie中的sessionid。然后服务器根据sessionid找到对应的session进行匹配；还有一种是浏览器禁用了cookie或不支持cookie，这种可以通过URL重写的方式发到服务器； token 访问资源的令牌验证流程：1.把用户的用户名和密码发到后端2.后端进行校验，校验成功会生成token, 把token发送给客户端3.客户端自己保存token, 再次请求就要在Http协议的请求头中带着token去访问服务端，和在服务端保存的token信息进行比对校验。 JWT java web token 的缩写，可使用restful接口定义，也可以用在web中段落引用组成：header在header中声明一些信息payload、 签证验证流程：1.段落引用在头部信息中声明加密算法和常量， 然后把header使用json转化为字符串2.段落引用在载荷中声明用户信息，同时还有一些其他的内容；再次使用json 把载荷部分进行转化，转化为字符串3.使用在header中声明的加密算法和每个项目随机生成的secret来进行加密， 把第一步分字符串和第二部分的字符串进行加密， 生成新的字符串。词字符串是独一无二的。4.解密的时候，只要客户端带着JWT来发起请求，服务端就直接使用secret进行解密。 特点：1.三部分组成，每一部分都进行字符串的转化2.解密的时候没有使用数据库，仅仅使用的是secret进行解密。3.JWT的secret不能泄密","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"login","slug":"login","permalink":"http://yoursite.com/tags/login/"}]},{"title":"Hexo免输入密码部署到github","slug":"Hexo免输入密码部署到github","date":"2020-06-07T10:52:19.000Z","updated":"2020-06-07T11:32:39.545Z","comments":true,"path":"2020/06/07/Hexo免输入密码部署到github/","link":"","permalink":"http://yoursite.com/2020/06/07/Hexo%E5%85%8D%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81%E9%83%A8%E7%BD%B2%E5%88%B0github/","excerpt":"","text":"hexo 使用hexo d命令部署到github时，会要求你输入用户名密码，每次提交都要输入，为了方便添加如下配置： 在系统变量中添加一个环境变量： 12变量名：HOME变量值：%USERPROFILE% 接着在你的用户目录（C:\\Users\\username）下新建一个叫 _netrc的文件编辑这个文件： 123machine github.comlogin usernamepassword password 设置好这些后，当你再次部署时，就不用输入用户名和密码了。","categories":[{"name":"博客","slug":"博客","permalink":"http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"}]},{"title":"使用jdk实现动态代理","slug":"使用jdk实现动态代理","date":"2020-06-07T05:21:02.000Z","updated":"2020-06-07T07:27:25.047Z","comments":true,"path":"2020/06/07/使用jdk实现动态代理/","link":"","permalink":"http://yoursite.com/2020/06/07/%E4%BD%BF%E7%94%A8jdk%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","excerpt":"","text":"java的代理就是客户类不再直接与委托类直接打打交道，而是通过一个中间层进行访问，这个中间层就是代理，优势: 1.隐藏委托类 2.代码解耦 代理主要分为静态代理、jdk动态代理、和CGLIB 动态代理，各有优缺点，没有最好的，存在即合理。 1 计算器接口需求例如我们有一个实现计算器的接口: 1234567891011121314151617181920212223242526272829public interface Calculator &#123; /** * 两个数相加 * @param a * @param b * @return */ int sub(int a, int b); /** * 两个数相减 * @param a * @param b * @return */ int less(int a, int b); /** * 两个数相乘 * @param a * @param b * @return */ int Multiply(int a, int b); /** * 两个数相除 * @param a * @param b * @return */ int except(int a, int b); 以及接口实现类，并且在每次预算前与运算后返回入参及结果打印: 123456789101112131415161718192021222324252627282930313233public class CalculatorImpl implements Calculator &#123; @Override public int sub(int a, int b) &#123; System.out.println(\"sub计算开始，参数为[\" + a + \",\"+ b +\"]。\"); int result = a + b; System.out.println(\"sub计算结束，结果为[\" + result +\"]。\"); return result; &#125; @Override public int less(int a, int b) &#123; System.out.println(\"less计算开始，参数为[\" + a + \",\"+ b +\"]。\"); int result = a - b; System.out.println(\"less计算结束，结果为[\" + result +\"]。\"); return result; &#125; @Override public int multiply(int a, int b) &#123; System.out.println(\"multiply计算开始，参数为[\" + a + \",\"+ b +\"]。\"); int result = a * b; System.out.println(\"multiply计算结束，结果为[\" + result +\"]。\"); return result; &#125; @Override public int except(int a, int b) &#123; System.out.println(\"except计算开始，参数为[\" + a + \",\"+ b +\"]。\"); int result = a / b; System.out.println(\"except计算结束，结果为[\" + result +\"]。\"); return result; &#125;&#125; 测试 1234567891011public class Test &#123; public static void main(String[] args) &#123; Calculator calculator = new CalculatorImpl(); int sub = calculator.sub(1, 2); System.out.println(\"---&gt;\" + sub); int less = calculator.less(6, 2); System.out.println(\"---&gt;\" + less); &#125;&#125; 打印结果为： sub计算开始，参数为[1,2]。sub计算结束，结果为[3]。—&gt;3less计算开始，参数为[6,2]。less计算结束，结果为[4]。—&gt;4 虽然实现了需求但是以上代码（虽然简单）暴露了很多问题： 1.代码混乱：越来越多的非业务需求（日志与验证等）加入后，原本简单的业务代码急剧膨胀，每个方法在处理核心逻辑的同时还需要关注多个点 2.代码分散：以日志需求为例，只是为了满足这个单一需求（加减乘除），就不得不在多个模块（方法）上多次重复相同的日志代码，如果日志代码修改，需要修改所有模块 2 使用jdk动态代理实现无入侵日志打印删除计算器实中的日志记录代码并创建动态代理类 CalculatorloggingProxy 1234567891011121314151617181920212223242526272829303132333435363738public class CalculatorloggingProxy &#123; //想要代理的对象 private Calculator target; public CalculatorloggingProxy(Calculator target) &#123; this.target = target; &#125; public Calculator getLoggingProxy()&#123; Calculator proxy = null; //代理对象由哪一个类加载器度负责加载 ClassLoader loader = target.getClass().getClassLoader(); //代理对象的类型，有哪些方法 Class[] interfaces = new Class[] &#123;Calculator.class&#125;; //当调用代理对象的方法时，执行该代码 InvocationHandler invocationHandler = new InvocationHandler() &#123; /** * @param proxy 正在返回的代理对象，一般情况下在 invoke方法中都不使用该对象 * @param method 正在被调用的方法 * @param args 方法的参数 * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String methodName = method.getName(); System.out.println(\"计算器[\"+ methodName + \"]方法开始执行,参数为\" + Arrays.asList(args)); //执行方法 Object result = method.invoke(target, args); System.out.println(\"方法[\"+ methodName + \"]计算完毕,结果为\" + result); return result; &#125; &#125;; proxy = (Calculator)Proxy.newProxyInstance(loader, interfaces, invocationHandler); return proxy; &#125;&#125; 测试test更改为 123456789101112131415161718public class Test &#123; public static void main(String[] args) &#123; Calculator calculator = new CalculatorImpl(); CalculatorloggingProxy calculatorloggingProxy = new CalculatorloggingProxy(calculator); //获取计算器代理对象 Calculator loggingProxy = calculatorloggingProxy.getLoggingProxy(); //调用加法 loggingProxy.sub(1, 2); //调用减法 loggingProxy.less(6, 2); //乘法 loggingProxy.multiply(4, 4); //除法 loggingProxy.except(18,2); &#125;&#125; 执行测试，结果为： 计算器[sub]方法开始执行,参数为[1, 2]方法[sub]计算完毕,结果为3计算器[less]方法开始执行,参数为[6, 2]方法[less]计算完毕,结果为4计算器[multiply]方法开始执行,参数为[4, 4]方法[multiply]计算完毕,结果为16计算器[except]方法开始执行,参数为[18, 2]方法[except]计算完毕,结果为9 至此我们完成了动态代理，实现需求。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"},{"name":"动态代理","slug":"动态代理","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"}]}],"categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"图片","slug":"图片","permalink":"http://yoursite.com/tags/%E5%9B%BE%E7%89%87/"},{"name":"login","slug":"login","permalink":"http://yoursite.com/tags/login/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"simple","slug":"simple","permalink":"http://yoursite.com/tags/simple/"},{"name":"动态代理","slug":"动态代理","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"}]}