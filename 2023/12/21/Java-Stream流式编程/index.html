<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/xm32_favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/xm_favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="1 Stream 基础知识什么是 StreamStream（流）是 Java 8 引入的一个新的抽象概念，它代表着一种处理数据的序列。简单来说，Stream 是一系列元素的集合，这些元素可以是集合、数组、I&#x2F;O 资源或者其他数据源。 Stream API 提供了丰富的操作方法，可以对 Stream 中的元素进行各种转换、过滤、映射、聚合等操作，从而实现对数据的处理和操作。Stream API 的设">
<meta property="og:type" content="article">
<meta property="og:title" content="Java Stream流式编程">
<meta property="og:url" content="http://yoursite.com/2023/12/21/Java-Stream%E6%B5%81%E5%BC%8F%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="QWHS">
<meta property="og:description" content="1 Stream 基础知识什么是 StreamStream（流）是 Java 8 引入的一个新的抽象概念，它代表着一种处理数据的序列。简单来说，Stream 是一系列元素的集合，这些元素可以是集合、数组、I&#x2F;O 资源或者其他数据源。 Stream API 提供了丰富的操作方法，可以对 Stream 中的元素进行各种转换、过滤、映射、聚合等操作，从而实现对数据的处理和操作。Stream API 的设">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-12-21T03:08:49.000Z">
<meta property="article:modified_time" content="2024-01-08T02:37:54.776Z">
<meta property="article:author" content="宁中老程">
<meta property="article:tag" content="simple">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2023/12/21/Java-Stream%E6%B5%81%E5%BC%8F%E7%BC%96%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java Stream流式编程 | QWHS</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">QWHS</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">纸上得来终觉浅</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/12/21/Java-Stream%E6%B5%81%E5%BC%8F%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/pao.gif">
      <meta itemprop="name" content="宁中老程">
      <meta itemprop="description" content="CV工程师，面向搜索引擎编程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QWHS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java Stream流式编程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-21 11:08:49" itemprop="dateCreated datePublished" datetime="2023-12-21T11:08:49+08:00">2023-12-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-08 10:37:54" itemprop="dateModified" datetime="2024-01-08T10:37:54+08:00">2024-01-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java8/" itemprop="url" rel="index"><span itemprop="name">Java8</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java8/Stream/" itemprop="url" rel="index"><span itemprop="name">Stream</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="1-Stream-基础知识"><a href="#1-Stream-基础知识" class="headerlink" title="1 Stream 基础知识"></a>1 Stream 基础知识</h2><h3 id="什么是-Stream"><a href="#什么是-Stream" class="headerlink" title="什么是 Stream"></a>什么是 Stream</h3><p>Stream（流）是 Java 8 引入的一个新的抽象概念，它代表着一种处理数据的序列。简单来说，Stream 是一系列元素的集合，这些元素可以是集合、数组、I/O 资源或者其他数据源。</p>
<p>Stream API 提供了丰富的操作方法，可以对 Stream 中的元素进行各种转换、过滤、映射、聚合等操作，从而实现对数据的处理和操作。Stream API 的设计目标是提供一种高效、可扩展和易于使用的方式来处理大量的数据。</p>
<p>Stream 具有以下几个关键特点：</p>
<ol>
<li><p><strong>数据源：</strong> Stream 可以基于不同类型的数据源创建，如集合、数组、I/O 资源等。你可以通过调用集合或数组的 stream() 方法来创建一个流。</p>
</li>
<li><p><strong>数据处理：</strong> Stream 提供了丰富的操作方法，可以对流中的元素进行处理。这些操作可以按需求组合起来，形成一个流水线式的操作流程。常见的操作包括过滤（filter）、映射（map）、排序（sorted）、聚合（reduce）等。</p>
</li>
<li><p><strong>惰性求值：</strong> Stream 的操作是惰性求值的，也就是说在定义操作流程时，不会立即执行实际计算。只有当终止操作（如收集结果或遍历元素）被调用时，才会触发实际的计算过程。</p>
</li>
<li><p><strong>不可变性：</strong> Stream 是不可变的，它不会修改原始数据源，也不会产生中间状态或副作用。每个操作都会返回一个新的流对象，以保证数据的不可变性。</p>
</li>
<li><p><strong>并行处理：</strong> Stream 支持并行处理，可以通过 parallel() 方法将流转换为并行流，利用多核处理器的优势来提高处理速度。在某些情况下，使用并行流可以极大地提高程序的性能。</p>
</li>
</ol>
<p>通过使用 Stream，我们可以使用简洁、函数式的方式处理数据。相比传统的循环和条件语句，Stream 提供了更高层次的抽象，使代码更具可读性、简洁性和可维护性。它是一种强大的工具，可以帮助我们更有效地处理和操作集合数据。</p>
<h3 id="如何创建-Stream-对象"><a href="#如何创建-Stream-对象" class="headerlink" title="如何创建 Stream 对象"></a>如何创建 Stream 对象</h3><p>1.从集合创建：我们可以通过调用集合的 <code>stream()</code> 方法来创建一个 Stream 对象。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = numbers.stream();</span><br></pre></td></tr></table></figure>

<p>2.从数组创建：Java 8 引入了 Arrays 类的 stream() 方法，我们可以使用它来创建一个 Stream 对象。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">"Alice"</span>, <span class="string">"Bob"</span>, <span class="string">"Carol"</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; stream = Arrays.stream(names);</span><br></pre></td></tr></table></figure>

<p>3.通过 Stream.of() 创建：我们可以使用 <code>Stream.of()</code> 方法直接将一组元素转换为 Stream 对象。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>4.通过 Stream.builder() 创建：如果我们不确定要添加多少个元素到 Stream 中，可以使用 Stream.builder() 创建一个 Stream.Builder 对象，并使用其 add() 方法来逐个添加元素，最后调用 build() 方法生成 Stream 对象。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stream.Builder&lt;String&gt; builder = Stream.builder();</span><br><span class="line">builder.add(<span class="string">"Apple"</span>);</span><br><span class="line">builder.add(<span class="string">"Banana"</span>);</span><br><span class="line">builder.add(<span class="string">"Cherry"</span>);</span><br><span class="line">Stream&lt;String&gt; stream = builder.build();</span><br></pre></td></tr></table></figure>

<p>5.从 I/O 资源创建：Java 8 引入了一些新的 I/O 类（如 BufferedReader、Files 等），它们提供了很多方法来读取文件、网络流等数据。这些方法通常返回一个 Stream 对象，可以直接使用。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">"data.txt"</span>);</span><br><span class="line"><span class="keyword">try</span> (Stream&lt;String&gt; stream = Files.lines(path)) &#123;</span><br><span class="line">    <span class="comment">// 使用 stream 处理数据</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.通过生成器创建：除了从现有的数据源创建 Stream，我们还可以使用生成器来生成元素。Java 8 中提供了 Stream.generate() 方法和 Stream.iterate() 方法来创建无限 Stream。例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.generate(() -&gt; <span class="number">0</span>); <span class="comment">// 创建一个无限流，每个元素都是 0</span></span><br><span class="line">Stream&lt;Integer&gt; stream = Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">1</span>); <span class="comment">// 创建一个无限流，从 0 开始递增</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，Stream 对象是一种一次性使用的对象，它只能被消费一次。一旦对 Stream 执行了终止操作（如收集结果、遍历元素），Stream 就会被关闭，后续无法再使用。因此，在使用 Stream 时，需要根据需要重新创建新的 Stream 对象。</p>
<h3 id="常用的-Stream-操作方法"><a href="#常用的-Stream-操作方法" class="headerlink" title="常用的 Stream 操作方法"></a>常用的 Stream 操作方法</h3><p><strong>1.过滤（Filter）：</strong> <code>filter()</code> 方法接受一个 Predicate 函数作为参数，用于过滤 Stream 中的元素。只有满足 Predicate 条件的元素会被保留下来。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Stream&lt;Integer&gt; filteredStream = stream.filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>); <span class="comment">// 过滤出偶数</span></span><br></pre></td></tr></table></figure>

<p><strong>2.映射（Map）：</strong> <code>map()</code> 方法接受一个 Function 函数作为参数，用于对 Stream 中的元素进行映射转换。对每个元素应用函数后的结果会构成一个新的 Stream。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"cherry"</span>);</span><br><span class="line">Stream&lt;Integer&gt; mappedStream = stream.map(s -&gt; s.length()); <span class="comment">// 映射为单词长度</span></span><br></pre></td></tr></table></figure>

<p><strong>3.扁平映射（FlatMap）：</strong> <code>flatMap()</code> 方法类似于 <code>map()</code> 方法，不同之处在于它可以将每个元素映射为一个流，并将所有流连接成一个流。这主要用于解决嵌套集合的情况。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; nestedList = Arrays.asList(</span><br><span class="line">    Arrays.asList(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">    Arrays.asList(<span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">    Arrays.asList(<span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">);</span><br><span class="line">Stream&lt;Integer&gt; flattenedStream = nestedList.stream().flatMap(List::stream); <span class="comment">// 扁平化为一个流</span></span><br></pre></td></tr></table></figure>

<p><strong>4.截断（Limit）：</strong> <code>limit()</code> 方法可以限制 Stream 的大小，只保留前 n 个元素。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Stream&lt;Integer&gt; limitedStream = stream.limit(<span class="number">3</span>); <span class="comment">// 只保留前 3 个元素</span></span><br></pre></td></tr></table></figure>

<p><strong>5.跳过（Skip）：</strong> <code>skip()</code> 方法可以跳过 Stream 中的前 n 个元素，返回剩下的元素组成的新 Stream。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Stream&lt;Integer&gt; skippedStream = stream.skip(<span class="number">2</span>); <span class="comment">// 跳过前 2 个元素</span></span><br></pre></td></tr></table></figure>

<p><strong>6.排序（Sorted）：</strong> <code>sorted()</code> 方法用于对 Stream 中的元素进行排序，默认是自然顺序排序。还可以提供自定义的 Comparator 参数来指定排序规则。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">Stream&lt;Integer&gt; sortedStream = stream.sorted(); <span class="comment">// 自然顺序排序</span></span><br></pre></td></tr></table></figure>

<p><strong>7.去重（Distinct）：</strong> <code>distinct()</code> 方法用于去除 Stream 中的重复元素，根据元素的 <code>equals()</code> 和 <code>hashCode()</code> 方法来判断是否重复。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">Stream&lt;Integer&gt; distinctStream = stream.distinct(); <span class="comment">// 去重</span></span><br></pre></td></tr></table></figure>

<p><strong>8.汇总（Collect）：</strong> <code>collect()</code> 方法用于将 Stream 中的元素收集到结果容器中，如 List、Set、Map 等。可以使用预定义的 Collectors 类提供的工厂方法来创建收集器，也可以自定义收集器。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"cherry"</span>);</span><br><span class="line">List&lt;String&gt; collectedList = stream.collect(Collectors.toList()); <span class="comment">// 收集为 List</span></span><br></pre></td></tr></table></figure>

<p><strong>9.归约（Reduce）：</strong> <code>reduce()</code> 方法用于将 Stream 中的元素依次进行二元操作，得到一个最终的结果。它接受一个初始值和一个 BinaryOperator 函数作为参数。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Optional&lt;Integer&gt; sum = stream.reduce((a, b) -&gt; a + b); <span class="comment">// 对所有元素求和</span></span><br></pre></td></tr></table></figure>

<p><strong>10.统计（Summary Statistics）：</strong> <code>summaryStatistics()</code> 方法可以从 Stream 中获取一些常用的统计信息，如元素个数、最小值、最大值、总和和平均值。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IntStream stream = IntStream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">IntSummaryStatistics stats = stream.summaryStatistics();</span><br><span class="line">System.out.println(<span class="string">"Count: "</span> + stats.getCount());</span><br><span class="line">System.out.println(<span class="string">"Min: "</span> + stats.getMin());</span><br><span class="line">System.out.println(<span class="string">"Max: "</span> + stats.getMax());</span><br><span class="line">System.out.println(<span class="string">"Sum: "</span> + stats.getSum());</span><br><span class="line">System.out.println(<span class="string">"Average: "</span> + stats.getAverage());</span><br></pre></td></tr></table></figure>

<p>以上只是 Stream API 提供的一部分常用操作方法，还有许多其他操作方法，如匹配（Match）、查找（Find）、遍历（ForEach）等</p>
<h2 id="2-Stream-的中间操作"><a href="#2-Stream-的中间操作" class="headerlink" title="2 Stream 的中间操作"></a>2 Stream 的中间操作</h2><h3 id="过滤操作（filter）"><a href="#过滤操作（filter）" class="headerlink" title="过滤操作（filter）"></a>过滤操作（filter）</h3><p>过滤操作（filter）是 Stream API 中的一种常用操作方法，它接受一个 Predicate 函数作为参数，用于过滤 Stream 中的元素。只有满足 Predicate 条件的元素会被保留下来，而不满足条件的元素将被过滤掉。</p>
<p>过滤操作的语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span></span><br></pre></td></tr></table></figure>

<p>其中，<code>T</code> 表示 Stream 元素的类型，<code>predicate</code> 是一个函数式接口 <code>Predicate</code> 的实例，它的泛型参数和 Stream 元素类型一致。</p>
<p>使用过滤操作可以根据自定义的条件来筛选出符合要求的元素，从而对 Stream 进行精确的数据过滤。</p>
<p>下面是一个示例，演示如何使用过滤操作筛选出一个整数流中的偶数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Stream&lt;Integer&gt; filteredStream = stream.filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">filteredStream.forEach(System.out::println); <span class="comment">// 输出结果: 2 4</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们首先创建了一个包含整数的 Stream，并调用 <code>filter()</code> 方法传入一个 Lambda 表达式 <code>n -&gt; n % 2 == 0</code>，表示要筛选出偶数。然后通过 <code>forEach()</code> 方法遍历输出结果。</p>
<p>需要注意的是，过滤操作返回的是一个新的 Stream 实例，原始的 Stream 不会受到改变。这也是 Stream 操作方法的一个重要特点，它们通常返回一个新的 Stream 实例，以便进行链式调用和组合多个操作步骤。</p>
<p>在实际应用中，过滤操作可以与其他操作方法结合使用，如映射（map）、排序（sorted）、归约（reduce）等，以实现更复杂的数据处理和转换。而过滤操作本身的优点在于，可以高效地对大型数据流进行筛选，从而提高程序的性能和效率。</p>
<h3 id="映射操作（map）"><a href="#映射操作（map）" class="headerlink" title="映射操作（map）"></a>映射操作（map）</h3><p>映射操作（map）是 Stream API 中的一种常用操作方法，它接受一个 Function 函数作为参数，用于对 Stream 中的每个元素进行映射转换，生成一个新的 Stream。</p>
<p>映射操作的语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span></span></span><br></pre></td></tr></table></figure>

<p>其中，<code>T</code> 表示原始 Stream 的元素类型，<code>R</code> 表示映射后的 Stream 的元素类型，<code>mapper</code> 是一个函数式接口 <code>Function</code> 的实例，它的泛型参数分别是原始 Stream 元素的类型和映射后的元素类型。</p>
<p>使用映射操作可以对 Stream 中的元素逐个进行处理或转换，从而获得一个新的 Stream。这个过程通常涉及对每个元素应用传入的函数，根据函数的返回值来构建新的元素。</p>
<p>下面是一个示例，演示如何使用映射操作将一个字符串流中的每个字符串转换为其长度：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"cherry"</span>);</span><br><span class="line">Stream&lt;Integer&gt; mappedStream = stream.map(s -&gt; s.length());</span><br><span class="line"><span class="comment">// 输出结果: 5 6 6</span></span><br><span class="line">mappedStream.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们首先创建了一个包含字符串的 Stream，并调用 <code>map()</code> 方法传入一个 Lambda 表达式 <code>s -&gt; s.length()</code>，表示要将每个字符串转换为其长度。然后通过 <code>forEach()</code> 方法遍历输出结果。</p>
<p>需要注意的是，映射操作返回的是一个新的 Stream 实例，原始的 Stream 不会受到改变。这也是 Stream 操作方法的一个重要特点，它们通常返回一个新的 Stream 实例，以便进行链式调用和组合多个操作步骤。</p>
<p>在实际应用中，映射操作可以与其他操作方法结合使用，如过滤（filter）、排序（sorted）、归约（reduce）等，以实现更复杂的数据处理和转换。而映射操作本身的优点在于，可以通过简单的函数变换实现对原始数据的转换，减少了繁琐的循环操作，提高了代码的可读性和维护性。</p>
<p>需要注意的是，映射操作可能引发空指针异常（NullPointerException），因此在执行映射操作时，应确保原始 Stream 中不包含空值，并根据具体情况进行空值处理。</p>
<h3 id="排序操作（sorted）"><a href="#排序操作（sorted）" class="headerlink" title="排序操作（sorted）"></a>排序操作（sorted）</h3><p>排序操作（sorted）是 Stream API 中的一种常用操作方法，它用于对 Stream 中的元素进行排序。排序操作可以按照自然顺序或者使用自定义的比较器进行排序。</p>
<p>排序操作的语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">sorted</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">sorted</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span></span></span><br></pre></td></tr></table></figure>

<p>第一种语法形式中，<code>sorted()</code> 方法会根据元素的自然顺序进行排序。如果元素实现了 <code>Comparable</code> 接口并且具备自然顺序，那么可以直接调用该方法进行排序。</p>
<p>第二种语法形式中，<code>sorted(Comparator&lt;? super T&gt; comparator)</code> 方法接受一个比较器（Comparator）作为参数，用于指定元素的排序规则。通过自定义比较器，可以对非 <code>Comparable</code> 类型的对象进行排序。</p>
<p>下面是一个示例，演示如何使用排序操作对一个字符串流进行排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"banana"</span>, <span class="string">"apple"</span>, <span class="string">"cherry"</span>);</span><br><span class="line">Stream&lt;String&gt; sortedStream = stream.sorted();</span><br><span class="line">sortedStream.forEach(System.out::println); <span class="comment">// 输出结果: apple banana cherry</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们首先创建了一个包含字符串的 Stream，并直接调用 <code>sorted()</code> 方法进行排序。然后通过 <code>forEach()</code> 方法遍历输出结果。</p>
<p>需要注意的是，排序操作返回的是一个新的 Stream 实例，原始的 Stream 不会受到改变。这也是 Stream 操作方法的一个重要特点，它们通常返回一个新的 Stream 实例，以便进行链式调用和组合多个操作步骤。</p>
<p>在实际应用中，排序操作可以与其他操作方法结合使用，如过滤（filter）、映射（map）、归约（reduce）等，以实现更复杂的数据处理和转换。排序操作本身的优点在于，可以将数据按照特定的顺序排列，便于查找、比较和分析。</p>
<p>需要注意的是，排序操作可能会影响程序的性能，特别是对于大型数据流或者复杂的排序规则。因此，在实际应用中，需要根据具体情况进行权衡和优化，选择合适的算法和数据结构来提高排序的效率。</p>
<h3 id="截断操作（limit-和-skip）"><a href="#截断操作（limit-和-skip）" class="headerlink" title="截断操作（limit 和 skip）"></a>截断操作（limit 和 skip）</h3><p>截断操作（limit和skip）是 Stream API 中常用的操作方法，用于在处理流的过程中对元素进行截断。</p>
<ol>
<li><p><strong>limit(n)：</strong> 保留流中的前n个元素，返回一个包含最多n个元素的新流。如果流中元素少于n个，则返回原始流。</p>
</li>
<li><p><strong>skip(n)：</strong> 跳过流中的前n个元素，返回一个包含剩余元素的新流。如果流中元素少于n个，则返回一个空流。</p>
</li>
</ol>
<p>下面分别详细介绍这两个方法的使用。</p>
<p>limit(n) 方法示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Stream&lt;Integer&gt; limitedStream = stream.limit(<span class="number">3</span>);</span><br><span class="line">limitedStream.forEach(System.out::println); <span class="comment">// 输出结果: 1 2 3</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个包含整数的 Stream，并调用 <code>limit(3)</code> 方法来保留前三个元素。然后使用 <code>forEach()</code> 方法遍历输出结果。</p>
<p>skip(n) 方法示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Stream&lt;Integer&gt; skippedStream = stream.skip(<span class="number">2</span>);</span><br><span class="line">skippedStream.forEach(System.out::println); <span class="comment">// 输出结果: 3 4 5</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个包含整数的 Stream，并调用 <code>skip(2)</code> 方法来跳过前两个元素。然后使用 <code>forEach()</code> 方法遍历输出结果。</p>
<p>需要注意的是，截断操作返回的是一个新的 Stream 实例，原始的 Stream 不会受到改变。这也是 Stream 操作方法的一个重要特点，它们通常返回一个新的 Stream 实例，以便进行链式调用和组合多个操作步骤。</p>
<p>截断操作在处理大型数据流或需要对数据进行切分和分页显示的场景中非常有用。通过限制或跳过指定数量的元素，可以控制数据的大小和范围，提高程序的性能并减少不必要的计算。</p>
<p>需要注意的是，在使用截断操作时需要注意流的有界性。如果流是无界的（例如 <code>Stream.generate()</code>），那么使用 <code>limit()</code> 方法可能导致程序陷入无限循环，而使用 <code>skip()</code> 方法则没有意义。</p>
<h2 id="3-Stream-的终端操作"><a href="#3-Stream-的终端操作" class="headerlink" title="3 Stream 的终端操作"></a>3 Stream 的终端操作</h2><h3 id="forEach-和-peek"><a href="#forEach-和-peek" class="headerlink" title="forEach 和 peek"></a>forEach 和 peek</h3><p>forEach和peek都是Stream API中用于遍历流中元素的操作方法，它们在处理流的过程中提供了不同的功能和使用场景。</p>
<ol>
<li><strong>forEach：</strong> forEach是一个终端操作方法，它接受一个Consumer函数作为参数，对流中的每个元素执行该函数。它没有返回值，因此无法将操作结果传递给后续操作。forEach会遍历整个流，对每个元素执行相同的操作。</li>
</ol>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"Alice"</span>, <span class="string">"Bob"</span>, <span class="string">"Charlie"</span>);</span><br><span class="line">names.stream()</span><br><span class="line">     .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>这个示例中，我们创建了一个包含字符串的List，并通过stream()方法将其转换为流。然后使用forEach方法遍历输出每个元素的值。</p>
<ol start="2">
<li><strong>peek：</strong> peek是一个中间操作方法，它接受一个Consumer函数作为参数，对流中的每个元素执行该函数。与forEach不同的是，peek方法会返回一个新的流，该流中的元素和原始流中的元素相同。</li>
</ol>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"Alice"</span>, <span class="string">"Bob"</span>, <span class="string">"Charlie"</span>);</span><br><span class="line">List&lt;String&gt; upperCaseNames = names.stream()</span><br><span class="line">                                   .map(String::toUpperCase)</span><br><span class="line">                                   .peek(System.out::println)</span><br><span class="line">                                   .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们首先将List转换为流，并通过map方法将每个元素转换为大写字母。然后使用peek方法在转换之前输出每个元素的值。最后通过collect方法将元素收集到一个新的List中。</p>
<p>需要注意的是，无论是forEach还是peek，它们都是用于在流的处理过程中执行操作。区别在于forEach是终端操作，不返回任何结果，而peek是中间操作，可以和其他操作方法进行组合和链式调用。</p>
<p>根据使用场景和需求，选择使用forEach或peek来遍历流中的元素。如果只是需要遍历输出元素，不需要操作结果，则使用forEach。如果需要在遍历过程中执行一些其他操作，并将元素传递给后续操作，则使用peek。</p>
<h2 id="4-聚合操作（reduce-和-collect）"><a href="#4-聚合操作（reduce-和-collect）" class="headerlink" title="4 聚合操作（reduce 和 collect）"></a>4 聚合操作（reduce 和 collect）</h2><p>reduce和collect都是Stream API中用于聚合操作的方法，它们可以将流中的元素进行汇总、计算和收集。</p>
<ol>
<li><strong>reduce：</strong> reduce是一个终端操作方法，它接受一个BinaryOperator函数作为参数，对流中的元素逐个进行合并操作，最终得到一个结果。该方法会将流中的第一个元素作为初始值，然后将初始值与下一个元素传递给BinaryOperator函数进行计算，得到的结果再与下一个元素进行计算，以此类推，直到遍历完所有元素。</li>
</ol>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Optional&lt;Integer&gt; sum = numbers.stream()</span><br><span class="line">                               .reduce((a, b) -&gt; a + b);</span><br><span class="line">sum.ifPresent(System.out::println); <span class="comment">// 输出结果: 15</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个包含整数的List，并通过stream()方法将其转换为流。然后使用reduce方法对流中的元素进行求和操作，将每个元素依次相加，得到结果15。</p>
<ol start="2">
<li><strong>collect：</strong> collect是一个终端操作方法，它接受一个Collector接口的实现作为参数，对流中的元素进行收集和汇总的操作。Collector接口定义了一系列用于聚合操作的方法，例如收集元素到List、Set、Map等容器中，或进行字符串连接、分组、计数等操作。</li>
</ol>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"Alice"</span>, <span class="string">"Bob"</span>, <span class="string">"Charlie"</span>);</span><br><span class="line">String joinedNames = names.stream()</span><br><span class="line">                          .collect(Collectors.joining(<span class="string">", "</span>));</span><br><span class="line">System.out.println(joinedNames); <span class="comment">// 输出结果: Alice, Bob, Charlie</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个包含字符串的List，并通过stream()方法将其转换为流。然后使用collect方法将流中的元素连接成一个字符串，每个元素之间使用逗号和空格分隔。</p>
<p>需要注意的是，reduce和collect都是终端操作，它们都会触发流的遍历和处理。不同的是，reduce方法用于对流中的元素进行累积计算，得到一个最终结果；而collect方法用于对流中的元素进行收集和汇总，得到一个容器或其他自定义的结果。</p>
<p>在选择使用reduce还是collect时，可以根据具体需求和操作类型来决定。如果需要对流中的元素进行某种计算和合并操作，得到一个结果，则使用reduce。如果需要将流中的元素收集到一个容器中，进行汇总、分组、计数等操作，则使用collect。</p>
<h2 id="5-匹配操作（allMatch、anyMatch-和-noneMatch）"><a href="#5-匹配操作（allMatch、anyMatch-和-noneMatch）" class="headerlink" title="5 匹配操作（allMatch、anyMatch 和 noneMatch）"></a>5 匹配操作（allMatch、anyMatch 和 noneMatch）</h2><p>在 Stream API 中，allMatch、anyMatch 和 noneMatch 是用于进行匹配操作的方法，它们可以用来检查流中的元素是否满足特定的条件。</p>
<ol>
<li><strong>allMatch：</strong> allMatch 方法用于判断流中的所有元素是否都满足给定的条件。当流中的所有元素都满足条件时，返回 true；如果存在一个元素不满足条件，则返回 false。</li>
</ol>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">boolean</span> allEven = numbers.stream()</span><br><span class="line">                         .allMatch(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">System.out.println(allEven); <span class="comment">// 输出结果: false</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个包含整数的 List，并通过 stream() 方法将其转换为流。然后使用 allMatch 方法判断流中的元素是否都是偶数。由于列表中存在奇数，所以返回 false。</p>
<ol start="2">
<li><strong>anyMatch：</strong> anyMatch 方法用于判断流中是否存在至少一个元素满足给定的条件。当流中至少有一个元素满足条件时，返回 true；如果没有元素满足条件，则返回 false。</li>
</ol>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">boolean</span> hasEven = numbers.stream()</span><br><span class="line">                         .anyMatch(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">System.out.println(hasEven); <span class="comment">// 输出结果: true</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个包含整数的 List，并通过 stream() 方法将其转换为流。然后使用 anyMatch 方法判断流中是否存在偶数。由于列表中存在偶数，所以返回 true。</p>
<ol start="3">
<li><strong>noneMatch：</strong> noneMatch 方法用于判断流中的所有元素是否都不满足给定的条件。当流中没有元素满足条件时，返回 true；如果存在一个元素满足条件，则返回 false。</li>
</ol>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">boolean</span> noneNegative = numbers.stream()</span><br><span class="line">                             .noneMatch(n -&gt; n &lt; <span class="number">0</span>);</span><br><span class="line">System.out.println(noneNegative); <span class="comment">// 输出结果: true</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个包含整数的 List，并通过 stream() 方法将其转换为流。然后使用 noneMatch 方法判断流中的元素是否都是非负数。由于列表中的元素都是非负数，所以返回 true。</p>
<p>需要注意的是，allMatch、anyMatch 和 noneMatch 都是终端操作，它们会遍历流中的元素直到满足条件或处理完所有元素。在性能上，allMatch 和 noneMatch 在第一个不匹配的元素处可以立即返回结果，而 anyMatch 在找到第一个匹配的元素时就可以返回结果。</p>
<h2 id="6-查找操作（findFirst-和-findAny）"><a href="#6-查找操作（findFirst-和-findAny）" class="headerlink" title="6 查找操作（findFirst 和 findAny）"></a>6 查找操作（findFirst 和 findAny）</h2><p>在 Stream API 中，findFirst 和 findAny 是用于查找操作的方法，它们可以用来从流中获取满足特定条件的元素。</p>
<ol>
<li><strong>findFirst：</strong> findFirst 方法用于返回流中的第一个元素。它返回一个 Optional 对象，如果流为空，则返回一个空的 Optional；如果流非空，则返回流中的第一个元素的 Optional。</li>
</ol>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"Alice"</span>, <span class="string">"Bob"</span>, <span class="string">"Charlie"</span>);</span><br><span class="line">Optional&lt;String&gt; first = names.stream()</span><br><span class="line">                              .findFirst();</span><br><span class="line">first.ifPresent(System.out::println); <span class="comment">// 输出结果: Alice</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个包含字符串的 List，并通过 stream() 方法将其转换为流。然后使用 findFirst 方法获取流中的第一个元素，并使用 ifPresent 方法判断 Optional 是否包含值，并进行相应的处理。</p>
<ol start="2">
<li><strong>findAny：</strong> findAny 方法用于返回流中的任意一个元素。它返回一个 Optional 对象，如果流为空，则返回一个空的 Optional；如果流非空，则返回流中的任意一个元素的 Optional。在顺序流中，通常会返回第一个元素；而在并行流中，由于多线程的处理，可能返回不同的元素。</li>
</ol>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Optional&lt;Integer&gt; any = numbers.stream()</span><br><span class="line">                               .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                               .findAny();</span><br><span class="line">any.ifPresent(System.out::println); <span class="comment">// 输出结果: 2 或 4（取决于并行处理的结果）</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个包含整数的 List，并通过 stream() 方法将其转换为流。然后使用 filter 方法筛选出偶数，再使用 findAny 方法获取任意一个偶数，最后使用 ifPresent 方法判断 Optional 是否包含值，并进行相应的处理。</p>
<p>需要注意的是，findAny 在并行流中会更有优势，因为在多线程处理时，可以返回最先找到的元素，提高效率。而在顺序流中，findAny 的性能与 findFirst 相当。</p>
<h2 id="7-统计操作（count、max-和-min）"><a href="#7-统计操作（count、max-和-min）" class="headerlink" title="7 统计操作（count、max 和 min）"></a>7 统计操作（count、max 和 min）</h2><p>在 Stream API 中，count、max 和 min 是用于统计操作的方法，它们可以用来获取流中元素的数量、最大值和最小值。</p>
<ol>
<li><strong>count：</strong> count 方法用于返回流中元素的数量。它返回一个 long 类型的值，表示流中的元素个数。</li>
</ol>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">long</span> count = numbers.stream()</span><br><span class="line">                    .count();</span><br><span class="line">System.out.println(count); <span class="comment">// 输出结果: 5</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个包含整数的 List，并通过 stream() 方法将其转换为流。然后使用 count 方法获取流中元素的数量，并将结果输出。</p>
<ol start="2">
<li><strong>max：</strong>  max 方法用于返回流中的最大值。它返回一个 Optional 对象，如果流为空，则返回一个空的 Optional；如果流非空，则返回流中的最大值的 Optional。</li>
</ol>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Optional&lt;Integer&gt; max = numbers.stream()</span><br><span class="line">                               .max(Integer::compareTo);</span><br><span class="line">max.ifPresent(System.out::println); <span class="comment">// 输出结果: 5</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个包含整数的 List，并通过 stream() 方法将其转换为流。然后使用 max 方法获取流中的最大值，并使用 ifPresent 方法判断 Optional 是否包含值，并进行相应的处理。</p>
<ol start="3">
<li><strong>min：</strong>  min 方法用于返回流中的最小值。它返回一个 Optional 对象，如果流为空，则返回一个空的 Optional；如果流非空，则返回流中的最小值的 Optional。</li>
</ol>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Optional&lt;Integer&gt; min = numbers.stream()</span><br><span class="line">                               .min(Integer::compareTo);</span><br><span class="line">min.ifPresent(System.out::println); <span class="comment">// 输出结果: 1</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个包含整数的 List，并通过 stream() 方法将其转换为流。然后使用 min 方法获取流中的最小值，并使用 ifPresent 方法判断 Optional 是否包含值，并进行相应的处理。</p>
<p>这些统计操作方法提供了一种便捷的方式来对流中的元素进行数量、最大值和最小值的计算。通过返回 Optional 对象，可以避免空指针异常。</p>
<h2 id="8-并行流"><a href="#8-并行流" class="headerlink" title="8 并行流"></a>8 并行流</h2><p>并行流是 Java 8 Stream API 中的一个特性。它可以将一个流的操作在多个线程上并行执行，以提高处理大量数据时的性能。</p>
<p>在传统的顺序流中，所有的操作都是在单个线程上按照顺序执行的。而并行流则会将流的元素分成多个小块，并在多个线程上并行处理这些小块，最后将结果合并起来。这样可以充分利用多核处理器的优势，加快数据处理的速度。</p>
<p>要将一个顺序流转换为并行流，只需调用流的 parallel() 方法即可。示例代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">numbers.stream()</span><br><span class="line">       .parallel()</span><br><span class="line">       .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个包含整数的 List，并通过 stream() 方法将其转换为流。接着调用 parallel() 方法将流转换为并行流，然后使用 forEach 方法遍历流中的元素并输出。</p>
<p>需要注意的是，并行流的使用并不总是适合所有情况。并行流的优势主要体现在数据量较大、处理时间较长的场景下。对于小规模数据和简单的操作，顺序流可能更加高效。在选择使用并行流时，需要根据具体情况进行评估和测试，以确保获得最佳的性能。</p>
<p>此外，还需要注意并行流在某些情况下可能引入线程安全的问题。如果多个线程同时访问共享的可变状态，可能会导致数据竞争和不确定的结果。因此，在处理并行流时，应当避免共享可变状态，或采用适当的同步措施来确保线程安全。</p>
<p>使用并行流可以通过利用多线程并行处理数据，从而提高程序的执行性能。下面是一些使用并行流提高性能的常见方法：</p>
<ol>
<li><strong>创建并行流：</strong> 要创建一个并行流，只需在普通流上调用 <code>parallel()</code> 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Stream&lt;Integer&gt; parallelStream = numbers.parallelStream();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>利用任务并行性：</strong> 并行流会将数据分成多个小块，并在多个线程上并行处理这些小块。这样可以充分利用多核处理器的优势。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">numbers.parallelStream()</span><br><span class="line">       .map(n -&gt; compute(n)) <span class="comment">// 在多个线程上并行处理计算</span></span><br><span class="line">       .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，使用 <code>map</code> 方法对流中的每个元素进行计算。由于并行流的特性，计算操作会在多个线程上并行执行，提高了计算的效率。</p>
<ol start="3">
<li><p><strong>避免共享可变状态：</strong> 在并行流中，多个线程会同时操作数据。如果共享可变状态（如全局变量）可能导致数据竞争和不确定的结果。因此，避免在并行流中使用共享可变状态，或者采取适当的同步措施来确保线程安全。</p>
</li>
<li><p><strong>使用合适的操作：</strong> 一些操作在并行流中的性能表现更好，而另一些操作则可能导致性能下降。一般来说，在并行流中使用基于聚合的操作（如 <code>reduce</code>、<code>collect</code>）和无状态转换操作（如 <code>map</code>、<code>filter</code>）的性能较好，而有状态转换操作（如 <code>sorted</code>）可能会导致性能下降。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good performance</span></span><br><span class="line"><span class="keyword">int</span> sum = numbers.parallelStream()</span><br><span class="line">                 .reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good performance</span></span><br><span class="line">List&lt;Integer&gt; evenNumbers = numbers.parallelStream()</span><br><span class="line">                                   .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                                   .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// potential performance degradation</span></span><br><span class="line">List&lt;Integer&gt; sortedNumbers = numbers.parallelStream()</span><br><span class="line">                                     .sorted()</span><br><span class="line">                                     .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>reduce</code> 和 <code>filter</code> 的操作在并行流中具有良好的性能，而 <code>sorted</code> 操作可能导致性能下降。</p>
<p>除了上述方法，还应根据具体情况进行评估和测试，并行流是否能够提高性能。有时候，并行流的开销（如线程的创建和销毁、数据切割和合并等）可能超过了其带来的性能提升。因此，在选择使用并行流时，应该根据数据量和操作复杂度等因素进行综合考虑，以确保获得最佳的性能提升。</p>
<h2 id="9-实践应用示例"><a href="#9-实践应用示例" class="headerlink" title="9 实践应用示例"></a>9 实践应用示例</h2><h3 id="使用-Stream-处理集合数据"><a href="#使用-Stream-处理集合数据" class="headerlink" title="使用 Stream 处理集合数据"></a>使用 Stream 处理集合数据</h3><ol>
<li>筛选出长度大于等于5的字符串，并打印输出：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"orange"</span>, <span class="string">"grapefruit"</span>, <span class="string">"kiwi"</span>);</span><br><span class="line">list.stream()</span><br><span class="line">    .filter(s -&gt; s.length() &gt;= <span class="number">5</span>)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">banana</span><br><span class="line">orange</span><br><span class="line">grapefruit</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将集合中的每个字符串转换为大写，并收集到新的列表中：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"orange"</span>, <span class="string">"grapefruit"</span>, <span class="string">"kiwi"</span>);</span><br><span class="line">List&lt;String&gt; resultList = list.stream()</span><br><span class="line">                              .map(String::toUpperCase)</span><br><span class="line">                              .collect(Collectors.toList());</span><br><span class="line">System.out.println(resultList);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[APPLE, BANANA, ORANGE, GRAPEFRUIT, KIWI]</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>统计集合中以字母”a”开头的字符串的数量：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"orange"</span>, <span class="string">"grapefruit"</span>, <span class="string">"kiwi"</span>);</span><br><span class="line"><span class="keyword">long</span> count = list.stream()</span><br><span class="line">                 .filter(s -&gt; s.startsWith(<span class="string">"a"</span>))</span><br><span class="line">                 .count();</span><br><span class="line">System.out.println(count);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用并行流来提高处理速度，筛选出长度小于等于5的字符串，并打印输出：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"orange"</span>, <span class="string">"grapefruit"</span>, <span class="string">"kiwi"</span>);</span><br><span class="line">list.parallelStream()</span><br><span class="line">    .filter(s -&gt; s.length() &lt;= <span class="number">5</span>)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apple</span><br><span class="line">kiwi</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>使用 Stream 对集合中的整数求和：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">int</span> sum = numbers.stream()</span><br><span class="line">                 .mapToInt(Integer::intValue)</span><br><span class="line">                 .sum();</span><br><span class="line">System.out.println(sum);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-Stream-进行文件操作"><a href="#使用-Stream-进行文件操作" class="headerlink" title="使用 Stream 进行文件操作"></a>使用 Stream 进行文件操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileStreamExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String fileName = <span class="string">"file.txt"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取文件内容并创建 Stream</span></span><br><span class="line">        <span class="keyword">try</span> (Stream&lt;String&gt; stream = Files.lines(Paths.get(fileName))) &#123;</span><br><span class="line">            <span class="comment">// 打印文件的每一行内容</span></span><br><span class="line">            stream.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 统计文件的行数</span></span><br><span class="line">            <span class="keyword">long</span> count = stream.count();</span><br><span class="line">            System.out.println(<span class="string">"总行数："</span> + count);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 筛选包含关键词的行并打印输出</span></span><br><span class="line">            stream.filter(line -&gt; line.contains(<span class="string">"keyword"</span>))</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将文件内容转换为大写并打印输出</span></span><br><span class="line">            stream.map(String::toUpperCase)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将文件内容收集到 List 中</span></span><br><span class="line">            List&lt;String&gt; lines = stream.collect(Collectors.toList());</span><br><span class="line">            System.out.println(lines);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，首先指定了要读取的文件名 <code>file.txt</code>。然后使用 <code>Files.lines()</code> 方法读取文件的每一行内容，并创建一个 Stream 对象。接下来，我们对 Stream 进行一些操作：</p>
<ul>
<li><p>使用 <code>forEach()</code> 方法打印文件的每一行内容。</p>
</li>
<li><p>使用 <code>count()</code> 方法统计文件的行数。</p>
</li>
<li><p>使用 <code>filter()</code> 方法筛选出包含关键词的行，并打印输出。</p>
</li>
<li><p>使用 <code>map()</code> 方法将文件内容转换为大写，并打印输出。</p>
</li>
<li><p>使用 <code>collect()</code> 方法将文件内容收集到 List 中。</p>
</li>
</ul>
<p>请根据实际需求修改代码中的文件名、操作内容和结果处理方式。需要注意的是，在使用完 Stream 后，应及时关闭文件资源，可以使用 <code>try-with-resources</code> 语句块来自动关闭文件。另外，请处理可能出现的 IOException 异常。</p>
<h3 id="使用-Stream-实现数据转换和筛选"><a href="#使用-Stream-实现数据转换和筛选" class="headerlink" title="使用 Stream 实现数据转换和筛选"></a>使用 Stream 实现数据转换和筛选</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; names = Arrays.asList(<span class="string">"Amy"</span>, <span class="string">"Bob"</span>, <span class="string">"Charlie"</span>, <span class="string">"David"</span>, <span class="string">"Eva"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换为大写并筛选出长度大于3的名称</span></span><br><span class="line">        List&lt;String&gt; result = names.stream()</span><br><span class="line">                                   .map(String::toUpperCase)</span><br><span class="line">                                   .filter(name -&gt; name.length() &gt; <span class="number">3</span>)</span><br><span class="line">                                   .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印结果</span></span><br><span class="line">        result.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，我们首先创建了一个包含一些名字的列表。然后使用 Stream 对列表进行操作：</p>
<ul>
<li><p>使用 <code>stream()</code> 方法将列表转换为一个 Stream。</p>
</li>
<li><p>使用 <code>map()</code> 方法将每个名称转换为大写。</p>
</li>
<li><p>使用 <code>filter()</code> 方法筛选出长度大于3的名称。</p>
</li>
<li><p>使用 <code>collect()</code> 方法将筛选后的结果收集到一个新的列表中。</p>
</li>
</ul>
<p>最后，我们使用 <code>forEach()</code> 方法打印结果列表中的每个名称。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/simple/" rel="tag"># simple</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/08/31/18%E4%B8%AA%E5%B7%A5%E4%BD%9C%E4%B8%AD%E5%B8%B8%E7%94%A8Shell%E8%84%9A%E6%9C%AC/" rel="prev" title="18个工作中常用Shell脚本">
      <i class="fa fa-chevron-left"></i> 18个工作中常用Shell脚本
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Stream-基础知识"><span class="nav-number">1.</span> <span class="nav-text">1 Stream 基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是-Stream"><span class="nav-number">1.1.</span> <span class="nav-text">什么是 Stream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何创建-Stream-对象"><span class="nav-number">1.2.</span> <span class="nav-text">如何创建 Stream 对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用的-Stream-操作方法"><span class="nav-number">1.3.</span> <span class="nav-text">常用的 Stream 操作方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Stream-的中间操作"><span class="nav-number">2.</span> <span class="nav-text">2 Stream 的中间操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#过滤操作（filter）"><span class="nav-number">2.1.</span> <span class="nav-text">过滤操作（filter）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#映射操作（map）"><span class="nav-number">2.2.</span> <span class="nav-text">映射操作（map）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序操作（sorted）"><span class="nav-number">2.3.</span> <span class="nav-text">排序操作（sorted）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#截断操作（limit-和-skip）"><span class="nav-number">2.4.</span> <span class="nav-text">截断操作（limit 和 skip）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Stream-的终端操作"><span class="nav-number">3.</span> <span class="nav-text">3 Stream 的终端操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#forEach-和-peek"><span class="nav-number">3.1.</span> <span class="nav-text">forEach 和 peek</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-聚合操作（reduce-和-collect）"><span class="nav-number">4.</span> <span class="nav-text">4 聚合操作（reduce 和 collect）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-匹配操作（allMatch、anyMatch-和-noneMatch）"><span class="nav-number">5.</span> <span class="nav-text">5 匹配操作（allMatch、anyMatch 和 noneMatch）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-查找操作（findFirst-和-findAny）"><span class="nav-number">6.</span> <span class="nav-text">6 查找操作（findFirst 和 findAny）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-统计操作（count、max-和-min）"><span class="nav-number">7.</span> <span class="nav-text">7 统计操作（count、max 和 min）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-并行流"><span class="nav-number">8.</span> <span class="nav-text">8 并行流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-实践应用示例"><span class="nav-number">9.</span> <span class="nav-text">9 实践应用示例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-Stream-处理集合数据"><span class="nav-number">9.1.</span> <span class="nav-text">使用 Stream 处理集合数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-Stream-进行文件操作"><span class="nav-number">9.2.</span> <span class="nav-text">使用 Stream 进行文件操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-Stream-实现数据转换和筛选"><span class="nav-number">9.3.</span> <span class="nav-text">使用 Stream 实现数据转换和筛选</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="宁中老程"
      src="/images/pao.gif">
  <p class="site-author-name" itemprop="name">宁中老程</p>
  <div class="site-description" itemprop="description">CV工程师，面向搜索引擎编程</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">宁中老程</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":300,"height":600},"mobile":{"show":false},"log":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>
